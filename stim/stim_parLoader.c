/******************************************************************************
 * "stim_parLoader.c"
 * 
 * This file has been generated by the ParLoader.
 *
 * This file is able to read a text parameter file (key=value) and load the
 * corresponding content to the specified structure.
 *
 * author:  Christan Madsen
 * date:    2015-04-03 (initial)
 * version: BETA
 *****************************************************************************/

#include <stdbool.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <Python.h>

#include "stim_parLoader.h"
#include "no_dmc_util.h" // Make use of several utils from the NO_DMC_LIB
//#include "no_dmc_debug.h"


// *** START INCLUDE GUARD ****************************************************
// The following is common to all parLoader 'instance'.

#ifndef _PARLOADER_C_GUARD
#define _PARLOADER_C_GUARD


// TODO to see if need to be set as PIOSTRING MAX LENGTH...
#define MAX_LINE_LENGTH 256

// This is the prefix used in parameter file to indicate the list number element
#define PARAM_PREFIX_LIST "number_of_"


// This structure allow to store parameters information
typedef struct {
  char *name;     // name of the parameter
  bool isList;    // 'false' for standard and 'true' for list
  bool mandatory; // 'true' if param presence is mandatory, 'false' otherwise. Note that in case of 'false' we have to update the flag value.
  bool found;     // to remember if we found the param
//  char *type;     // data type of the parameter : will be used for convertion from string to value. Type can be any of those listed in no_dmc_piolib_type_def.h
} paramDef;


//plip
/* ---------------------------------------------------------------------------------*/
int getListSize(PyObject * params,char * name){
  /* Function that return the size of list via list name */
  //name = "number_of_"+name
  //name = strcat("number_of_",name);
  int sizeNewName = strlen(PARAM_PREFIX_LIST)+ strlen( name ) + 1;
  char * newName = (char *) malloc( sizeNewName );

  strcpy(newName,PARAM_PREFIX_LIST);
  strcat(newName,name);

  PyObject * tmp_value=(int)PyLong_AsLong(PyDict_GetItemString(params,newName));

  free(newName);

  return tmp_value;
}
/* ---------------------------------------------------------------------------------*/
int testParam(PyObject * params,char * name){
 /* test if name is in parameters list with keywords form PyObject =>params
  Params needed :
    name = keyword
  */
  PyObject * tmp_value=PyDict_GetItemString(params,name);
  if(tmp_value == NULL) return 1;
  return 0;
}
/* ---------------------------------------------------------------------------------*/
void strip_ext(char *fname)
{
    char *end = fname + strlen(fname);

    while (end > fname && *end != '.') {
        --end;
    }

    if (end > fname) {
        *end = '\0';
    }
}
/* ---------------------------------------------------------------------------------*/
PyObject * load_PyParams(char* path){
    /* Load python parameters form file gived in parameters path */    

    // init variables
    PyObject *pName, *pModule, *pDict, *pFunc;
    PyObject * params;


    // Initialize the Python Interpreter
    Py_Initialize();

    strip_ext(path);
    
    //add current path to python
    PyRun_SimpleString("import sys");
    PyRun_SimpleString("import os");
    PyRun_SimpleString("sys.path.append(os.getcwd())");

    // Build the name object
    pName = PyUnicode_FromString(path);
    
    // Load the module object
    pModule = PyImport_Import(pName);

    if ((pModule = PyImport_Import(pName)) == NULL) {
      fprintf(stderr,"Error: PyImport_Import\n");
      exit(0);
    }
 
    // pDict is a borrowed reference 
    pDict = PyModule_GetDict(pModule);

    // pFunc is also a borrowed reference 
    pFunc = PyDict_GetItemString(pDict, "main");

    if (PyCallable_Check(pFunc)){
        params = PyObject_CallObject(pFunc, NULL);
        
    }else{
        PyErr_Print();
        exit(0);
    }

    
 return params;
  
}
/* ---------------------------------------------------------------------------------*/
PyObject * getParam(PyObject * params,char * pName){
  /* get parameters with keywords form PyObject =>params 
  Params needed : 
    pName = keyword
  */ 
  
  PyObject * tmp_value=PyDict_GetItemString(params,pName);
  
  return tmp_value;

}
/* ---------------------------------------------------------------------------------*/
PyObject * getItemParam(PyObject * params,char * pName,int index){
  /* get item from parameter with keywords and index form PyObject =>params 
  Params needed : 
    pName = keyword
    index = index of the return param
   */  

  PyObject * tmp_value=PyDict_GetItemString(params,pName);

  tmp_value =PyList_GetItem(tmp_value,index);
  return tmp_value;

}
/* ---------------------------------------------------------------------------------*/



/**
 * Extract PIODOUBLE from the specified string value.
 */
PIODOUBLE myRead_PIODOUBLE(PIOSTRING value) {
  char *endptr;
  PIODOUBLE tmpval;
  
  tmpval = strtod(value, &endptr);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOLONG from the specified string value.
 */
PIOLONG myRead_PIOLONG(PIOSTRING value) {
  char *endptr;
  PIOLONG tmpval;
  
  tmpval = strtol(value, &endptr, 10);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOFLOAT from the specified string value.
 */
PIOFLOAT myRead_PIOFLOAT(PIOSTRING value) {
  char *endptr;
  PIOFLOAT tmpval;

  tmpval = strtof(value, &endptr);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOINT from the specified string value.
 */
PIOINT myRead_PIOINT(PIOSTRING value) {
  char *endptr;
  PIOINT tmpval;

  tmpval = strtol(value, &endptr, 10);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

// Not that there is no myRead_PIOSTRING() since the conversion is unecessary!

/**
 * Allow to retrieve the corresponding paramDef (if any) regarding the name pass in arg.
 */
paramDef *getParamDef(char *name, paramDef paramDef_list[], int paramDef_list_size) {

  int i;
  for (i = 0; i < paramDef_list_size; i++) {
    if (strcmp(name, paramDef_list[i].name) == 0) {
      return &paramDef_list[i];
    }
  }
  
  fprintf(stderr, "ERROR: Invalid parameter '%s': not defined in struct header file!\n", name);
  return NULL;
}

#endif
// *** END INCLUDE GUARD ******************************************************


// Auto generated by the python script
paramDef stim_paramDef_list[] = {
  {"bolometer", false, true, false},
  {"brimo_filename", false, true, false},
  {"stay_in_memory", false, true, false},
  {"iterations", false, true, false},
  {"BeginRing", false, true, false},
  {"EndRing", false, true, false},
  {"rings_per_read", false, true, false},
  {"signal_in", false, true, false},
  {"signal_out", false, true, false},
  {"hpr_out", false, true, false},
  {"do_SHPR", false, true, false},
  {"TOI_pixel_index", false, true, false},
  {"phase", false, true, false},
  {"random_seed", false, true, false},
  {"do_photonic_noise", false, true, false},
  {"do_LFER_convolve", false, true, false},
  {"nharm_oof", false, true, false},
  {"amp_oof_param", false, true, false},
  {"do_electronic_noise", false, true, false},
  {"do_despike_flag", false, true, false},
  {"do_sim_adu", false, true, false},
  {"sim_inl_name", false, true, false},
  {"rawgain_name", false, true, false},
  {"rawcst_name", false, true, false},
  {"fourk_name", false, true, false},
  {"add_baseline", false, true, false},
  {"electronic_noise_adu", false, true, false},
  {"do_compress_decompress", false, true, false},
  {"do_correct_adc", false, true, false},
  {"corr_inl_name", false, true, false},
  {"do_adu_to_volts", false, true, false},
  {"do_bl_demod", false, true, false},
  {"do_gaindecorr", false, true, false},
  {"use_bolometer_nonlinearity", false, true, false},
  {"thermal_baseline", false, true, false},
  {"do_LFER_deconvolve", false, true, false},
  {"deconv_LPF_FILTER", false, true, false},
  {"deconv_R_FILTER", false, true, false},
  {"do_calibrate", false, true, false},
  {"add_final_toi", false, true, false},
  {"add_final_toi_factor", false, true, false},
  {"add_hpr_name", true, false, false},
  {"add_hpr_factor", true, false, false},
  {"RD12calib", false, false, false},
  {"save_sim_inl", false, false, false},
};
int stim_paramDef_list_size = 45;



/**
 * Allow to update (ie. store) the parameter value(s) in the structure.
 *
 * @param list_size the size of the list (if any) otherwise the value is ignored.
 */
int stim_updateParam(stim_parContent *param, char *name, PIOSTRING *value, PIOLONG list_size) {
  //fprintf(stderr, "[DEBUG] updateParam() name = '%s'   value = '%s' list_size = "PIOLONG_FMT"\n", name, *value, list_size);

  // Retrieve our inner param def
  paramDef *currentParamDef = getParamDef(name, stim_paramDef_list, stim_paramDef_list_size);
  if (currentParamDef == NULL) {
    //fprintf(stderr, "ERROR: \n", name);
    return 3;
  }
  // Prevent redefinition
  if (currentParamDef->found) {
    fprintf(stderr, "ERROR: param '%s' already defined!\n", name);
    return 4;
  }
  // Mark the param as found
  currentParamDef->found = true;


  // Auto gen by python script
  // Copy into correct entry in parameters struct
  if (strcmp(name, "bolometer") == 0) {
    strcpy(param->bolometer, *value);
  }
  else if (strcmp(name, "brimo_filename") == 0) {
    strcpy(param->brimo_filename, *value);
  }
  else if (strcmp(name, "stay_in_memory") == 0) {
    errno = 0;
    param->stay_in_memory = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'stay_in_memory': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "iterations") == 0) {
    errno = 0;
    param->iterations = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'iterations': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "BeginRing") == 0) {
    errno = 0;
    param->BeginRing = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'BeginRing': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "EndRing") == 0) {
    errno = 0;
    param->EndRing = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'EndRing': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "rings_per_read") == 0) {
    errno = 0;
    param->rings_per_read = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'rings_per_read': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "signal_in") == 0) {
    strcpy(param->signal_in, *value);
  }
  else if (strcmp(name, "signal_out") == 0) {
    strcpy(param->signal_out, *value);
  }
  else if (strcmp(name, "hpr_out") == 0) {
    strcpy(param->hpr_out, *value);
  }
  else if (strcmp(name, "do_SHPR") == 0) {
    errno = 0;
    param->do_SHPR = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_SHPR': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "TOI_pixel_index") == 0) {
    strcpy(param->TOI_pixel_index, *value);
  }
  else if (strcmp(name, "phase") == 0) {
    strcpy(param->phase, *value);
  }
  else if (strcmp(name, "random_seed") == 0) {
    errno = 0;
    param->random_seed = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'random_seed': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "do_photonic_noise") == 0) {
    errno = 0;
    param->do_photonic_noise = myRead_PIOFLOAT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_photonic_noise': Unable to convert value '%s' to target type %s\n", *value, "PIOFLOAT");
      return 1;
    }
  }
  else if (strcmp(name, "do_LFER_convolve") == 0) {
    errno = 0;
    param->do_LFER_convolve = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_LFER_convolve': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "nharm_oof") == 0) {
    errno = 0;
    param->nharm_oof = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'nharm_oof': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "amp_oof_param") == 0) {
    strcpy(param->amp_oof_param, *value);
  }
  else if (strcmp(name, "do_electronic_noise") == 0) {
    errno = 0;
    param->do_electronic_noise = myRead_PIOFLOAT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_electronic_noise': Unable to convert value '%s' to target type %s\n", *value, "PIOFLOAT");
      return 1;
    }
  }
  else if (strcmp(name, "do_despike_flag") == 0) {
    errno = 0;
    param->do_despike_flag = myRead_PIOFLOAT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_despike_flag': Unable to convert value '%s' to target type %s\n", *value, "PIOFLOAT");
      return 1;
    }
  }
  else if (strcmp(name, "do_sim_adu") == 0) {
    errno = 0;
    param->do_sim_adu = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_sim_adu': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "sim_inl_name") == 0) {
    strcpy(param->sim_inl_name, *value);
  }
  else if (strcmp(name, "rawgain_name") == 0) {
    strcpy(param->rawgain_name, *value);
  }
  else if (strcmp(name, "rawcst_name") == 0) {
    strcpy(param->rawcst_name, *value);
  }
  else if (strcmp(name, "fourk_name") == 0) {
    strcpy(param->fourk_name, *value);
  }
  else if (strcmp(name, "add_baseline") == 0) {
    strcpy(param->add_baseline, *value);
  }
  else if (strcmp(name, "electronic_noise_adu") == 0) {
    errno = 0;
    param->electronic_noise_adu = myRead_PIOFLOAT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'electronic_noise_adu': Unable to convert value '%s' to target type %s\n", *value, "PIOFLOAT");
      return 1;
    }
  }
  else if (strcmp(name, "do_compress_decompress") == 0) {
    errno = 0;
    param->do_compress_decompress = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_compress_decompress': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "do_correct_adc") == 0) {
    errno = 0;
    param->do_correct_adc = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_correct_adc': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "corr_inl_name") == 0) {
    strcpy(param->corr_inl_name, *value);
  }
  else if (strcmp(name, "do_adu_to_volts") == 0) {
    errno = 0;
    param->do_adu_to_volts = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_adu_to_volts': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "do_bl_demod") == 0) {
    errno = 0;
    param->do_bl_demod = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_bl_demod': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "do_gaindecorr") == 0) {
    errno = 0;
    param->do_gaindecorr = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_gaindecorr': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "use_bolometer_nonlinearity") == 0) {
    errno = 0;
    param->use_bolometer_nonlinearity = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'use_bolometer_nonlinearity': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "thermal_baseline") == 0) {
    strcpy(param->thermal_baseline, *value);
  }
  else if (strcmp(name, "do_LFER_deconvolve") == 0) {
    errno = 0;
    param->do_LFER_deconvolve = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_LFER_deconvolve': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "deconv_LPF_FILTER") == 0) {
    strcpy(param->deconv_LPF_FILTER, *value);
  }
  else if (strcmp(name, "deconv_R_FILTER") == 0) {
    strcpy(param->deconv_R_FILTER, *value);
  }
  else if (strcmp(name, "do_calibrate") == 0) {
    errno = 0;
    param->do_calibrate = myRead_PIOFLOAT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_calibrate': Unable to convert value '%s' to target type %s\n", *value, "PIOFLOAT");
      return 1;
    }
  }
  else if (strcmp(name, "add_final_toi") == 0) {
    strcpy(param->add_final_toi, *value);
  }
  else if (strcmp(name, "add_final_toi_factor") == 0) {
    errno = 0;
    param->add_final_toi_factor = myRead_PIOFLOAT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'add_final_toi_factor': Unable to convert value '%s' to target type %s\n", *value, "PIOFLOAT");
      return 1;
    }
  }
  else if (strcmp(name, "add_hpr_name") == 0) {
    param->flag_add_hpr_name = _PAR_TRUE;
    param->n_add_hpr_name = list_size;
    param->add_hpr_name = malloc(list_size * sizeof(PIOSTRING));
    if (param->add_hpr_name == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->add_hpr_name[i], value[i]);
    }
  }
  else if (strcmp(name, "add_hpr_factor") == 0) {
    param->flag_add_hpr_factor = _PAR_TRUE;
    param->n_add_hpr_factor = list_size;
    param->add_hpr_factor = malloc(list_size * sizeof(PIOFLOAT));
    if (param->add_hpr_factor == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->add_hpr_factor[i] = myRead_PIOFLOAT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'add_hpr_factor': Unable to convert value '%s' to target type %s\n", value[i], "PIOFLOAT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "RD12calib") == 0) {
    param->flag_RD12calib = _PAR_TRUE;
    errno = 0;
    param->RD12calib = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'RD12calib': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "save_sim_inl") == 0) {
    param->flag_save_sim_inl = _PAR_TRUE;
    strcpy(param->save_sim_inl, *value);
  }
  else {
    fprintf(stderr, "ERROR: %s: Unknown param name!\n", name);
    return 1;
  }



  return 0;
}


int stim_readParam(stim_parContent *param, const char *filename) {
  // Parse the parameter file: read each line and update info in structure
  // if we encounter an error stop the process or print a warning depending of the severity.

  // check MPI rank
  char* pEnv;
  int mpi_rank;
  pEnv = getenv( "OMPI_COMM_WORLD_RANK"); // openmpi
  if (pEnv == NULL) {
    pEnv = getenv( "SLURM_PROCID"); // http://slurm.schedmd.com/sbatch.html
  }
  if (pEnv == NULL) {
    pEnv = getenv( "PMI_RANK"); // datarmor mpicc
  }
  if (pEnv == NULL) {
    mpi_rank = 0;
  } else {
    mpi_rank = atoi( pEnv);
  }

  if (mpi_rank == 0) {
    fprintf( stderr, "\n\nstim_readParam() from file \"%s\"\n",filename);
  }

  // Init the structure to ensure all flag are set to false by default
  memset(param, 0, sizeof(stim_parContent));

  // Open the param file
  PyObject * pyParams = load_PyParams(filename);
  if (pyParams == NULL) {
    fprintf(stderr, "ERROR while trying to open parameter file: '%s'\n", filename);
    PyErr_Print();
    perror("Error");
    exit(-1);
    return 1;
  }

  // Init the internal structure allowing to know if a parameter has already appeared.
  for (int i=0; i < stim_paramDef_list_size; i++) {
    stim_paramDef_list[i].found = false;
  }

  // Init the list values
  PIOLONG currentListIndex = 0; // the index of next element to be read
  PIOSTRING *currentListValues = NULL; // The array of PIOSTRING to store all values of the list
  char value[MAX_LINE_LENGTH];

  for(int i =0;i<stim_paramDef_list_size;i++){
    int flag_parsing = 0; 
    currentListIndex = 0;

    int valid_param = testParam(pyParams,stim_paramDef_list[i].name);
    
    //if params is in pyParams
    if(valid_param == 0){     
      char * name = stim_paramDef_list[i].name;
      //If list of params
      
      if(stim_paramDef_list[i].isList){    
        int ListSize = getListSize(pyParams,name);
	      //If list not null
	      if(ListSize!=-1) {
	        //create list values params
          currentListValues = malloc(ListSize * sizeof(PIOSTRING));

	        while(currentListIndex!=ListSize && flag_parsing == 0){
              PyObject * pyValue =getItemParam(pyParams,stim_paramDef_list[i].name,currentListIndex);  
              if(pyValue != NULL){
                //PIOSTRING * value = PyUnicode_AsUTF8(PyObject_Str(pyValue));
		            strncpy(value,PyUnicode_AsUTF8(PyObject_Str(pyValue)),MAX_LINE_LENGTH);
                // Store the list value
                strcpy(currentListValues[currentListIndex], value); // -1 since array is 0 indexed!
                currentListIndex++;		            
              }else{
                flag_parsing =1;
              }
            }
	 
            // Save List parameter to param structure
            stim_updateParam(param,name,currentListValues,currentListIndex);
          }
      }else{
        // Save simple parameters to param structure
        PyObject * pyValue =getParam(pyParams,stim_paramDef_list[i].name);
        if(pyValue != NULL){
          PIOSTRING *value = PyUnicode_AsUTF8(PyObject_Str(pyValue));
          stim_updateParam(param,name,value,0);
        }
      }
    }
  }    
  return 0;
}



/*

int stim_readParam(stim_parContent *param, const char *filename) {

  // Parse the parameter file: read each line and update info in structure
  // if we encounter an error stop the process or print a warning depending of the severity.

  // check MPI rank
  char* pEnv;
  int mpi_rank;
  pEnv = getenv( "OMPI_COMM_WORLD_RANK"); // openmpi
  if (pEnv == NULL) {
    pEnv = getenv( "SLURM_PROCID"); // http://slurm.schedmd.com/sbatch.html
  }
  if (pEnv == NULL) {
    pEnv = getenv( "PMI_RANK"); // datarmor mpicc
  }
  if (pEnv == NULL) {
    mpi_rank = 0;
  } else {
    mpi_rank = atoi( pEnv);
  }

  if (mpi_rank == 0) {
    fprintf( stderr, "\n\nstim_readParam() from file \"%s\"\n", filename);
  }

  // Init the structure to ensure all flag are set to false by default
  memset(param, 0, sizeof(stim_parContent));

  // Open the param file
  FILE *fp = fopen(filename, "r");
  if (fp == NULL) {
    fprintf(stderr, "ERROR while trying to open parameter file: '%s'\n", filename);
    perror("Error");
    return 1;
  }

  // Init the internal structure allowing to know if a parameter has already appeared.
  for (int i=0; i < stim_paramDef_list_size; i++) {
    stim_paramDef_list[i].found = false;
  }

  // Init the list values
  char *currentListName = NULL; // The list name (= the parameter name for the list)
  PIOLONG currentListTotalNumber = 0; // The total number of element in the list
  PIOLONG currentListIndex = 0; // the index of next element to be read
  PIOSTRING *currentListValues = NULL; // The array of PIOSTRING to store all values of the list

  // Init of parsing values
  char *s;
  char buff[MAX_LINE_LENGTH];
  int currentLine = 1;

  // Loop on each line of the parameter file
  while (fgets(buff, sizeof buff, fp) != NULL) {
    //fprintf(stderr, "[DEBUG] *** line #%d: '%s'\nstrlen(buff)= %zd\n", currentLine, buff, strlen(buff));

    // Check that line is not too long!
    if (strlen(buff) == (MAX_LINE_LENGTH-1)) { // -1 since we do not count the last char '\0'
      // In log we specify MAX_LINE_LENGTH-3 since we remove the new line char and the '\0' and take one more char to be sure we don't exceed.
      fprintf(stderr, "ERROR parameter file: '%s' has its line #%d too long! (max is %d chars)\n", filename, currentLine, MAX_LINE_LENGTH-3);
      return 1;
    }

    int firstChar = 0;
    while (isspace(buff[firstChar])) {
      firstChar++;
    }
    // Skip blank lines and comments
    if ((firstChar == strlen(buff)) || buff[firstChar] == '\n' || buff[firstChar] == '#') {
      //fprintf(stderr, "[DEBUG] line %d is empty or comment\n", currentLine);
      // Update line counter
      currentLine++;
      continue;
    }

    // Parse name/value pair from line
    char name[MAX_LINE_LENGTH], value[MAX_LINE_LENGTH];
    s = strtok(buff, "=");
    if (s==NULL) {
      fprintf(stderr, "ERROR: Missing param affectation symbol '=' at line %d\n", currentLine);
      //fprintf(stderr, "[DEBUG] line: %s\n", buff);
      return 1;
    }
    else {
      s = trim(s);
      strncpy(name, s, MAX_LINE_LENGTH);
    }
    s = strtok (NULL, "=");
    if (s==NULL || strlen(trim(s)) == 0) {
      fprintf(stderr, "ERROR: Missing param value at line %d\n", currentLine);
      //fprintf(stderr, "[DEBUG] line: %s\n", buff);
      return 1;
    }
    else {
      s = trim(s);
      strncpy(value, s, MAX_LINE_LENGTH);
    }

    if (mpi_rank == 0) {
      fprintf( stderr, "%s: reading %s = %s\n", __FILE__, name, value);
    }

    // Check if we are in a list reading phase
    if (currentListName != NULL) {
      char list_elt_to_be_read[MAX_LINE_LENGTH]; // Allow to store the name of the expected parameter (in case of list)
      sprintf(list_elt_to_be_read, "%s"PIOLONG_FMT"", currentListName, currentListIndex);
      if (strcmp(name, list_elt_to_be_read) != 0) {
        fprintf(stderr, "ERROR: We were expecting list param '%s' at line %d, but found '%s'\n",
            list_elt_to_be_read, currentLine, name);
        return 1;
      }

      // Store the list value
      strcpy(currentListValues[currentListIndex-1], value); // -1 since array is 0 indexed!

      // Handle end of list
      if (currentListIndex == currentListTotalNumber) {
        // Save List to param structure
        if (stim_updateParam(param, currentListName, currentListValues, currentListTotalNumber) != 0) {
          free(currentListName);
          return 1;
        }
        // Reset list name
        free(currentListName);
        currentListName = NULL;
      } else {
        currentListIndex++;
      }
      // Update line counter
      currentLine++;
      continue;
    }

    // Handle special param prefix: PARAM_PREFIX_LIST ("number_of_")
    if (startsWith(name, PARAM_PREFIX_LIST) == 0) {
      //fprintf(stderr, "[DEBUG] we detect a list number prefix at line: %d\n", currentLine);
      // Update info with number of element to be read...
      // - Save the current list param name
      currentListName = strdupnodmc(name+strlen(PARAM_PREFIX_LIST));
      if (currentListName == NULL) {
        perror("Error");
        return 1;
      }
      //fprintf(stderr, "[DEBUG] list param name: '%s'\n", currentListName);

      // Retrieve our inner param def
      paramDef *currentParamDef = getParamDef(currentListName, stim_paramDef_list, stim_paramDef_list_size);
      if (currentParamDef == NULL) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter refer to an invalid element '%s'\n", currentLine, currentListName);
        return 1;
      }

      // Check that the "number_of" refered to an existing element of type list
      if (!currentParamDef->isList) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter refer to a none list element '%s'\n", currentLine, currentListName);
        return 1;
      }
      
      // - Update info about list
      errno = 0;
      currentListTotalNumber = myRead_PIOLONG(value);
      if (errno != 0) {
        fprintf(stderr, "ERROR (line #%d): Unable to convert value '%s' to target type %s\n", currentLine, value, "PIOLONG");
        //perror("Error");
        return 1;
      }
      //fprintf(stderr, "[DEBUG] list param total number: "PIOLONG_FMT"\n", currentListTotalNumber);

      // Check that "number_of" can't be negative
      if (currentListTotalNumber < 0) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter can't be negative!\n", currentLine);
        return 1;
      }

      // Check that if param is required, the "number_of" can't be 0
      if (currentListTotalNumber == 0) {
        // Retrieve mandatory bool
        bool mandatory = currentParamDef->mandatory;

        if (mandatory) {
          fprintf(stderr, "ERROR (line %d): 'number_of' parameter can't be 0 for the mandatory element '%s'!\n", currentLine, currentListName);
          return 1;
        } else {
          // In this case we expect no other parameters of this name!
          // We just "ignore" the 'number_of' element...

          // Reset list name
          free(currentListName);
          currentListName = NULL;
        }
      } else {
        currentListIndex = 1; // the index to be read next!
        // Allocate memory for storing list values (values will be converted later)
        currentListValues = malloc(currentListTotalNumber * sizeof(PIOSTRING));
        if (currentListValues == NULL) {
          perror("Error");
          return 1;
        }
      }

      // Update line counter
      currentLine++;
      continue;
    }

    // In case of a simple parameter
    if (stim_updateParam(param, name, &value, 0) != 0) {
      return 1;
    }

    // Update line counter
    currentLine++;
  }
  
  //fprintf(stderr, "[DEBUG] End of parsing!\n");

  // Make some check

  // - Check that if we were reading list we read all elements otherwise print error msg.
  if (currentListName != NULL) {
    fprintf(stderr, "ERROR: missing some elements definition for parameter '%s'\n", currentListName);
    return 1;
  }

  // - All mandatory param must have been read! (see 'mandatory' and 'found')
  // Loop on all param def
  int i;
  for (i = 0; i < stim_paramDef_list_size; i++) {
    if (stim_paramDef_list[i].mandatory && (!stim_paramDef_list[i].found)) {
      fprintf(stderr, "ERROR: Missing mandatory parameter '%s'\n", stim_paramDef_list[i].name);
      return 1;
    }
  }

  //fprintf(stderr, "[DEBUG] Parameter file successfully parsed!\n");

  return 0;
}

*/

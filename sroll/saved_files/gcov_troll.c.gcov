        -:    0:Source:troll.c
        -:    0:Graph:troll.gcno
        -:    0:Data:troll.gcda
        -:    0:Runs:4
        -:    0:Programs:1
        -:    1:// this is for srand48(), drand48(), realpath()
        -:    2:#ifndef _XOPEN_SOURCE
        -:    3:#define _XOPEN_SOURCE 700
        -:    4:#endif
        -:    5:  
        -:    6:#define MAXOUTMAP (2048)
        -:    7:
        -:    8:#define CNN_NSIDE (32)
        -:    9:
        -:   10:#define USEDII
        -:   11://#define TESTFITADU
        -:   12:
        -:   13:#include <stdio.h>
        -:   14:#include <stdlib.h>
        -:   15:#include <stdbool.h>
        -:   16:#include <string.h>
        -:   17:#include <mpi.h>
        -:   18:#include <float.h>
        -:   19:#include <math.h>
        -:   20:#include <sys/time.h>
        -:   21:#include <time.h>
        -:   22:#include <unistd.h>
        -:   23:#include <sys/types.h>
        -:   24:#include <sys/stat.h>
        -:   25:#include <fcntl.h>
        -:   26:#include <fftw3.h>
        -:   27:#include <assert.h>
        -:   28:#include <errno.h>
        -:   29:#include <omp.h>
        -:   30:#include <libgen.h>
        -:   31:#include "spline.h"
        -:   32:
        -:   33:#include "no_dmc_metadata.h"
        -:   34:#include "no_dmc_data_access.h"
        -:   35:#include "no_dmc_piolib_type_def.h"
        -:   36:#include "no_dmc_util.h"
        -:   37:#include "no_dmc_debug.h"
        -:   38:#include "no_dmc_version.h"
        -:   39:#include "chealpix.h"
        -:   40:
        -:   41:#define PY_SSIZE_T_CLEAN
        -:   42:#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
        -:   43:#include <Python.h>
        -:   44:#include <numpy/arrayobject.h>
        -:   45:
        -:   46:
        -:   47:#include "troll_param.h"
        -:   48:
        -:   49:#include "stim_parLoader.h"
        -:   50:#include "stim.h"
        -:   51:#include "stim_tools.h"
        -:   52:#if 1
        -:   53:#define OPTIPIX
        -:   54:#endif
        -:   55:#if 1
        -:   56:#define OPTIMPI
        -:   57:#endif
        -:   58:
        -:   59:#define MAXADUBOLO (100)
        -:   60:long nadufit[MAXADUBOLO]; // 100 max number of bolometers
        -:   61:
        -:   62:float *tpparam=NULL; // parameters for neural network initialise to NULL at the beginning.
        -:   63:int CNN_NB_PARAM=0;
        -:   64:
        -:   65:// TODO TEST TIME STEP IN ADU
        -:   66:PIOLONG ADURGSTEP[MAXADUBOLO];
        -:   67:PIOLONG nadustep[MAXADUBOLO];
        -:   68:#define ADUSTEP (32000)
        -:   69:
        -:   70:int NUMBEROFITER=500;
        -:   71:
        -:   72:int NORMFITPOL=0;
        -:   73:
        -:   74:int PIOWriteVECT(const char *path,void *value,int off,int size);
        -:   75:
        -:   76:double rg_vals[MAXADUBOLO][4*32000];
        -:   77:int rg_start[MAXADUBOLO][32000];
        -:   78:int rg_end[MAXADUBOLO][32000];
        -:   79:
        -:   80:double *xspladu;
        -:   81:BSpline *bspline[MAXADUBOLO]; // 100 max number of bolometers
        -:   82:BSpline *bsplineTime[MAXADUBOLO];
        -:   83:
        -:   84:int *realpix;
        -:   85:int *irealpix;
        -:   86:
        -:   87:enum MAPRINGS_values {
        -:   88:  FULL        = 1,
        -:   89:  HM12        = 2,
        -:   90:  S12345      = 4,
        -:   91:  YEAR12      = 8,
        -:   92:  FULLODDEVEN = 16,
        -:   93:  HM12ODDEVEN = 32
        -:   94:};
        -:   95:
        -:   96:enum MAPRINGS_maps {
        -:   97:  MAPFULL  = 1,
        -:   98:  HM1      = 2,
        -:   99:  HM2      = 4,
        -:  100:  S1       = 8,
        -:  101:  S2       = 16,
        -:  102:  S3       = 32,
        -:  103:  S4       = 64,
        -:  104:  S5       = 128,
        -:  105:  YEAR1    = 256,
        -:  106:  YEAR2    = 512,
        -:  107:  FULLODD  = 1024,
        -:  108:  FULLEVEN = 2048,
        -:  109:  HM1ODD   = 4096,
        -:  110:  HM1EVEN  = 8192,
        -:  111:  HM2ODD   = 16384,
        -:  112:  HM2EVEN  = 32768
        -:  113:};
        -:  114:
        -:  115:typedef struct {
        -:  116:  int ipx;
        -:  117:  int hit;
        -:  118:} hpint;
        -:  119:
        -:  120:typedef struct {
        -:  121:  PyObject * sys;
        -:  122:  PyObject * py_path;
        -:  123:  PyObject * ModuleString;
        -:  124:  PyObject * Module;
        -:  125:  PyObject * Dict;
        -:  126:  PyObject * init;
        -:  127:  PyObject * initFromFile;
        -:  128:  PyObject * initFrom_Files;
        -:  129:  PyObject * init_net;
        -:  130:  PyObject * init_net_data;
        -:  131:  PyObject * allocf32;
        -:  132:  PyObject * alloci32;
        -:  133:  PyObject * Clean;
        -:  134:  PyObject * grad;
        -:  135:  PyObject * agrad;
        -:  136:  PyObject * gloss;
        -:  137:  PyObject * close;
        -:  138:  PyObject * pred;
        -:  139:  PyObject * corr;
        -:  140:  PyObject * initpar;
        -:  141:  PyObject * getparam;
        -:  142:  PyObject * initconvw;
        -:  143:  PyObject * getconvw;
        -:  144:  PyObject * initconvb;
        -:  145:  PyObject * getconvb;
        -:  146:  PyObject * initflw;
        -:  147:  PyObject * getflw;
        -:  148:  PyObject * initflb;
        -:  149:  PyObject * getflb;
        -:  150:  PyObject * pltvec;
        -:  151:  PyObject * plthisto;
        -:  152:} WrapPython;
        -:  153:
        -:  154:int python_rank;
        -:  155:int mpi_python_size;
        -:  156:int tensorflow_rank;
        -:  157:int mpi_tensorflow_size;
        -:  158:MPI_Comm python_comm;
        -:  159:MPI_Comm tensorflow_comm;
        -:  160:
638421614:  161:int compar_int(const void *a, const void *b)
        -:  162:{
638421614:  163:  hpint *pa = (hpint *) a;
638421614:  164:  hpint *pb = (hpint *) b;
638421614:  165:  return(pb->hit-pa->hit);
        -:  166:}
        -:  167:
    #####:  168:int getx12(int idx)
        -:  169:{
    #####:  170:  int res=(idx%2)
    #####:  171:    +((idx/4)%2)*2
    #####:  172:    +((idx/16)%2)*4
    #####:  173:    +((idx/64)%2)*8
    #####:  174:    +((idx/256)%2)*16
    #####:  175:    +((idx/1024)%2)*32
    #####:  176:    +((idx/4096)%2)*64
    #####:  177:    +((idx/16384)%2)*128
    #####:  178:    +((idx/65536)%2)*256
    #####:  179:    +((idx/262144)%2)*512
    #####:  180:    +((idx/1048576)%2)*1024
    #####:  181:    +((idx/4194304)%2)*2048;
    #####:  182:  return(res);
        -:  183:}
        -:  184:
    #####:  185:int gety12(int idx)
        -:  186:{
    #####:  187:  int res=((idx/2)%2)
    #####:  188:    +((idx/8)%2)*2
    #####:  189:    +((idx/32)%2)*4
    #####:  190:    +((idx/128)%2)*8
    #####:  191:    +((idx/512)%2)*16
    #####:  192:    +((idx/2048)%2)*32
    #####:  193:    +((idx/8192)%2)*64
    #####:  194:    +((idx/32768)%2)*128
    #####:  195:    +((idx/131072)%2)*256
    #####:  196:    +((idx/524288)%2)*512
    #####:  197:    +((idx/2097152)%2)*1024
    #####:  198:    +((idx/8388608)%2)*2048;
    #####:  199:  return(res);
        -:  200:}
        -:  201:
    #####:  202:int set12(int x,int y)
        -:  203:{
    #####:  204:  int res=((x)%2)
    #####:  205:    +((x/2)%2)*4
    #####:  206:    +((x/4)%2)*16
    #####:  207:    +((x/8)%2)*64
    #####:  208:    +((x/16)%2)*256
    #####:  209:    +((x/32)%2)*1024
    #####:  210:    +((x/64)%2)*4096
    #####:  211:    +((x/128)%2)*16384
    #####:  212:    +((x/256)%2)*65536
    #####:  213:    +((x/512)%2)*262144
    #####:  214:    +((x/1024)%2)*1048576
    #####:  215:    +((x/2048)%2)*4194304
    #####:  216:    +((y)%2)*2
    #####:  217:    +((y/2)%2)*8
    #####:  218:    +((y/4)%2)*32
    #####:  219:    +((y/8)%2)*128
    #####:  220:    +((y/16)%2)*512
    #####:  221:    +((y/32)%2)*2048
    #####:  222:    +((y/64)%2)*8192
    #####:  223:    +((y/128)%2)*32768
    #####:  224:    +((y/256)%2)*131072
    #####:  225:    +((y/512)%2)*524288
    #####:  226:    +((y/1024)%2)*2097152
    #####:  227:    +((y/2048)%2)*8388608;
    #####:  228:  return(res);
        -:  229:}
        -:  230:
        -:  231:#define MAXRAND 1000000
        -:  232:
      376:  233:PyObject *EXECPYTHON(PyObject *TheObject)
        -:  234:{
      376:  235:  if (TheObject==NULL) {
    #####:  236:    PyErr_Print();
    #####:  237:    exit(0);
        -:  238:  }
      376:  239:  return(TheObject);
        -:  240:}
      100:  241:PyObject *CALLPYTHON(PyObject *Dict,const char *name)
        -:  242:{
      100:  243:  PyObject *res=PyDict_GetItemString(Dict,name);
      100:  244:  if (PyCallable_Check(res)) {
      100:  245:    return(res); 
        -:  246:  }
        -:  247:  else {
    #####:  248:    fprintf(stderr,"Problem while loading %s function\n",name);
    #####:  249:    PyErr_Print();
    #####:  250:    exit(0);
        -:  251:  }
        -:  252:  return(NULL);
        -:  253:}
        -:  254:
        4:  255:void InitPython(WrapPython *mywrap, char *myfunct, int rank)
        -:  256:{
        -:  257:  char thepath[1024];
        4:  258:  int i,lastslash=-1;
        4:  259:  strcpy(thepath,myfunct);
      340:  260:  for (i=0;i<strlen(myfunct);i++) 
      336:  261:    if (myfunct[i]=='/') lastslash=i;
        4:  262:  if (lastslash==-1) {
    #####:  263:    sprintf(thepath,".");
    #####:  264:    lastslash=0;
        -:  265:  }
        -:  266:  else {
        4:  267:    thepath[lastslash]='\0';
        4:  268:    lastslash++;
        -:  269:  }
        4:  270:  if (rank==0) {
        1:  271:    fprintf(stderr,"Call python module in path\n%s\n",thepath);
        -:  272:  }
        4:  273:  Py_Initialize();
        -:  274:
        4:  275:  mywrap->sys = EXECPYTHON(PyImport_ImportModule("sys"));
        4:  276:  mywrap->py_path = EXECPYTHON(PyObject_GetAttrString(mywrap->sys, "path"));
        -:  277:  
        -:  278:#ifdef PYTHON3
        4:  279:  PyList_Append(mywrap->py_path, PyUnicode_FromString(thepath));
        -:  280:#else
        -:  281:  PyList_Append(mywrap->py_path, PyString_FromString(thepath));
        -:  282:#endif
        -:  283:  
        -:  284:  
        4:  285:  strcpy(thepath,myfunct+lastslash);
        4:  286:  lastslash=-1;
       96:  287:  for (i=0;i<strlen(thepath);i++) 
       92:  288:    if (thepath[i]=='.') lastslash=i;
        4:  289:  if (lastslash!=-1) thepath[lastslash]='\0';
        -:  290:
        4:  291:  if (rank==0) {
        1:  292:    fprintf(stderr,"Call module : %s\n",thepath);
        -:  293:  }
        -:  294:
        -:  295:  
        -:  296:      
        -:  297:#ifdef PYTHON3
        4:  298:  mywrap->ModuleString = PyUnicode_FromString(thepath);
        -:  299:#else
        -:  300:  mywrap->ModuleString = PyString_FromString(thepath);
        -:  301:#endif
        4:  302:  mywrap->Module = EXECPYTHON(PyImport_Import(mywrap->ModuleString));
        4:  303:  mywrap->Dict = EXECPYTHON(PyModule_GetDict(mywrap->Module));
        -:  304:
        -:  305:  
        -:  306:  
        4:  307:  mywrap->init     = CALLPYTHON(mywrap->Dict, "init_shape");
        4:  308:  mywrap->initFrom_Files = CALLPYTHON(mywrap->Dict, "init_shape_from_files");
        4:  309:  mywrap->init_net = CALLPYTHON(mywrap->Dict, "init_network");
        4:  310:  mywrap->init_net_data = CALLPYTHON(mywrap->Dict, "init_network_data");
        4:  311:  mywrap->allocf32 = CALLPYTHON(mywrap->Dict, "alloc_table_float32");
        4:  312:  mywrap->alloci32 = CALLPYTHON(mywrap->Dict, "alloc_table_int32");
        4:  313:  mywrap->Clean    = CALLPYTHON(mywrap->Dict, "free_table");
        4:  314:  mywrap->grad     = CALLPYTHON(mywrap->Dict, "calc_grad");
        4:  315:  mywrap->agrad    = CALLPYTHON(mywrap->Dict, "apply_grad");
        4:  316:  mywrap->gloss    = CALLPYTHON(mywrap->Dict, "get_loss");
        4:  317:  mywrap->close    = CALLPYTHON(mywrap->Dict, "close_session");
        4:  318:  mywrap->pred     = CALLPYTHON(mywrap->Dict, "get_prediction");
        4:  319:  mywrap->corr     = CALLPYTHON(mywrap->Dict, "get_correction");
        4:  320:  mywrap->initpar  = CALLPYTHON(mywrap->Dict, "alloc_param");
        4:  321:  mywrap->getparam = CALLPYTHON(mywrap->Dict, "get_param");
        4:  322:  mywrap->initconvw = CALLPYTHON(mywrap->Dict, "alloc_convw");
        4:  323:  mywrap->getconvw  = CALLPYTHON(mywrap->Dict, "get_convw");
        4:  324:  mywrap->initconvb = CALLPYTHON(mywrap->Dict, "alloc_convb");
        4:  325:  mywrap->getconvb  = CALLPYTHON(mywrap->Dict, "get_convb");
        4:  326:  mywrap->initflw = CALLPYTHON(mywrap->Dict, "alloc_flw");
        4:  327:  mywrap->getflw  = CALLPYTHON(mywrap->Dict, "get_flw");
        4:  328:  mywrap->initflb = CALLPYTHON(mywrap->Dict, "alloc_flb");
        4:  329:  mywrap->getflb  = CALLPYTHON(mywrap->Dict, "get_flb");
        4:  330:  mywrap->pltvec    = CALLPYTHON(mywrap->Dict, "plt_vec");
        4:  331:  mywrap->plthisto  = CALLPYTHON(mywrap->Dict, "plt_histo");
        4:  332:}
        -:  333:
        4:  334:void CleanPython(WrapPython *mywrap)
        -:  335:{
        -:  336:  // Clean up
        4:  337:  Py_DECREF(mywrap->Module);
        4:  338:  Py_DECREF(mywrap->ModuleString);
        -:  339:  
        -:  340:  
        4:  341:  Py_Finalize();
        4:  342:}
        -:  343:
        -:  344:ssize_t pwrite(int fildes, const void *buf, size_t nbyte,
        -:  345:              off_t offset);
        -:  346:
        1:  347:int isPowerOfTwo (unsigned int x)
        -:  348:{
        1:  349:  return ((x != 0) && ((x & (~x + 1)) == x));
        -:  350:}
        -:  351:
        -:  352:#define RINGSIZE (27664l)
      104:  353:void GetProcMem(long *vmem,long *phymem)
        -:  354:{
        -:  355:    FILE *fp;
        -:  356:    char name[256];
        -:  357:    int pid;
        -:  358:    char comm[512];
        -:  359:    char state;
        -:  360:    int ppid,pgrp,session,tty_nr,tpgid;
        -:  361:    unsigned long flags,minflt,cminflt,majflt,cmajflt,utime;
        -:  362:    long cutime,cstime,priority,nice,xxx,itrealvalue,starttime,vsize,rss,stime;
        -:  363:
      104:  364:    sprintf(name,"/proc/%d/stat",(int) getpid());
        -:  365:
      104:  366:    fp=fopen(name,"r");
      104:  367:    fscanf(fp,"%d %s %c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld %lu %lu %ld",
        -:  368:	   &pid,comm,&state,&ppid,&pgrp,&session,&tty_nr,&tpgid,&flags,&minflt,&cminflt,&majflt,
        -:  369:	   &cmajflt,&utime,&stime,&cutime,&cstime,&priority,&nice,&xxx,&itrealvalue,&starttime,&vsize,
        -:  370:	   &rss);
      104:  371:    fclose(fp);
        -:  372:   
      104:  373:    *vmem=vsize;
      104:  374:    *phymem=rss*4096;
      104:  375:}
        -:  376:
    #####:  377:float GetLoadAvg()
        -:  378:{
        -:  379:    char Line[256];
        -:  380:    float a,b,c;
        -:  381:
    #####:  382:    FILE *fp=fopen("/proc/loadavg","r");
    #####:  383:    fgets(Line,256,fp);
    #####:  384:    fclose(fp);
    #####:  385:    sscanf(Line,"%f %f %f",&a,&b,&c);
    #####:  386:    return(a);
        -:  387:}
        -:  388:
        -:  389:
        -:  390:#include "troll_parLoader.h"
        -:  391:
        -:  392:#ifdef NOGCITER
        -:  393:#define NOGCITER
        -:  394:#endif
        -:  395:
        -:  396:#if 0
        -:  397:#define DORGG
        -:  398:#endif
        -:  399:
        -:  400:#ifdef TRUECP
        -:  401:#define TRUECP
        -:  402:#endif
        -:  403:
        -:  404:#if 0
        -:  405:#define TESPT fprintf(stderr,"***DBG*** %s:%d\n",__FILE__,__LINE__)
        -:  406:#else
        -:  407:#define TESPT {}
        -:  408:#endif
        -:  409:
        -:  410:#define UNSEENPIX (-1.6375000E+30)
        -:  411:
        -:  412:#ifdef FITANGLE
        -:  413:#define FITANGLE
        -:  414:#endif
        -:  415:
        -:  416:#ifdef FITPOLEFF
        -:  417:#define FITPOLEFF
        -:  418:#endif
        -:  419:
        -:  420:#define DONSIDE
        -:  421:#ifdef DONSIDE
        -:  422:#endif
        -:  423:#define NSIDE (8)
        -:  424:#define ORIENT (4)
        -:  425:
        -:  426:#define DOMAP
        -:  427:#ifdef DOMAP
        -:  428:#endif
        -:  429:
        -:  430://#define SOLDIPX (-0.00049639860)
        -:  431://#define SOLDIPY (-0.0022099761)
        -:  432://#define SOLDIPZ (0.0024331235)
        -:  433:
        -:  434:#define SOLDIPX (-0.00022735409)
        -:  435:#define SOLDIPY (-0.0022259792)
        -:  436:#define SOLDIPZ (0.0025066439)
        -:  437:#define TINY 1.0e-303;
        -:  438:
        -:  439:int *invgi;
        -:  440:
       64:  441:int ludcmp(double *a,double *d,int *indx,int n)
        -:  442:{
       64:  443:  int i,imax=0,j,k;
        -:  444:  double big,dum,sum,temp;
       64:  445:  double *vv = (double *) malloc(sizeof(double)*n);
        -:  446:
       64:  447:  *d=1.0;
      744:  448:  for (i=0;i<n;i++) {
      680:  449:    big=0.0;
    11256:  450:    for (j=0;j<n;j++)
    10576:  451:      if ((temp=fabs(a[n*i+j])) > big) big=temp;
      680:  452:    if (big == 0.0) {
    #####:  453:      fprintf(stderr,"Singular matrix in routine LUDCMP\n");
    #####:  454:      return(-1);
        -:  455:    }
      680:  456:    vv[i]=1.0/big;
        -:  457:  }
      744:  458:  for (j=0;j<n;j++) {
     5628:  459:    for (i=0;i<j;i++) {
     4948:  460:      sum=a[n*i+j];
     4948:  461:      for (k=0;k<i;k++) sum -= a[n*i+k]*a[n*k+j];
     4948:  462:      a[n*i+j]=sum;
        -:  463:    }
      680:  464:    big=0.0;
     6308:  465:    for (i=j;i<n;i++) {
     5628:  466:      sum=a[n*i+j];
    35068:  467:      for (k=0;k<j;k++)
    29440:  468:        sum -= a[n*i+k]*a[n*k+j];
     5628:  469:      a[n*i+j]=sum;
     5628:  470:      if ( (dum=vv[i]*fabs(sum)) >= big) {
      740:  471:        big=dum;
      740:  472:        imax=i;
        -:  473:      }
        -:  474:    }
      680:  475:    if (j != imax) {
      728:  476:      for (k=0;k<n;k++) {
      668:  477:        dum=a[n*imax+k];
      668:  478:        a[n*imax+k]=a[n*j+k];
      668:  479:        a[n*j+k]=dum;
        -:  480:      }
       60:  481:      *d = -(*d);
       60:  482:      vv[imax]=vv[j];
        -:  483:    }
      680:  484:    indx[j]=imax;
      680:  485:    if (a[n*j+j] == 0.0) a[n*j+j]=TINY;
      680:  486:    if (j != n) {
      680:  487:      dum=1.0/(a[n*j+j]);
      680:  488:      for (i=j+1;i<n;i++) a[n*i+j] *= dum;
        -:  489:    }
        -:  490:  }
       64:  491:  free(vv);
       64:  492:  return(0);
        -:  493:}
        -:  494:
        -:  495:#undef TINY
        -:  496:
       64:  497:void lubksb(double *a,double *b,int *indx,int n)
        -:  498:{
       64:  499:  int i,ii=-1,ip,j;
        -:  500:  double sum;
        -:  501:
      744:  502:  for (i=0;i<n;i++) {
      680:  503:    ip=indx[i];
      680:  504:    sum=b[ip];
      680:  505:    b[ip]=b[i];
      680:  506:    if (ii>-1)
      616:  507:      for (j=ii;j<=i-1;j++) sum -= a[n*i+j]*b[j];
       64:  508:    else if (sum!=0) ii=i;
      680:  509:    b[i]=sum;
        -:  510:  }
        -:  511:
      744:  512:  for (i=n-1;i>=0;i--) {
      680:  513:    sum=b[i];
      680:  514:    for (j=i+1;j<n;j++) sum -= a[n*i+j]*b[j];
      680:  515:    b[i]=sum/a[n*i+i];
        -:  516:  }
       64:  517:}
        -:  518:
       64:  519:int lusol(double *a,double *b,int n)
        -:  520:{
        -:  521:  double d;
       64:  522:  int *indx= (int *) malloc(n*sizeof(int));
       64:  523:  if (ludcmp(a,&d,indx,n)!=0) return(-1);
       64:  524:  lubksb(a,b,indx,n);
       64:  525:  free(indx);
       64:  526:  return(0);
        -:  527:}
        -:  528:
    #####:  529:void invert(double *a,double *y,int n)
        -:  530:{
        -:  531:  double d;
    #####:  532:  double *col= (double *) malloc(n*sizeof(double));
    #####:  533:  double *l_a= (double *) malloc(n*n*sizeof(double));
    #####:  534:  memcpy(l_a,a,n*n*sizeof(double));
        -:  535:  int i,j;
    #####:  536:  int *indx= (int *) malloc(n*sizeof(int));
    #####:  537:  ludcmp(l_a,&d,indx,n);
        -:  538:
    #####:  539:  for (j=0;j<n;j++) {
    #####:  540:    memset(col,0,n*sizeof(double));
    #####:  541:    col[j]=1.0;
    #####:  542:    lubksb(l_a,col,indx,n);
    #####:  543:    for (i=0;i<n;i++) y[j+i*n]=col[i];
        -:  544:  }
        -:  545:
    #####:  546:  free(l_a);
    #####:  547:  free(col);
    #####:  548:  free(indx);
    #####:  549:}
        -:  550:
    #####:  551:double norm(double *a,int n)
        -:  552:{
        -:  553:  int i,j;
    #####:  554:  double maxd=0;
    #####:  555:  double *col= (double *) malloc(n*sizeof(double));
    #####:  556:  memset(col,0,n*sizeof(double));
        -:  557:
    #####:  558:  for (j=0;j<n;j++) {
    #####:  559:    for (i=0;i<n;i++) col[j]+=fabs(a[i+j*n]);
    #####:  560:    if (maxd<col[j]) maxd=col[j];
        -:  561:  }
        -:  562:
    #####:  563:  free(col);
    #####:  564:  return(maxd);
        -:  565:}
        -:  566:
    #####:  567:double Dcond(double *a,int n)
        -:  568:{
    #####:  569:  double *b=(double *) malloc(n*n*sizeof(double));
        -:  570:
    #####:  571:  invert(a,b,n);
    #####:  572:  double cond=norm(a,n)*norm(b,n);
    #####:  573:  free(b);
    #####:  574:  return(cond);
        -:  575:}
        -:  576:
        -:  577:
    #####:  578:int invert_3_3(double *mat,double *res)
        -:  579:{
    #####:  580:  double a=mat[0];
    #####:  581:  double b=mat[1];
    #####:  582:  double c=mat[2];
    #####:  583:  double d=mat[3];
    #####:  584:  double e=mat[4];
    #####:  585:  double f=mat[5];
    #####:  586:  double g=mat[6];
    #####:  587:  double h=mat[7];
    #####:  588:  double i=mat[8];
        -:  589:
    #####:  590:  double determinant = a*(e*i-f*h)-d*(b*i-h*c)+g*(b*f-e*c);
    #####:  591:  if (determinant==0) return(-1);
    #####:  592:  double invdet = 1/determinant;
        -:  593:
    #####:  594:  res[0] =  (e*i-f*h)*invdet;
    #####:  595:  res[3] = -(d*i-g*f)*invdet;
    #####:  596:  res[6] =  (d*h-g*e)*invdet;
    #####:  597:  res[1] = -(b*i-h*c)*invdet;
    #####:  598:  res[4] =  (a*i-g*c)*invdet;
    #####:  599:  res[7] = -(a*h-b*g)*invdet;
    #####:  600:  res[2] =  (b*f-c*e)*invdet;
    #####:  601:  res[5] = -(a*f-c*d)*invdet;
    #####:  602:  res[8] =  (a*e-b*d)*invdet;
    #####:  603:  return(0);
        -:  604:}
        -:  605:
        -:  606:
    #####:  607:double donorm_3_3(double *mat)
        -:  608:{
    #####:  609:  double a=mat[0];
    #####:  610:  double b=mat[1];
    #####:  611:  double c=mat[2];
    #####:  612:  double d=mat[3];
    #####:  613:  double e=mat[4];
    #####:  614:  double f=mat[5];
    #####:  615:  double g=mat[6];
    #####:  616:  double h=mat[7];
    #####:  617:  double i=mat[8];
        -:  618:
    #####:  619:  double res1= fabs(a)+fabs(b)+fabs(c);
    #####:  620:  double res2= fabs(d)+fabs(e)+fabs(f);
    #####:  621:  double res3= fabs(g)+fabs(h)+fabs(i);
        -:  622:
    #####:  623:  if (res2>res1) {
    #####:  624:    if (res3>res2) return(res3);
    #####:  625:    else return(res2);
        -:  626:  }
    #####:  627:  if (res3>res1) return(res3);
    #####:  628:  else return(res1);
        -:  629:}
        -:  630:
    #####:  631:double cond_3_3_thres(double a,double b,double c,
        -:  632:                      double d,double e,double f,
        -:  633:                      double g,double h,double i)
        -:  634:{
        -:  635:  double mat[9];
        -:  636:  double res[9];
        -:  637:  int ii,j,k;
        -:  638:
    #####:  639:  mat[0]=a;
    #####:  640:  mat[1]=b;
    #####:  641:  mat[2]=c;
    #####:  642:  mat[3]=d;
    #####:  643:  mat[4]=e;
    #####:  644:  mat[5]=f;
    #####:  645:  mat[6]=g;
    #####:  646:  mat[7]=h;
    #####:  647:  mat[8]=i;
        -:  648:
    #####:  649:  if (invert_3_3(mat,res)==-1) return(1E30);
        -:  650:
    #####:  651:  double cond=donorm_3_3(mat)*donorm_3_3(res);
        -:  652:
    #####:  653:  if (cond<1000) {
    #####:  654:    double err=0;
    #####:  655:    for (k=1;k<3;k++) {
    #####:  656:      for (ii=0;ii<3;ii++) {
    #####:  657:        for (j=0;j<3;j++) {
    #####:  658:          err += res[3*ii+k]*res[3*k+j]*mat[3*ii+j];
        -:  659:        }
        -:  660:      }
        -:  661:    }
        -:  662:
    #####:  663:    cond=sqrt(err/2);
        -:  664:  }
        -:  665:
    #####:  666:  return(cond);
        -:  667:}
        -:  668:
    #####:  669:double legendre(double x,int n)
        -:  670:{
        -:  671:  int i;
    #####:  672:  double P0=1;
    #####:  673:  double P1=x;
    #####:  674:  double P2=0;
    #####:  675:  if (n==0) return(P0);
    #####:  676:  if (n==1) return(P1);
    #####:  677:  for (i=2;i<=n;i++) {
    #####:  678:    P2=(2*(i-1)+1)*x*P1-(i-1)*P0;
    #####:  679:    P0=P1;
    #####:  680:    P1=P2;
        -:  681:  }
    #####:  682:  return(P2);
        -:  683:}
        -:  684:
    #####:  685:double solvemap2(double a,double b,double c,double d,
        -:  686:                 double *v0,double *v1)
        -:  687:{
        -:  688:
    #####:  689:  double det=1./(a*d-b*c);
    #####:  690:  double x0=det*(d*(*v0)-b*(*v1));
    #####:  691:  double x1=det*(-c*(*v0)+a*(*v1));
        -:  692:
    #####:  693:  *v0=x0;
    #####:  694:  *v1=x1;
    #####:  695:  return(det);
        -:  696:}
        -:  697:
    19487:  698:double solvemap(double *x,double *y,double *z,
        -:  699:                double II, double IQ, double IU,
        -:  700:                double QQ, double QU, double UU)
        -:  701:{
        -:  702:  //double determinant =    +A(0,0)*(A(1,1)*A(2,2)-A(2,1)*A(1,2))
        -:  703:  //                     -A(0,1)*(A(1,0)*A(2,2)-A(1,2)*A(2,0))
        -:  704:  //                    +A(0,2)*(A(1,0)*A(2,1)-A(1,1)*A(2,0));
    38974:  705:  double determinant = II*(QQ*UU-QU*QU)
    19487:  706:    -IQ*(IQ*UU-QU*IU)
    19487:  707:    +IU*(IQ*QU-QQ*IU);
        -:  708:
    19487:  709:  double invdet = 1/determinant;
    19487:  710: double result_0_0 =  (QQ*UU - QU*QU)*invdet; // (A(1,1)*A(2,2)-A(2,1)*A(1,2))*invdet;
    19487:  711: double result_1_0 = -(IQ*UU - IU*QU)*invdet; //-(A(0,1)*A(2,2)-A(0,2)*A(2,1))*invdet;
    19487:  712: double result_2_0 =  (IQ*QU - IU*QQ)*invdet; // (A(0,1)*A(1,2)-A(0,2)*A(1,1))*invdet;
    19487:  713: double result_0_1 = -(IQ*UU - QU*IU)*invdet; //-(A(1,0)*A(2,2)-A(1,2)*A(2,0))*invdet;
    19487:  714: double result_1_1 =  (II*UU - IU*IU)*invdet; // (A(0,0)*A(2,2)-A(0,2)*A(2,0))*invdet;
    19487:  715: double result_2_1 = -(II*QU - IQ*IU)*invdet; //-(A(0,0)*A(1,2)-A(1,0)*A(0,2))*invdet;
    19487:  716: double result_0_2 =  (IQ*QU - IU*QQ)*invdet; // (A(1,0)*A(2,1)-A(2,0)*A(1,1))*invdet;
    19487:  717: double result_1_2 = -(II*QU - IU*IQ)*invdet; //-(A(0,0)*A(2,1)-A(2,0)*A(0,1))*invdet;
    19487:  718: double result_2_2 =  (II*QQ - IQ*IQ)*invdet; // (A(0,0)*A(1,1)-A(1,0)*A(0,1))*invdet;
        -:  719:
    19487:  720: double ox = *x*result_0_0 + *y*result_1_0 + *z*result_2_0;
    19487:  721: double oy = *x*result_0_1 + *y*result_1_1 + *z*result_2_1;
    19487:  722: double oz = *x*result_0_2 + *y*result_1_2 + *z*result_2_2;
        -:  723:
    19487:  724: *x=ox;
    19487:  725: *y=oy;
    19487:  726: *z=oz;
        -:  727:
    19487:  728: return(determinant);
        -:  729:}
        -:  730:
        -:  731:// maximum number of stim iterations in one troll run
        -:  732:#ifndef MAXSIMU
        -:  733:#define MAXSIMU (1)
        -:  734:#endif
        -:  735:
        -:  736:// * maximum number of Theo_noPS HPR templates per bolometer
        -:  737:// * from main():
        -:  738://     npixbeam = Param->n_Theo_noPS / nbolo;
        -:  739://     assert( npixbeam <= MAXTHEOHPR);
        -:  740:// * can be set at compilation time with '-DMAXTHEOHPR=xxx'
        -:  741:// * values used in RD12 are 4 at 100ghz-217ghz, 7 at 353ghz and 9 at 545ghz-857ghz
        -:  742:// * need to remember why it was set to 11 for RD12...
        -:  743:
        -:  744:// TROLL update:
        -:  745:// MAXTHEOHPR = 5 TF (H0, H1, H2, H3, H4 + TT1@353) + ANGLE + POLEFF + TDUST + CO13 + SYNCROTRON = 10
        -:  746:// see "extra theo tempaltes" comment around line 6616
        -:  747:// updated assert( npixbeam+5 <= MAXTHEOHPR);
        -:  748:// 545/857 : 
        -:  749:// MAXTHEOHPR = 8 TF + 1FSL + ANGLE + POLEFF + CO13  = 12
        -:  750:
        -:  751:#ifndef MAXTHEOHPR
        -:  752:#define MAXTHEOHPR (10)
        -:  753:#endif
        -:  754:
        -:  755:typedef struct {
        -:  756:  PIODOUBLE sig;
        -:  757:  PIODOUBLE listp[MAXSIMU];
        -:  758:  PIOFLOAT comap;
        -:  759:  PIOFLOAT dustmap;
        -:  760:  PIOFLOAT pdustmap;
        -:  761:  PIOFLOAT listofpix[MAXTHEOHPR];
        -:  762:  PIODOUBLE vspline[4];
        -:  763:  int istart;
        -:  764:  int iend;
        -:  765:  PIOINT ipix;
        -:  766:  PIOINT rg;
        -:  767:  PIOINT hrg;
        -:  768:  PIOFLOAT freefree;
        -:  769:  PIOINT adu;
        -:  770:  PIOFLOAT sadu;
        -:  771:  PIOFLOAT corr_nl;
        -:  772:  PIOFLOAT corr_cnn;
        -:  773:  PIOINT gi;
        -:  774:  PIODOUBLE dip;
        -:  775:  PIOFLOAT fsl;
        -:  776:  PIOFLOAT phase;
        -:  777:  PIOFLOAT w;
        -:  778:  PIOFLOAT co;
        -:  779:  PIOFLOAT si; // pixel pour 32 orientation et 12*32*32 pixel
        -:  780:  PIOBYTE  surv;
        -:  781:  PIOBYTE  ib;
        -:  782:  PIOFLOAT hit;
        -:  783:  PIOFLOAT wp;
        -:  784:  PIODOUBLE vi,vq,vu;
        -:  785:  PIODOUBLE model;
        -:  786:} hpix;
        -:  787:
        -:  788:long DODISTOR=0;
        -:  789:#define _PIOMALLOC malloc
        -:  790:#define _PIOFREE free
        -:  791:
    #####:  792:double gcmat_mpi(double *mat,double *vec,int n,int nn,long begr,long edr)
        -:  793:{
    #####:  794:  int itermax = 1000;
    #####:  795:  double eps = 1.e-14;
        -:  796:  int iter;
        -:  797:  int i,j;
        -:  798:  int rank,mpi_size;
    #####:  799:  MPI_Comm_rank(MPI_COMM_WORLD,&rank);
    #####:  800:  MPI_Comm_size(MPI_COMM_WORLD,&mpi_size);
    #####:  801:  int *tab_begr =_PIOMALLOC(sizeof(int)*mpi_size);
    #####:  802:  int *tab_edr  =_PIOMALLOC(sizeof(int)*mpi_size);
        -:  803:
    #####:  804:  tab_begr[rank]=begr;
    #####:  805:  tab_edr[rank]=edr;
        -:  806:
    #####:  807:  for (i=0;i<mpi_size;i++) {
    #####:  808:    MPI_Bcast(tab_begr+i, sizeof(int), MPI_BYTE, i, MPI_COMM_WORLD);
    #####:  809:    MPI_Bcast(tab_edr+i , sizeof(int), MPI_BYTE, i, MPI_COMM_WORLD);
        -:  810:  }
        -:  811:
        -:  812:  double delta0, delta_new, alpha, delta_old, beta;
        -:  813:
        -:  814:
    #####:  815:  double *x = (double *) calloc (n, sizeof (double));
    #####:  816:  double *b = (double *) calloc (n, sizeof (double));
    #####:  817:  double *d = (double *) calloc (n, sizeof (double));
    #####:  818:  double *q = (double *) calloc (n, sizeof (double));
    #####:  819:  double *r = (double *) calloc (n, sizeof (double));
    #####:  820:  double *s = (double *) calloc (n, sizeof (double));
    #####:  821:  double *hit = (double *) calloc (n, sizeof (double));
        -:  822:
    #####:  823:  iter = 0;
        -:  824:  // Compute second member
    #####:  825:  for (i=0;i<mpi_size;i++) {
    #####:  826:    memcpy(b+tab_begr[i],vec+tab_begr[i],(tab_edr[i]-tab_begr[i]+1)*sizeof(double));
    #####:  827:    MPI_Bcast(b+tab_begr[i], sizeof(double)*(tab_edr[i]-tab_begr[i]+1), MPI_BYTE, i, MPI_COMM_WORLD);
        -:  828:  }
        -:  829:  // starting point x = solution
    #####:  830:  for (i=0; i<n; i++) x[i] = 0.;
        -:  831:
        -:  832:  // Compute Ax
        -:  833:  //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, x, q);
    #####:  834:  for (i=begr;i<= edr;i++) {
    #####:  835:    double tmp=0;
    #####:  836:    for (j=0;j<n;j++) tmp=tmp+x[j]*mat[j+(i-begr)*nn];
    #####:  837:    q[i]=tmp;
        -:  838:  }
        -:  839:
    #####:  840:  for (i=begr; i <= edr; i++)
        -:  841:    {
    #####:  842:      r[i] = b[i] - q[i];
    #####:  843:      d[i] = r[i];
        -:  844:    }
        -:  845:
        -:  846:  // Preconditionnement
    #####:  847:  for (i=begr; i <=edr; i++) {
    #####:  848:    hit[i]=mat[i+(i-begr)*nn];
    #####:  849:    if (hit[i]==0) hit[i]=1;
        -:  850:  }
    #####:  851:  for (i=begr; i<= edr; i++)
    #####:  852:    s[i] = r[i] / hit[i];
        -:  853:
    #####:  854:  double delta_new_tmp = 0.0;
    #####:  855:  for (i = begr; i <= edr; i++) delta_new_tmp += r[i] * s[i];
    #####:  856:  delta_new=0;
    #####:  857:  for (i=0;i<mpi_size;i++) {
    #####:  858:    double tmp=delta_new_tmp;
    #####:  859:    MPI_Bcast(&tmp, sizeof(double), MPI_BYTE, i, MPI_COMM_WORLD);
    #####:  860:    delta_new+=tmp;
        -:  861:  }
    #####:  862:  delta0 = delta_new;
        -:  863:
        -:  864:
    #####:  865:  if (rank==0) fprintf (stderr, "iter = %d - delta0 = %lg - delta_new = %lg\n", iter, delta0, delta_new);
        -:  866:
    #####:  867:  while (iter < itermax && delta_new > eps*eps*delta0)
        -:  868:    {
        -:  869:      // q <= Ad
    #####:  870:      for (i=begr; i <= edr; i++)
    #####:  871:        q[i] = 0.0;
        -:  872:
        -:  873:      //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, d, q);
    #####:  874:      for (i=0;i<mpi_size;i++) {
    #####:  875:        MPI_Bcast(d+tab_begr[i], sizeof(double)*(tab_edr[i]-tab_begr[i]+1), MPI_BYTE, i, MPI_COMM_WORLD);
        -:  876:      }
    #####:  877:      for (i=begr;i<= edr;i++) {
    #####:  878:        double tmp=0;
    #####:  879:        for (j=0;j<n;j++) tmp=tmp+d[j]*mat[j+(i-begr)*nn];
    #####:  880:        q[i]=tmp;
        -:  881:      }
        -:  882:
        -:  883:      //
    #####:  884:      double dtq = 0.0;
    #####:  885:      double dtq_tmp = 0.0;
    #####:  886:      for (i=begr; i <= edr; i++)
    #####:  887:        dtq_tmp += d[i] * q[i];
    #####:  888:      for (i=0;i<mpi_size;i++) {
    #####:  889:        double tmp=dtq_tmp;
    #####:  890:        MPI_Bcast(&tmp, sizeof(double), MPI_BYTE, i, MPI_COMM_WORLD);
    #####:  891:        dtq+=tmp;
        -:  892:      }
    #####:  893:      alpha = delta_new / dtq;
    #####:  894:      for (i=begr; i<= edr; i++)
    #####:  895:        x[i] += alpha * d[i];
        -:  896:
    #####:  897:      if (iter % 100 == 0)
        -:  898:        {
    #####:  899:          if (rank==0&&iter%10==0) fprintf (stderr,"gcmat_mpi() iter = %d - delta0 = %lg - delta_new = %lg\n", iter, delta0, delta_new);
    #####:  900:          for (i=0; i < n; i++)
    #####:  901:            q[i] = 0.0;
        -:  902:
    #####:  903:          for (i=0;i<mpi_size;i++) {
    #####:  904:            MPI_Bcast(x+tab_begr[i], sizeof(double)*(tab_edr[i]-tab_begr[i]+1), MPI_BYTE, i, MPI_COMM_WORLD);
        -:  905:          }
        -:  906:
        -:  907:          //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, x, q);
    #####:  908:          for (i=begr;i<= edr;i++) {
    #####:  909:            double tmp=0;
    #####:  910:            for (j=0;j<n;j++) tmp=tmp+x[j]*mat[j+(i-begr)*nn];
    #####:  911:            q[i]=tmp;
        -:  912:          }
    #####:  913:          for (i=begr; i <= edr; i++) {
    #####:  914:            r[i] = b[i] - q[i];
        -:  915:          }
        -:  916:        }
        -:  917:      else
        -:  918:        {
    #####:  919:          for (i=begr; i<= edr; i++)
    #####:  920:            r[i] -= alpha * q[i];
        -:  921:        }
    #####:  922:      for (i=begr; i<= edr; i++)
    #####:  923:        s[i] = r[i] / hit[i];
        -:  924:
    #####:  925:      delta_old = delta_new;
    #####:  926:      delta_new = 0.0;
        -:  927:
    #####:  928:      delta_new_tmp = 0.0;
    #####:  929:      for (i = begr; i <= edr; i++) delta_new_tmp += r[i] * s[i];
    #####:  930:      delta_new=0;
    #####:  931:      for (i=0;i<mpi_size;i++) {
    #####:  932:        double tmp=delta_new_tmp;
    #####:  933:        MPI_Bcast(&tmp, sizeof(double), MPI_BYTE, i, MPI_COMM_WORLD);
    #####:  934:        delta_new+=tmp;
        -:  935:      }
    #####:  936:      beta = delta_new / delta_old;
        -:  937:
    #####:  938:      for (i=begr; i<= edr; i++)
    #####:  939:        d[i] = s[i] + beta * d[i];
    #####:  940:      iter ++;
        -:  941:    }
    #####:  942:  if (rank==0) fprintf (stderr,"gcmat_mpi2() iter = %d - delta0 = %lg - delta_new = %lg\n",
        -:  943:          iter, delta0, delta_new);
    #####:  944:  if (rank==0) fprintf (stderr,"CG in iter = %d (max=%d)\n", iter, itermax);
    #####:  945:  for (i=0;i<mpi_size;i++) {
    #####:  946:    memcpy(vec+tab_begr[i],x+tab_begr[i],(tab_edr[i]-tab_begr[i]+1)*sizeof(double));
    #####:  947:    MPI_Bcast(vec+tab_begr[i], sizeof(double)*(tab_edr[i]-tab_begr[i]+1), MPI_BYTE, i, MPI_COMM_WORLD);
        -:  948:  }
        -:  949:
    #####:  950:  _PIOFREE(tab_begr);
    #####:  951:  _PIOFREE(tab_edr);
        -:  952:
    #####:  953:  return(delta_new/delta0);
        -:  954:}
        -:  955:
        -:  956:
    #####:  957:double gcmat(double *mat,double *vec,int n,int nn)
        -:  958:{
    #####:  959:  int itermax = 1000;
    #####:  960:  double eps = 1.e-6;
        -:  961:  int iter;
        -:  962:  int i,j;
        -:  963:
    #####:  964:  long begr=0;
    #####:  965:  long edr =n-1;
        -:  966:  double delta0, delta_new, alpha, delta_old, beta;
    #####:  967:  double *x = (double *) calloc (n, sizeof (double));
    #####:  968:  double *b = (double *) calloc (n, sizeof (double));
    #####:  969:  double *d = (double *) calloc (n, sizeof (double));
    #####:  970:  double *q = (double *) calloc (n, sizeof (double));
    #####:  971:  double *r = (double *) calloc (n, sizeof (double));
    #####:  972:  double *s = (double *) calloc (n, sizeof (double));
    #####:  973:  double *hit = (double *) calloc (n, sizeof (double));
        -:  974:
    #####:  975:  memcpy(b,vec,n*sizeof(double));
        -:  976:
    #####:  977:  iter = 0;
        -:  978:  // starting point x = solution
    #####:  979:  for (i=0; i<n; i++) x[i] = 0.;
        -:  980:
        -:  981:  // Compute Ax
        -:  982:  //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, x, q);
    #####:  983:  for (i=begr;i<= edr;i++) {
    #####:  984:    double tmp=0;
    #####:  985:    for (j=0;j<n;j++) tmp=tmp+x[j]*mat[j+(i-begr)*nn];
    #####:  986:    q[i]=tmp;
        -:  987:  }
        -:  988:
    #####:  989:  for (i=begr; i <= edr; i++)
        -:  990:    {
    #####:  991:      r[i] = b[i] - q[i];
    #####:  992:      d[i] = r[i];
        -:  993:    }
        -:  994:
        -:  995:  // Preconditionnement
    #####:  996:  for (i=begr; i <=edr; i++) {
    #####:  997:    hit[i]=mat[i+(i-begr)*nn];
    #####:  998:    if (hit[i]==0) hit[i]=1;
        -:  999:  }
    #####: 1000:  for (i=begr; i<= edr; i++) {
    #####: 1001:    s[i] = r[i] / hit[i];
    #####: 1002:    d[i] /= hit[i];
        -: 1003:  }
        -: 1004:
    #####: 1005:  delta_new = 0.0;
    #####: 1006:  for (i = begr; i <= edr; i++) delta_new += r[i] * s[i];
    #####: 1007:  delta0 = delta_new;
        -: 1008:
    #####: 1009:  fprintf (stderr, "gcmat() iter = %d - delta0 = %lg - delta_new = %lg\n", iter, delta0, delta_new);
        -: 1010:
    #####: 1011:  while (iter < itermax && delta_new > eps*eps*delta0)
        -: 1012:    {
        -: 1013:
        -: 1014:      // q <= Ad
    #####: 1015:      for (i=begr; i <= edr; i++)
    #####: 1016:        q[i] = 0.0;
        -: 1017:
        -: 1018:      //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, d, q);
    #####: 1019:      for (i=begr;i<= edr;i++) {
    #####: 1020:        double tmp=0;
    #####: 1021:        for (j=0;j<n;j++) tmp=tmp+d[j]*mat[j+(i-begr)*nn];
    #####: 1022:        q[i]=tmp;
        -: 1023:      }
        -: 1024:
        -: 1025:      //
    #####: 1026:      double dtq = 0.0;
    #####: 1027:      for (i=begr; i <= edr; i++) {
    #####: 1028:        dtq += d[i] * q[i];
        -: 1029:      }
        -: 1030:
    #####: 1031:      alpha = delta_new / dtq;
    #####: 1032:      for (i=begr; i<= edr; i++)
    #####: 1033:        x[i] += alpha * d[i];
        -: 1034:
    #####: 1035:      fprintf (stderr,"gcmat2() iter = %d - delta0 = %lg - delta_new = %lg\n", iter, delta0, delta_new);
    #####: 1036:      if (iter % 100 == 0 && iter != 0)
        -: 1037:        {
    #####: 1038:          for (i=0; i < n; i++)
    #####: 1039:            q[i] = 0.0;
        -: 1040:
        -: 1041:          //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, x, q);
    #####: 1042:          for (i=begr;i<= edr;i++) {
    #####: 1043:            double tmp=0;
    #####: 1044:            for (j=0;j<n;j++) tmp=tmp+x[j]*mat[j+(i-begr)*nn];
    #####: 1045:            q[i]=tmp;
        -: 1046:          }
    #####: 1047:          for (i=begr; i <= edr; i++) {
    #####: 1048:            r[i] = b[i] - q[i];
        -: 1049:          }
        -: 1050:        }
        -: 1051:      else
        -: 1052:        {
    #####: 1053:          for (i=begr; i<= edr; i++)
    #####: 1054:            r[i] -= alpha * q[i];
        -: 1055:        }
    #####: 1056:      for (i=begr; i<= edr; i++)
    #####: 1057:        s[i] = r[i] / hit[i];
        -: 1058:
    #####: 1059:      delta_old = delta_new;
    #####: 1060:      delta_new = 0.0;
    #####: 1061:      for (i = begr; i <= edr; i++) delta_new += r[i] * s[i];
    #####: 1062:      beta = delta_new / delta_old;
        -: 1063:
    #####: 1064:      for (i=begr; i<= edr; i++)
    #####: 1065:        d[i] = s[i] + beta * d[i];
    #####: 1066:      iter ++;
        -: 1067:    }
    #####: 1068:  fprintf (stderr,"gcmat3() iter = %d - delta0 = %lg - delta_new = %lg\n",
        -: 1069:          iter, delta0, delta_new);
    #####: 1070:  fprintf (stderr,"CG in iter = %d (max=%d)\n", iter, itermax);
        -: 1071:
    #####: 1072:  memcpy(vec,x,n*sizeof(double));
    #####: 1073:  return(delta_new/delta0);
        -: 1074:}
        -: 1075:
    #####: 1076:void matmul(double *in1,double *in2,double *out,int n)
        -: 1077:{
        -: 1078:  int i,j,k;
        -: 1079:
    #####: 1080:  for (i=0;i<n;i++) {
    #####: 1081:    for (j=0;j<n;j++) {
    #####: 1082:      double tmp=0;
    #####: 1083:      for (k=0;k<n;k++) {
    #####: 1084:        tmp+=in1[i+n*k]*in2[k+n*j];
        -: 1085:      }
    #####: 1086:      out[i+j*n]=tmp;
        -: 1087:    }
        -: 1088:  }
    #####: 1089:}
        -: 1090:
    #####: 1091:void euler_matrix_new(double a1,double a2,double a3,int itype,double *mat)
        -: 1092:{
    #####: 1093:  double c1 = cos(a1);
    #####: 1094:  double s1 = sin(a1);
    #####: 1095:  double c2 = cos(a2);
    #####: 1096:  double s2 = sin(a2);
    #####: 1097:  double c3 = cos(a3);
    #####: 1098:  double s3 = sin(a3);
        -: 1099:
    #####: 1100:  double ze = 0.0;
    #####: 1101:  double un = 1.0;
        -: 1102:
        -: 1103:  double m1[9], m2[9], m3[9];
        -: 1104:
        -: 1105:  //-- form full rotation matrix --
        -: 1106:  //-- FOR REFERENCE:
        -: 1107:  //
        -: 1108:  // itype : 1
        -: 1109:  // m1 = [[ c1,-s1,  0],[ s1, c1,  0],[  0,  0,  1]] ; around   z
        -: 1110:  // m2 = [[ c2,  0, s2],[  0,  1,  0],[-s2,  0, c2]] ; around   y
        -: 1111:  // m3 = [[  1,  0,  0],[  0, c3,-s3],[  0, s3, c3]] ; around   x
        -: 1112:  //
        -: 1113:  // itype : 2
        -: 1114:  // m1 = [[ c1,-s1,  0],[ s1, c1,  0],[  0,  0,  1]] ; around   z
        -: 1115:  // m2 = [[  1,  0,  0],[  0, c2,-s2],[  0, s2, c2]] ; around   x
        -: 1116:  // m3 = [[ c3,-s3,  0],[ s3, c3,  0],[  0,  0,  1]] ; around   z
        -: 1117:  //
        -: 1118:  // itype : 3
        -: 1119:  // m1 = [[ c1,-s1,  0],[ s1, c1,  0],[  0,  0,  1]] ; around   z
        -: 1120:  // m2 = [[ c2,  0, s2],[  0,  1,  0],[-s2,  0, c2]] ; around   y
        -: 1121:  // m3 = [[ c3,-s3,  0],[ s3, c3,  0],[  0,  0,  1]] ; around   z
        -: 1122:  //
        -: 1123:  //
        -: 1124:  // matrix = m1 ( m2 m3 )
        -: 1125:
        -: 1126:  //m1(:,1) = (/ c1,-s1, ze /)
        -: 1127:  //m1(:,2) = (/ s1, c1, ze /)
        -: 1128:  // m1(:,3) = (/ ze, ze, un /)
    #####: 1129:  m1[0]=c1;  m1[3]=-s1;  m1[6]=ze;
    #####: 1130:  m1[1]=s1;  m1[4]= c1;  m1[7]=ze;
    #####: 1131:  m1[2]=ze;  m1[5]= ze;  m1[8]=un;
        -: 1132:
    #####: 1133:  switch(itype) {
        -: 1134:
    #####: 1135:  case 1: // ZYX
        -: 1136:
        -: 1137:    //m2(:,1) = (/ c2, ze, s2 /)
        -: 1138:    //m2(:,2) = (/ ze, un, ze /)
        -: 1139:    //m2(:,3) = (/-s2, ze, c2 /)
    #####: 1140:    m2[0]=c2;  m2[3]=ze;  m2[6]=s2;
    #####: 1141:    m2[1]=ze;  m2[4]=un;  m2[7]=ze;
    #####: 1142:    m2[2]=-s2; m2[5]=ze;  m2[8]=c2;
        -: 1143:
        -: 1144:    //m3(:,1) = (/ un, ze, ze /)
        -: 1145:    //m3(:,2) = (/ ze, c3,-s3 /)
        -: 1146:    //m3(:,3) = (/ ze, s3, c3 /)
    #####: 1147:    m3[0]=un;  m3[3]=ze;  m3[6]=ze;
    #####: 1148:    m3[1]=ze;  m3[4]=c3;  m3[7]=-s3;
    #####: 1149:    m3[2]=ze;  m3[5]=s3;  m3[8]=c3;
    #####: 1150:    break;
        -: 1151:
    #####: 1152:  case 2: // ZXZ
        -: 1153:
        -: 1154:    //m2(:,1) = (/ un, ze, ze /)
        -: 1155:    //m2(:,2) = (/ ze, c2,-s2 /)
        -: 1156:    //m2(:,3) = (/ ze, s2, c2 /)
    #####: 1157:    m2[0]=un;  m2[1]=ze;  m2[2]=ze;
    #####: 1158:    m2[3]=ze;  m2[4]=c2;  m2[5]=-s2;
    #####: 1159:    m2[6]=ze;  m2[7]=s2;  m2[8]=c2;
        -: 1160:
        -: 1161:
        -: 1162:    //m3(:,1) = (/ c3,-s3, ze /)
        -: 1163:    //m3(:,2) = (/ s3, c3, ze /)
        -: 1164:    //m3(:,3) = (/ ze, ze, un /)
    #####: 1165:    m3[0]=c3;  m3[1]=-s3; m3[2]=ze;
    #####: 1166:    m3[3]=s3;  m3[4]=c3;  m3[5]=ze;
    #####: 1167:    m3[6]=ze;  m3[7]=ze;  m3[8]=un;
    #####: 1168:    break;
        -: 1169:
    #####: 1170:  case 3: // ZYZ
        -: 1171:
        -: 1172:    //m2(:,1) = (/ c2, ze, s2 /)
        -: 1173:    //m2(:,2) = (/ ze, un, ze /)
        -: 1174:    //m2(:,3) = (/-s2, ze, c2 /)
    #####: 1175:    m2[0]=c2;  m2[1]=ze;  m2[2]=s2;
    #####: 1176:    m2[3]=ze;  m2[4]=un;  m2[5]=ze;
    #####: 1177:    m2[6]=-s2; m2[7]=ze;  m2[8]=c2;
        -: 1178:
        -: 1179:    //m3(:,1) = (/ c3,-s3, ze /)
        -: 1180:    //m3(:,2) = (/ s3, c3, ze /)
        -: 1181:    //m3(:,3) = (/ ze, ze, un /)
    #####: 1182:    m3[0]=c3;  m3[1]=-s3; m3[2]=ze;
    #####: 1183:    m3[3]=s3;  m3[4]=c3;  m3[5]=ze;
    #####: 1184:    m3[6]=ze;  m3[7]=ze;  m3[8]=un;
    #####: 1185:    break;
        -: 1186:
    #####: 1187:  default:
    #####: 1188:    assert( 0 && "troll.c:euler_matrix_new() error, invalid itype value.");
        -: 1189:
        -: 1190:  }
        -: 1191:  double res[9];
        -: 1192:  //matrix = matmul(m1,matmul(m2,m3))
    #####: 1193:  matmul(m2,m3,res,3);
    #####: 1194:  matmul(m1,res,mat,3);
    #####: 1195:}
        -: 1196:
        -: 1197://==================================================================================
        -: 1198://
        -: 1199://    DFPMIN MINIMISATION
        -: 1200://
        -: 1201://==================================================================================
        -: 1202:#define SIGN(a,b) ((b) >= 0.0 ? fabs(a) : -fabs(a))
        -: 1203:int ncom;       /* defined in DLINMIN */
        -: 1204:double *pcom=0,*xicom=0,(*nrfunc)(double *);
        -: 1205:void (*nrdfun)(double *,double *);
        -: 1206:
        -: 1207:
        -: 1208:#define ITMAX 10000
        -: 1209:#define EPS 1.0e-16
        -: 1210:#define FREEALL free_vector(xi,1,n);free_vector(h,1,n);free_vector(g,1,n);
        -: 1211:#define TOL 2.0e-4
        -: 1212:
        -: 1213:int ncom=0;     /* defining declarations */
        -: 1214:
        -: 1215:#define GOLD 1.618034
        -: 1216:#define GLIMIT 100.0
        -: 1217:#define TINY 1.0e-20
        -: 1218:#define NRMAX(a,b) ((a) > (b) ? (a) : (b))
        -: 1219:#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);
        -: 1220:
    #####: 1221:void mnbrak(double *ax,double *bx,double *cx,double *fa,double *fb,double *fc,double (*func)(double))
        -: 1222:{
        -: 1223:  double ulim,u,r,q,fu,dum;
        -: 1224:
    #####: 1225:  *fa=(*func)(*ax);
    #####: 1226:  *fb=(*func)(*bx);
    #####: 1227:  if (*fb > *fa) {
    #####: 1228:    SHFT(dum,*ax,*bx,dum)
    #####: 1229:    SHFT(dum,*fb,*fa,dum)
        -: 1230:  }
    #####: 1231:  *cx=(*bx)+GOLD*(*bx-*ax);
    #####: 1232:  *fc=(*func)(*cx);
    #####: 1233:  while (*fb > *fc) {
    #####: 1234:    r=(*bx-*ax)*(*fb-*fc);
    #####: 1235:    q=(*bx-*cx)*(*fb-*fa);
    #####: 1236:    u=(*bx)-((*bx-*cx)*q-(*bx-*ax)*r)/
    #####: 1237:      (2.0*SIGN(NRMAX(fabs(q-r),TINY),q-r));
    #####: 1238:    ulim=(*bx)+GLIMIT*(*cx-*bx);
    #####: 1239:    if ((*bx-u)*(u-*cx) > 0.0) {
    #####: 1240:      fu=(*func)(u);
    #####: 1241:      if (fu < *fc) {
    #####: 1242:        *ax=(*bx);
    #####: 1243:        *bx=u;
    #####: 1244:        *fa=(*fb);
    #####: 1245:        *fb=fu;
    #####: 1246:        return;
    #####: 1247:      } else if (fu > *fb) {
    #####: 1248:        *cx=u;
    #####: 1249:        *fc=fu;
    #####: 1250:        return;
        -: 1251:      }
    #####: 1252:      u=(*cx)+GOLD*(*cx-*bx);
    #####: 1253:      fu=(*func)(u);
    #####: 1254:    } else if ((*cx-u)*(u-ulim) > 0.0) {
    #####: 1255:      fu=(*func)(u);
    #####: 1256:      if (fu < *fc) {
    #####: 1257:        SHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx))
    #####: 1258:        SHFT(*fb,*fc,fu,(*func)(u))
        -: 1259:      }
    #####: 1260:    } else if ((u-ulim)*(ulim-*cx) >= 0.0) {
    #####: 1261:      u=ulim;
    #####: 1262:      fu=(*func)(u);
        -: 1263:    } else {
    #####: 1264:      u=(*cx)+GOLD*(*cx-*bx);
    #####: 1265:      fu=(*func)(u);
        -: 1266:    }
    #####: 1267:    SHFT(*ax,*bx,*cx,u)
    #####: 1268:    SHFT(*fa,*fb,*fc,fu)
        -: 1269:  }
        -: 1270:}
        -: 1271:
        -: 1272:#undef GOLD
        -: 1273:#undef GLIMIT
        -: 1274:#undef TINY
        -: 1275:#undef NRMAX
        -: 1276:#undef SHFT
        -: 1277:
        -: 1278:#define CGOLD 0.3819660
        -: 1279:#define ZEPS 1.0e-10
        -: 1280:#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);
        -: 1281:
    #####: 1282:double brent(double ax,double bx,double cx,double (*f)(double ),double tol,double *xmin)
        -: 1283:{
        -: 1284:  int iter;
    #####: 1285:  double a,b,d=0.0,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;
    #####: 1286:  double e=0.0;
        -: 1287:
    #####: 1288:  a=((ax < cx) ? ax : cx);
    #####: 1289:  b=((ax > cx) ? ax : cx);
    #####: 1290:  x=w=v=bx;
    #####: 1291:  fw=fv=fx=(*f)(x);
    #####: 1292:  for (iter=0;iter<ITMAX;iter++) {
    #####: 1293:    xm=0.5*(a+b);
    #####: 1294:    tol2=2.0*(tol1=tol*fabs(x)+ZEPS);
    #####: 1295:    if (fabs(x-xm) <= (tol2-0.5*(b-a))) {
    #####: 1296:      *xmin=x;
    #####: 1297:      return fx;
        -: 1298:    }
    #####: 1299:    if (fabs(e) > tol1) {
    #####: 1300:      r=(x-w)*(fx-fv);
    #####: 1301:      q=(x-v)*(fx-fw);
    #####: 1302:      p=(x-v)*q-(x-w)*r;
    #####: 1303:      q=2.0*(q-r);
    #####: 1304:      if (q > 0.0) p = -p;
    #####: 1305:      q=fabs(q);
    #####: 1306:      etemp=e;
    #####: 1307:      e=d;
    #####: 1308:      if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))
    #####: 1309:        d=CGOLD*(e=(x >= xm ? a-x : b-x));
        -: 1310:      else {
    #####: 1311:        d=p/q;
    #####: 1312:        u=x+d;
    #####: 1313:        if (u-a < tol2 || b-u < tol2)
    #####: 1314:          d=SIGN(tol1,xm-x);
        -: 1315:      }
        -: 1316:    } else {
    #####: 1317:      d=CGOLD*(e=(x >= xm ? a-x : b-x));
        -: 1318:    }
    #####: 1319:    u=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));
    #####: 1320:    fu=(*f)(u);
    #####: 1321:    if (fu <= fx) {
    #####: 1322:      if (u >= x) a=x; else b=x;
    #####: 1323:      SHFT(v,w,x,u)
    #####: 1324:      SHFT(fv,fw,fx,fu)
        -: 1325:    } else {
    #####: 1326:      if (u < x) a=u; else b=u;
    #####: 1327:      if (fu <= fw || w == x) {
    #####: 1328:        v=w;
    #####: 1329:        w=u;
    #####: 1330:        fv=fw;
    #####: 1331:        fw=fu;
    #####: 1332:      } else if (fu <= fv || v == x || v == w) {
    #####: 1333:        v=u;
    #####: 1334:        fv=fu;
        -: 1335:      }
        -: 1336:    }
        -: 1337:  }
    #####: 1338:  fprintf(stderr,"Too many iterations in BRENT");
    #####: 1339:  *xmin=x;
    #####: 1340:  return fx;
        -: 1341:}
        -: 1342:
        -: 1343:#undef CGOLD
        -: 1344:#undef ZEPS
        -: 1345:
        -: 1346:#define NRANSI
        -: 1347:#define ZEPS 1.0e-10
        -: 1348:#define MOV3(a,b,c, d,e,f) (a)=(d);(b)=(e);(c)=(f);
        -: 1349:
    #####: 1350:double dbrent(double ax, double bx, double cx, double (*f)(double),
        -: 1351:        double (*df)(double), double tol, double *xmin)
        -: 1352:{
        -: 1353:  int iter,ok1,ok2;
    #####: 1354:  double a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;
        -: 1355:  double fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;
        -: 1356:
    #####: 1357:  a=(ax < cx ? ax : cx);
    #####: 1358:  b=(ax > cx ? ax : cx);
    #####: 1359:  x=w=v=bx;
    #####: 1360:  fw=fv=fx=(*f)(x);
    #####: 1361:  dw=dv=dx=(*df)(x);
    #####: 1362:  for (iter=0;iter<ITMAX;iter++) {
    #####: 1363:    xm=0.5*(a+b);
    #####: 1364:    tol1=tol*fabs(x)+ZEPS;
    #####: 1365:    tol2=2.0*tol1;
    #####: 1366:    if (fabs(x-xm) <= (tol2-0.5*(b-a))) {
    #####: 1367:      *xmin=x;
    #####: 1368:      return fx;
        -: 1369:    }
    #####: 1370:    if (fabs(e) > tol1) {
    #####: 1371:      d1=2.0*(b-a);
    #####: 1372:      d2=d1;
    #####: 1373:      if (dw != dx) d1=(w-x)*dx/(dx-dw);
    #####: 1374:      if (dv != dx) d2=(v-x)*dx/(dx-dv);
    #####: 1375:      u1=x+d1;
    #####: 1376:      u2=x+d2;
    #####: 1377:      ok1 = (a-u1)*(u1-b) > 0.0 && dx*d1 <= 0.0;
    #####: 1378:      ok2 = (a-u2)*(u2-b) > 0.0 && dx*d2 <= 0.0;
    #####: 1379:      olde=e;
    #####: 1380:      e=d;
    #####: 1381:      if (ok1 || ok2) {
    #####: 1382:        if (ok1 && ok2)
    #####: 1383:          d=(fabs(d1) < fabs(d2) ? d1 : d2);
    #####: 1384:        else if (ok1)
    #####: 1385:          d=d1;
        -: 1386:        else
    #####: 1387:          d=d2;
    #####: 1388:        if (fabs(d) <= fabs(0.5*olde)) {
    #####: 1389:          u=x+d;
    #####: 1390:          if (u-a < tol2 || b-u < tol2)
    #####: 1391:            d=SIGN(tol1,xm-x);
        -: 1392:        } else {
    #####: 1393:          d=0.5*(e=(dx >= 0.0 ? a-x : b-x));
        -: 1394:        }
        -: 1395:      } else {
    #####: 1396:        d=0.5*(e=(dx >= 0.0 ? a-x : b-x));
        -: 1397:      }
        -: 1398:    } else {
    #####: 1399:      d=0.5*(e=(dx >= 0.0 ? a-x : b-x));
        -: 1400:    }
    #####: 1401:    if (fabs(d) >= tol1) {
    #####: 1402:      u=x+d;
    #####: 1403:      fu=(*f)(u);
        -: 1404:    } else {
    #####: 1405:      u=x+SIGN(tol1,d);
    #####: 1406:      fu=(*f)(u);
    #####: 1407:      if (fu > fx) {
    #####: 1408:        *xmin=x;
    #####: 1409:        return fx;
        -: 1410:      }
        -: 1411:    }
    #####: 1412:    du=(*df)(u);
    #####: 1413:    if (fu <= fx) {
    #####: 1414:      if (u >= x) a=x; else b=x;
    #####: 1415:      MOV3(v,fv,dv, w,fw,dw)
    #####: 1416:      MOV3(w,fw,dw, x,fx,dx)
    #####: 1417:      MOV3(x,fx,dx, u,fu,du)
        -: 1418:    } else {
    #####: 1419:      if (u < x) a=u; else b=u;
    #####: 1420:      if (fu <= fw || w == x) {
    #####: 1421:        MOV3(v,fv,dv, w,fw,dw)
    #####: 1422:        MOV3(w,fw,dw, u,fu,du)
    #####: 1423:      } else if (fu < fv || v == x || v == w) {
    #####: 1424:        MOV3(v,fv,dv, u,fu,du)
        -: 1425:          }
        -: 1426:    }
        -: 1427:  }
    #####: 1428:  fprintf(stderr,"Too many iterations in routine dbrent");
    #####: 1429:  return 0.0;
        -: 1430:}
        -: 1431:
    #####: 1432:double f1dim(double x)
        -: 1433:{
        -: 1434:  int j;
        -: 1435:  double f,*xt;
        -: 1436:
    #####: 1437:  xt= (double *) malloc(ncom*sizeof(double));
    #####: 1438:  for (j=0;j<ncom;j++) xt[j]=pcom[j]+x*xicom[j];
    #####: 1439:  f=(*nrfunc)(xt);
    #####: 1440:  free(xt);
    #####: 1441:  return f;
        -: 1442:}
        -: 1443:
    #####: 1444:double df1dim(double x)
        -: 1445:{
        -: 1446:
        -: 1447:  int j;
    #####: 1448:  double df1=0.0;
        -: 1449:  double *xt,*df;
        -: 1450:
    #####: 1451:  xt= (double *) malloc(ncom*sizeof(double));
    #####: 1452:  df= (double *) malloc(ncom*sizeof(double));
    #####: 1453:  for (j=0;j<ncom;j++) xt[j]=pcom[j]+x*xicom[j];
    #####: 1454:  (*nrdfun)(xt,df);
    #####: 1455:  for (j=0;j<ncom;j++) df1 += df[j]*xicom[j];
    #####: 1456:  free(df);
    #####: 1457:  free(xt);
    #####: 1458:  return df1;
        -: 1459:}
        -: 1460:
        -: 1461:
        -: 1462:
    #####: 1463:void dlinmin(double *p,double *xi,int n,double *fret,
        -: 1464:            double (*func)(double *p),
        -: 1465:            void (*dfunc)(double *p,double *xi))
        -: 1466:{
        -: 1467:  int j;
        -: 1468:  double xx,fx,fb,fa,bx,ax;
    #####: 1469:  double xmin = DBL_MIN;
        -: 1470:  void mnbrak();
        -: 1471:
    #####: 1472:  ncom=n;
    #####: 1473:  double *pcom=(double *) malloc(sizeof(double)*n);
    #####: 1474:  double *xicom=(double *) malloc(sizeof(double)*n);
    #####: 1475:  nrfunc=func;
    #####: 1476:  nrdfun=dfunc;
    #####: 1477:  for (j=0;j<n;j++) {
    #####: 1478:    pcom[j]=p[j];
    #####: 1479:    xicom[j]=xi[j];
        -: 1480:  }
    #####: 1481:  ax=0.0;
    #####: 1482:  xx=1.0;
    #####: 1483:  mnbrak(&ax,&xx,&bx,&fa,&fx,&fb,f1dim);
    #####: 1484:  *fret=dbrent(ax,xx,bx,f1dim,df1dim,TOL,&xmin);
    #####: 1485:  for (j=0;j<n;j++) {
    #####: 1486:    xi[j] *= xmin;
    #####: 1487:    p[j] += xi[j];
        -: 1488:  }
    #####: 1489:  free(xicom);free(pcom);
    #####: 1490:}
        -: 1491:#define NRANSI
        -: 1492:#define TOL 2.0e-4
        -: 1493:
        -: 1494:int gainoff=0;
        -: 1495:PIOLONG nbolo;
        -: 1496:PIOLONG GAINSTEP;
        -: 1497:PIOLONG GAINSTEPADU;
        -: 1498:
    #####: 1499:void linmin(double *p, double *xi, int n, double *fret,
        -: 1500:            double (*func)(double *))
        -: 1501:{
        -: 1502:  int j;
        -: 1503:  double xx,xmin,fx,fb,fa,bx,ax;
        -: 1504:
    #####: 1505:  ncom=n;
    #####: 1506:  pcom= (double *)malloc(n*sizeof(double));
    #####: 1507:  xicom= (double *)malloc(n*sizeof(double));
    #####: 1508:  nrfunc=func;
    #####: 1509:  for (j=0;j<n;j++) {
    #####: 1510:    pcom[j]=p[j];
    #####: 1511:    xicom[j]=xi[j];
        -: 1512:  }
    #####: 1513:  ax=0.0;
    #####: 1514:  xx=1.0;
        -: 1515:  // peut-etre ici que j'evite de me taper les >>1%
    #####: 1516:  double total=1;
    #####: 1517:  while (total>1E-3) {
    #####: 1518:    total=0;
    #####: 1519:    for (j=0;j<GAINSTEP*nbolo;j++) {
    #####: 1520:      total=(p[j+gainoff]+xx*xi[j+gainoff]-1)*(p[j+gainoff]+xx*xi[j+gainoff]-1);
        -: 1521:    }
    #####: 1522:    total/=((double) n);
    #####: 1523:    if (total>1E-3) xx/=2;
        -: 1524:  }
        -: 1525:
    #####: 1526:  mnbrak(&ax,&xx,&bx,&fa,&fx,&fb,f1dim);
    #####: 1527:  *fret=brent(ax,xx,bx,f1dim,TOL,&xmin);
        -: 1528:
        -: 1529:  // autre endroit ou j'evite de me taper les >>1%
    #####: 1530:  total=1;
    #####: 1531:  while (total>1E-3) {
    #####: 1532:    total=0;
    #####: 1533:    for (j=0;j<GAINSTEP*nbolo;j++) {
    #####: 1534:      total=(xmin*xi[j+gainoff])*(xmin*xi[j+gainoff]);
        -: 1535:    }
    #####: 1536:    total/=((double) n);
    #####: 1537:    if (total>1E-3) xmin/=2;
        -: 1538:  }
        -: 1539:
    #####: 1540:  for (j=0;j<n;j++) {
    #####: 1541:    xi[j] *= xmin;
    #####: 1542:    p[j] += xi[j];
        -: 1543:  }
    #####: 1544:  free(xicom);
    #####: 1545:  free(pcom);
    #####: 1546:}
        -: 1547:#undef TOL
        -: 1548:#undef NRANSI
        -: 1549:
        -: 1550:#undef TOL
        -: 1551:PIOLONG *newnr;
        -: 1552:
    #####: 1553:void frprmn(double *p,int n,double ftol,int *iter,double *fret,
        -: 1554:            double (*func)(double *p),
        -: 1555:            void  (*dfunc)(double *p,double *xi))
        -: 1556:{
        -: 1557:  int j,its;
        -: 1558:  double gg,gam,fp,dgg;
    #####: 1559:  double *g = (double *) malloc(sizeof(double)*n);
    #####: 1560:  double *h = (double *) malloc(sizeof(double)*n);
    #####: 1561:  double *xi= (double *) malloc(sizeof(double)*n);
        -: 1562:
        -: 1563:  int rank_size;
    #####: 1564:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
    #####: 1565:  int rank=rank_size;
        -: 1566:
    #####: 1567:  memset(h,0,sizeof(double)*n);
    #####: 1568:  fp=(*func)(p);
    #####: 1569:  (*dfunc)(p,xi);
    #####: 1570:  for (j=0;j<n;j++) {
    #####: 1571:    g[j] = -xi[j];
    #####: 1572:    xi[j]=h[j]=g[j];
        -: 1573:  }
    #####: 1574:  for (its=0;its<ITMAX;its++) {
    #####: 1575:    *iter=its;
    #####: 1576:    linmin(p,xi,n,fret,func);
    #####: 1577:    if (2.0*fabs(*fret-fp) <= ftol*(fabs(*fret)+fabs(fp)+EPS)||*fret>fp) {
    #####: 1578:      free(g);free(h);free(xi);
    #####: 1579:      if (rank==0) fprintf(stderr,"ABS OK fret[%ld] = %lg %lg %lg %lg %lg %lg\n",(long) its,fp,*fret,p[0],p[1],p[2],p[3]);
    #####: 1580:      return;
        -: 1581:    }
    #####: 1582:    if (rank==0) fprintf(stderr,"fret[%ld] = %lg %lg %lg %lg %lg %lg : %lg\n",(long) its,fp,*fret,
    #####: 1583:                         p[0]-1.01,p[1]-1.01,p[2]-1.01,p[3]-1.01,
    #####: 1584:                          (p[0]-1.01)*(p[0]-1.01)+
    #####: 1585:                          (p[1]-1.01)*(p[1]-1.01)+
    #####: 1586:                          (p[2]-1.01)*(p[2]-1.01)+
    #####: 1587:                          (p[3]-1.01)*(p[3]-1.01));
        -: 1588:
    #####: 1589:    fp=(*func)(p);
    #####: 1590:    (*dfunc)(p,xi);
    #####: 1591:    dgg=gg=0.0;
    #####: 1592:    for (j=0;j<n;j++) {
    #####: 1593:      gg += g[j]*g[j];
    #####: 1594:      dgg += xi[j]*xi[j];
        -: 1595:      //dgg += (xi[j]+g[j])*xi[j];
        -: 1596:    }
    #####: 1597:    if (gg == 0.0) {
    #####: 1598:      free(g);free(h);free(xi);
    #####: 1599:      if (rank==0) fprintf(stderr,"gg==0 fret[%ld] = %lg %lg %lg %lg %lg\n",(long) its,*fret,p[newnr[nbolo]-1],
    #####: 1600:                           p[newnr[nbolo]],p[newnr[nbolo]+1],p[newnr[nbolo]+2]);
    #####: 1601:      return;
        -: 1602:    }
    #####: 1603:    gam=dgg/gg;
    #####: 1604:    for (j=0;j<n;j++) {
    #####: 1605:      g[j] = -xi[j];
    #####: 1606:      xi[j]=h[j]=g[j]+gam*h[j];
        -: 1607:    }
        -: 1608:  }
    #####: 1609:  free(g);free(h);free(xi);
        -: 1610:  //fprintf(stderr,"Too many iterations in FRPRMN\n");
        -: 1611:}
        -: 1612:
        -: 1613:#undef ITMAX
        -: 1614:#undef EPS
        -: 1615:#undef FREEALL
        -: 1616:
        -: 1617:
        -: 1618:#define ITMAX 2000
        -: 1619:#define EPS 1.0e-10
        -: 1620:
    #####: 1621:void dfpmin(double *p,int n,double ftol,int *iter,double *fret,double (*func)(),void (*dfunc)())
        -: 1622:{
        -: 1623:  int rank_size;
    #####: 1624:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
    #####: 1625:  int rank=rank_size;
        -: 1626:  int j,i,its;
        -: 1627:  double fp,fae,fad,fac;
        -: 1628:  double *xi,*g,*dg,*hdg,*vector();
        -: 1629:  double **hessin,**matrix();
    #####: 1630:  double *p0=(double *)malloc(sizeof(double)*n);
    #####: 1631:  for (i=0;i<n;i++) p0[i]=2;
        -: 1632:
    #####: 1633:  hessin=(double **) malloc(sizeof(double *)*n);
    #####: 1634:  for (i=0;i<n;i++) hessin[i]=(double *) malloc(sizeof(double)*n);
        -: 1635:
    #####: 1636:  xi=(double *) malloc(sizeof(double)*n);
    #####: 1637:  g=(double *) malloc(sizeof(double)*n);
    #####: 1638:  dg=(double *) malloc(sizeof(double)*n);
    #####: 1639:  hdg=(double *) malloc(sizeof(double)*n);
    #####: 1640:  fp=(*func)(p);
    #####: 1641:  (*dfunc)(p,g);
        -: 1642:
    #####: 1643:  for (i=0;i<n;i++) {
    #####: 1644:    for (j=0;j<n;j++) hessin[i][j]=0.0;
    #####: 1645:    hessin[i][i]=1.0;
    #####: 1646:    xi[i] = -g[i];
        -: 1647:  }
    #####: 1648:  for (its=0;its<ITMAX;its++) {
    #####: 1649:    *iter=its;
    #####: 1650:    linmin(p,xi,n,fret,func);
    #####: 1651:    double diffp=0;
    #####: 1652:    for (i=0;i<n;i++) diffp+=(p0[i]-p[i])*(p0[i]-p[i]);
    #####: 1653:    diffp=sqrt(diffp/n);
        -: 1654:
    #####: 1655:    if (2.0*fabs(*fret-fp) <= ftol*(fabs(*fret)+fabs(fp)+EPS)||*fret<1E-10||diffp<1E-10 ||fabs(*fret-fp)<1E-12) {
    #####: 1656:      if (rank==0) fprintf(stderr,"END ABS fret[%ld] = %.10lg %.10lg %lg %lg %lg %lg : %lg %lg %lg\n",(long) its,fp,*fret,
    #####: 1657:                           p[gainoff+0],p[gainoff+1],p[gainoff+2],p[gainoff+3],ftol*(fabs(*fret)+fabs(fp)+EPS),fabs(*fret-fp),diffp);
    #####: 1658:      free(hdg);
    #####: 1659:      free(dg);
    #####: 1660:      free(g);
    #####: 1661:      free(xi);
    #####: 1662:      free(p0);
    #####: 1663:      for (i=0;i<n;i++) free(hessin[i]);
    #####: 1664:      free(hessin);
    #####: 1665:      return;
        -: 1666:    }
    #####: 1667:    memcpy(p0,p,n*sizeof(double));
        -: 1668:
    #####: 1669:    if (rank==0) fprintf(stderr,"fret[%ld] %lg =\t%.10lg\t%.10lg\t%lg\t[ %lg %lg %lg %lg ]\n",(long) its,diffp,fp,*fret,fp-*fret,
    #####: 1670:                         p[gainoff+0],p[gainoff+1],p[gainoff+2],p[gainoff+3]);
    #####: 1671:    fp=(*fret);
    #####: 1672:    for (i=0;i<n;i++) dg[i]=g[i];
    #####: 1673:    *fret=(*func)(p);
    #####: 1674:    (*dfunc)(p,g);
    #####: 1675:    for (i=0;i<n;i++) dg[i]=g[i]-dg[i];
    #####: 1676:    for (i=0;i<n;i++) {
    #####: 1677:      hdg[i]=0.0;
    #####: 1678:      for (j=0;j<n;j++) hdg[i] += hessin[i][j]*dg[j];
        -: 1679:    }
    #####: 1680:    fac=fae=0.0;
    #####: 1681:    for (i=0;i<n;i++) {
    #####: 1682:      fac += dg[i]*xi[i];
    #####: 1683:      fae += dg[i]*hdg[i];
        -: 1684:    }
    #####: 1685:    fac=1.0/fac;
    #####: 1686:    fad=1.0/fae;
    #####: 1687:    for (i=0;i<n;i++) dg[i]=fac*xi[i]-fad*hdg[i];
    #####: 1688:    for (i=0;i<n;i++)
    #####: 1689:      for (j=0;j<n;j++)
    #####: 1690:        hessin[i][j] += fac*xi[i]*xi[j]
    #####: 1691:          -fad*hdg[i]*hdg[j]+fae*dg[i]*dg[j];
    #####: 1692:    for (i=0;i<n;i++) {
    #####: 1693:      xi[i]=0.0;
    #####: 1694:      for (j=0;j<n;j++) xi[i] -= hessin[i][j]*g[j];
        -: 1695:    }
        -: 1696:  }
    #####: 1697:  fprintf(stderr,"Too many iterations in DFPMIN");
        -: 1698:}
        -: 1699:
        -: 1700:#undef ITMAX
        -: 1701:#undef EPS
        -: 1702:
        -: 1703:double **rawcst;
        -: 1704:
        -: 1705:int nadudeg=1;
        -: 1706:
        -: 1707:// TODO TODO
        -: 1708:long nnbpix;
        -: 1709:hpix **loc_hpix;
        -: 1710:PIOLONG *loc_nhpix;
        -: 1711:
        -: 1712:double *SSI;
        -: 1713:double *SSQ;
        -: 1714:double *SSU;
        -: 1715:double *SSI2;
        -: 1716:double *SSQ2;
        -: 1717:double *SSU2;
        -: 1718:double *II;
        -: 1719:double *IQ;
        -: 1720:double *IU;
        -: 1721:double *QQ;
        -: 1722:double *UU;
        -: 1723:double *QU;
        -: 1724:
        -: 1725:double *dthetai;
        -: 1726:double *dthetaq;
        -: 1727:double *dthetau;
        -: 1728:
        -: 1729:double *dii;
        -: 1730:double *dqq;
        -: 1731:double *duu;
        -: 1732:
        -: 1733://double *ddegi;
        -: 1734://double *ddegq;
        -: 1735://double *ddegu;
        -: 1736:
        -: 1737:double *dcoi;
        -: 1738:double *dcoq;
        -: 1739:double *dcou;
        -: 1740:
        -: 1741:double *dfri;
        -: 1742:double *dfrq;
        -: 1743:double *dfru;
        -: 1744:
        -: 1745:double *ddusti;
        -: 1746:double *ddustq;
        -: 1747:double *ddustu;
        -: 1748:
        -: 1749:double *dpixi;
        -: 1750:double *dpixq;
        -: 1751:double *dpixu;
        -: 1752:
        -: 1753:double *daduspli;
        -: 1754:double *dadusplq;
        -: 1755:double *dadusplu;
        -: 1756:
        -: 1757:double *cdip;
        -: 1758:double *cco;
        -: 1759:double *ccfree;
        -: 1760:double *ctheta;
        -: 1761:double *cdust;
        -: 1762:double *cpix;
        -: 1763:double *dapix;
        -: 1764:double *ctmp;
        -: 1765:double *g;
        -: 1766:PIOBYTE *flgpix;
        -: 1767:
        -: 1768:troll_parContent* Param;
        -: 1769:
        -: 1770:PIOLONG globalBeginRing;
        -: 1771:PIOLONG globalEndRing;
        -: 1772:PIOLONG globalRangeRing;
        -: 1773:// This new struct allow to store the ring distribution (begin/end) among each rank
        -: 1774:typedef struct {
        -: 1775:  PIOLONG *BeginRing;
        -: 1776:  PIOLONG *EndRing;
        -: 1777:} rankInfo;
        -: 1778:
        -: 1779:rankInfo globalRankInfo;
        -: 1780:
        -: 1781:
        -: 1782:PIOINT **rgord;
        -: 1783:
        -: 1784:double *eta_dest;
        -: 1785:double *eta;
        -: 1786:double *dpsico;
        -: 1787:double *dpsisi;
        -: 1788:
        -: 1789:PIOLONG nadu=0;
        -: 1790:
        -: 1791:
        -: 1792:PIOBYTE **flg_rg;
        -: 1793:long npixbeam;
        -: 1794:PIOLONG nmatco;
        -: 1795:PIOLONG nfreefree;
        -: 1796:PIOLONG nmatdust;
        -: 1797:long ittt,itbogo;
        -: 1798:double *qmat;
        -: 1799:double *umat;
        -: 1800:long nmatres;
        -: 1801:int testzero=-1;
        -: 1802:
        -: 1803:double normaoff=0;
        -: 1804:double *NEP_tab = NULL;
        -: 1805:
        -: 1806:DETNAME *pixnames;   // array of bolometers pixname in the same order as in the parameter files
        -: 1807:int     *freqs;      // frequency of each bolometer in pixnames array
        -: 1808:int      singleFreq; // set to the frequency of all bolometers if single channel, else 0
        -: 1809:
        -: 1810:long REMHDIP;
        -: 1811:long DOFITANGLE=0;
        -: 1812:long DOFITPOLEFF=0;
        -: 1813:long DOCO13=0;
        -: 1814:long NDOCNN=0;
        -: 1815:int DOCNN[MAXTHEOHPR];
        -: 1816:PIOBYTE COMP_CNN=0;
        -: 1817:WrapPython MyPythonBackend;
        -: 1818:
        -: 1819:PIOINT DOSYNCHRO=0;
        -: 1820:double *x2;
        -: 1821:double *x2old;
        -: 1822:double *x2init;
        -: 1823:double *b2;
        -: 1824:double *d2;
        -: 1825:double *q2;
        -: 1826:double *r2;
        -: 1827:double *s2;
        -: 1828:double *hit2;
        -: 1829:PIOLONG docutrg;
        -: 1830:
        -: 1831:long nmatpix;
        -: 1832:#define FITGAIN
        -: 1833:#ifdef FITGAIN
        -: 1834:  int nitbogo=4;
        -: 1835:#else
        -: 1836:  int nitbogo=1;
        -: 1837:#endif
        -: 1838:int DOTDUST;
        -: 1839:int MAXFREQ=0;
        -: 1840:PIOLONG CUTRG;
        -: 1841:PIOLONG *newnr2;
        -: 1842:PIOINT **rgord2;
        -: 1843://int *the_stat_pix;
        -: 1844:double delta0;
        -: 1845:
        -: 1846:double **cache_xi2;
        -: 1847:double **cache_gain_xi2;
        -: 1848:long n_cache_xi2=0;
        -: 1849:
        -: 1850:int NOMOREFITTED=0;
        -: 1851:
        -: 1852:double *mat1_adu=NULL;
        -: 1853:double *mat2_adu=NULL;
        -: 1854:
        -: 1855:
    #####: 1856:void plotfloat(float *data,int ndata)
        -: 1857:{
        -: 1858:  int i;
        -: 1859:
    #####: 1860:  PyObject *arglist = Py_BuildValue("(l)", (long) ndata);
    #####: 1861:  PyObject *py_table  = EXECPYTHON(PyObject_CallObject(MyPythonBackend.allocf32, arglist));
        -: 1862:
    #####: 1863:  float *signal  = (float * )PyArray_DATA((PyArrayObject *)py_table  );
    #####: 1864:  for (i=0;i<ndata;i++) {
    #####: 1865:    signal[i]=data[i];
        -: 1866:  }
        -: 1867:  
    #####: 1868:  arglist = PyTuple_New(1);
    #####: 1869:  PyTuple_SetItem(arglist,0,py_table);
        -: 1870:  
    #####: 1871:  PyObject *myrun = EXECPYTHON(PyObject_CallObject(MyPythonBackend.pltvec, arglist));
    #####: 1872:  if (myrun==NULL) exit(0);
    #####: 1873:  Py_DECREF(arglist); 
    #####: 1874:}
    #####: 1875:void plothistofloat(float *data,float *hdata,int ndata)
        -: 1876:{
        -: 1877:  int i;
        -: 1878:
    #####: 1879:  PyObject *arglist = Py_BuildValue("(l)", (long) ndata);
    #####: 1880:  PyObject *py_table  = EXECPYTHON(PyObject_CallObject(MyPythonBackend.allocf32, arglist));
    #####: 1881:  PyObject *py_wtable  = EXECPYTHON(PyObject_CallObject(MyPythonBackend.allocf32, arglist));
        -: 1882:
    #####: 1883:  float *signal  = (float * )PyArray_DATA((PyArrayObject *)py_table  );
    #####: 1884:  for (i=0;i<ndata;i++) {
    #####: 1885:    signal[i]=data[i];
        -: 1886:  }
    #####: 1887:  signal  = (float * )PyArray_DATA((PyArrayObject *)py_wtable  );
    #####: 1888:  for (i=0;i<ndata;i++) {
    #####: 1889:    signal[i]=hdata[i];
        -: 1890:  }
        -: 1891:  
    #####: 1892:  arglist = PyTuple_New(2);
    #####: 1893:  PyTuple_SetItem(arglist,0,py_table);
    #####: 1894:  PyTuple_SetItem(arglist,1,py_wtable);
        -: 1895:  
    #####: 1896:  PyObject *myrun = EXECPYTHON(PyObject_CallObject(MyPythonBackend.plthisto, arglist));
    #####: 1897:  if (myrun==NULL) exit(0);
    #####: 1898:  Py_DECREF(arglist); 
    #####: 1899:}
        -: 1900:
        -: 1901:
    #####: 1902:void plotdouble(double *data,int ndata)
        -: 1903:{
        -: 1904:  int i;
        -: 1905:
    #####: 1906:  PyObject *arglist = Py_BuildValue("(l)", (long) ndata);
    #####: 1907:  PyObject *py_table  = EXECPYTHON(PyObject_CallObject(MyPythonBackend.allocf32, arglist));
        -: 1908:
    #####: 1909:  float *signal  = (float * )PyArray_DATA((PyArrayObject *)py_table  );
    #####: 1910:  for (i=0;i<ndata;i++) {
    #####: 1911:    signal[i]=data[i];
        -: 1912:  }
        -: 1913:  
    #####: 1914:  arglist = PyTuple_New(1);
    #####: 1915:  PyTuple_SetItem(arglist,0,py_table);
        -: 1916:  
    #####: 1917:  PyObject *myrun = EXECPYTHON(PyObject_CallObject(MyPythonBackend.pltvec, arglist));
    #####: 1918:  if (myrun==NULL) exit(0);
    #####: 1919:  Py_DECREF(arglist); 
    #####: 1920:}
        -: 1921:
    #####: 1922:void minimize_gain_gi(double *ix2,double *gaingi)
        -: 1923:{
        -: 1924:  MPI_Status statu;
        -: 1925:  long i,rrk,j,k,l1,l2,ib;
    #####: 1926:  int itermax = (NUMBEROFITER);
        -: 1927:  int iter;
        -: 1928:  double  delta_new, delta_old, beta;
    #####: 1929:  double  alpha=1.0; // get rid of gcc "maybe-uninitialized" warning depending on optimsation level
        -: 1930:
        -: 1931:  PIOLONG GAINSTEP2;
        -: 1932:  int rank;
        -: 1933:  int size;
        -: 1934:  int mpi_size;
        -: 1935:  int rank_size;
    #####: 1936:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
    #####: 1937:  rank=rank_size;
    #####: 1938:  MPI_Comm_size(MPI_COMM_WORLD,&size);
    #####: 1939:  mpi_size=size;
        -: 1940:
    #####: 1941:  GAINSTEP2=GAINSTEP;
        -: 1942:
    #####: 1943:  nmatres=newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+nfreefree;
        -: 1944:
    #####: 1945:  if (rank==0) {
    #####: 1946:    fprintf(stderr,"==============================\n\nminimize_gain_gi(): ITERATION %ld/%d\n\n==============================\n",itbogo,Param->NITT);
    #####: 1947:    fprintf(stderr,"DISTOR %d\n",(int) DODISTOR);
    #####: 1948:    fprintf(stderr,"GAIN ");
    #####: 1949:    for (i=0;i<nbolo;i++) fprintf(stderr,"%lg ",gaingi[i*GAINSTEP]);
    #####: 1950:    fprintf(stderr,"\n");
    #####: 1951:    if (GAINSTEP>1) {
    #####: 1952:      fprintf(stderr,"...\nGAIN ");
    #####: 1953:      for (i=0;i<nbolo;i++) fprintf(stderr,"%lg ",gaingi[i*GAINSTEP+(GAINSTEP-1)]);
    #####: 1954:      fprintf(stderr,"\n");
        -: 1955:    }
        -: 1956:  }
    #####: 1957:  if (itbogo==0) delta0=0;
    #####: 1958:  MPI_Barrier(MPI_COMM_WORLD);
        -: 1959:
        -: 1960:  struct timeval tp1,tp2;
    #####: 1961:  gettimeofday(&tp1,NULL);
        -: 1962:
    #####: 1963:  iter = 0;
    #####: 1964:  memset(b2  ,0,nmatres*sizeof (double));
    #####: 1965:  memset(d2  ,0,nmatres*sizeof (double));
    #####: 1966:  memset(q2  ,0,nmatres*sizeof (double));
    #####: 1967:  memset(r2  ,0,nmatres*sizeof (double));
    #####: 1968:  memset(s2  ,0,nmatres*sizeof (double));
    #####: 1969:  memset(hit2,0,nmatres*sizeof (double));
        -: 1970:
        -: 1971:  //==========================================
        -: 1972:  //=  Compute second member
        -: 1973:  //=
        -: 1974:  //=
        -: 1975:  long l,m;
        -: 1976:
        -: 1977:  ////// BUILD B2
        -: 1978:  //GetProcMem(&vmem,&phymem);
        -: 1979:  //if (rank==0) fprintf(stderr,"Rank: %ld Line=%d MEM %.1lf[%.1lf]MB\n",
        -: 1980:  //                  (long) rank, __LINE__,
        -: 1981:  //                  (double) vmem/1024./1024.,
        -: 1982:  //                  (double) phymem/1024./1024.);
        -: 1983:
    #####: 1984:  for (k=0;k<nnbpix;k++)  {
        -: 1985:    //long imat=the_stat_pix[k];
    #####: 1986:    long ndata = loc_nhpix[k];
    #####: 1987:    hpix *htmp = loc_hpix[k];
    #####: 1988:    II[k]=0;
    #####: 1989:    IQ[k]=0;
    #####: 1990:    IU[k]=0;
    #####: 1991:    QQ[k]=0;
    #####: 1992:    UU[k]=0;
    #####: 1993:    QU[k]=0;
        -: 1994:
        -: 1995:
    #####: 1996:    for (l1=0;l1<ndata;l1++) {
    #####: 1997:      long ri1=htmp[l1].rg-globalBeginRing;
        -: 1998:
    #####: 1999:      double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 2000:                                        -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 2001:      double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 2002:                                        +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 2003:      if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####: 2004:        II[k]+=htmp[l1].w;
    #####: 2005:        IQ[k]+=htmp[l1].w*CO1;
    #####: 2006:        IU[k]+=htmp[l1].w*SI1;
    #####: 2007:        QQ[k]+=htmp[l1].w*CO1*CO1;
    #####: 2008:        QU[k]+=htmp[l1].w*SI1*CO1;
    #####: 2009:        UU[k]+=htmp[l1].w*SI1*SI1;
        -: 2010:      }
        -: 2011:    }
        -: 2012:
    #####: 2013:    if (ndata>0&&flgpix[k]>0) {
        -: 2014:
    #####: 2015:      double SI=0;
    #####: 2016:      double SQ=0;
    #####: 2017:      double SU=0;
        -: 2018:
        -: 2019:#ifdef USEDII
    #####: 2020:      memset(dii ,0,sizeof(double)*nbolo*GAINSTEP);
    #####: 2021:      memset(dqq ,0,sizeof(double)*nbolo*GAINSTEP);
    #####: 2022:      memset(duu ,0,sizeof(double)*nbolo*GAINSTEP);
        -: 2023:#endif
    #####: 2024:      memset(dcoi+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2025:      memset(dcoq+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2026:      memset(dcou+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2027:      memset(dfri+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2028:      memset(dfrq+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2029:      memset(dfru+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2030:      memset(dthetai+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2031:      memset(dthetaq+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2032:      memset(dthetau+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2033:      memset(ddusti+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2034:      memset(ddustq+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2035:      memset(ddustu+k*nbolo,0,sizeof(double)*nbolo);
    #####: 2036:      memset(dpixi+k*nbolo*npixbeam,0,sizeof(double)*nbolo*npixbeam);
    #####: 2037:      memset(dpixq+k*nbolo*npixbeam,0,sizeof(double)*nbolo*npixbeam);
    #####: 2038:      memset(dpixu+k*nbolo*npixbeam,0,sizeof(double)*nbolo*npixbeam);
        -: 2039:
        -: 2040:
    #####: 2041:      for (l1=0;l1<ndata;l1++) {
    #####: 2042:        long ri1=htmp[l1].rg-globalBeginRing;
        -: 2043:
    #####: 2044:        double g1=gaingi[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 2045:
    #####: 2046:        double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 2047:                                          -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 2048:        double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 2049:                                          +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 2050:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 2051:
    #####: 2052:          htmp[l1].wp=0;
        -: 2053:          //htmp[l1].thsig=0;
        -: 2054:
    #####: 2055:          if (Param->REMHDIP==0) {
    #####: 2056:            SI+=htmp[l1].w*(htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].dip-htmp[l1].corr_nl-htmp[l1].corr_cnn);
    #####: 2057:            SQ+=htmp[l1].w*(htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].dip-htmp[l1].corr_nl-htmp[l1].corr_cnn)*CO1;
    #####: 2058:            SU+=htmp[l1].w*(htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].dip-htmp[l1].corr_nl-htmp[l1].corr_cnn)*SI1;
        -: 2059:          }
        -: 2060:          else {
    #####: 2061:            SI+=htmp[l1].w*(htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].freefree-htmp[l1].corr_nl-htmp[l1].corr_cnn);
    #####: 2062:            SQ+=htmp[l1].w*(htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].freefree-htmp[l1].corr_nl-htmp[l1].corr_cnn)*CO1;
    #####: 2063:            SU+=htmp[l1].w*(htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].freefree-htmp[l1].corr_nl-htmp[l1].corr_cnn)*SI1;
        -: 2064:          }
        -: 2065:
        -: 2066:#ifdef USEDII
    #####: 2067:          dii[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model;
    #####: 2068:          dqq[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model*CO1;
    #####: 2069:          duu[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model*SI1;
        -: 2070:
        -: 2071:#endif
        -: 2072:
    #####: 2073:          if (nmatco>0) {
    #####: 2074:            dcoi[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].comap;
    #####: 2075:            dcoq[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].comap*CO1;
    #####: 2076:            dcou[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].comap*SI1;
        -: 2077:          }
    #####: 2078:          if (nmatdust>0) {
    #####: 2079:            ddusti[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].dustmap;
    #####: 2080:            ddustq[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].dustmap*CO1;
    #####: 2081:            ddustu[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].dustmap*SI1;
        -: 2082:          }
    #####: 2083:          if (nfreefree>0) {
    #####: 2084:            dfri[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].freefree;
    #####: 2085:            dfrq[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].freefree*CO1;
    #####: 2086:            dfru[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].freefree*SI1;
        -: 2087:          }
        -: 2088:
    #####: 2089:          if (ittt>0) {
    #####: 2090:            for (m=0;m<npixbeam;m++)  {
    #####: 2091:              dpixi[nbolo*m+htmp[l1].ib+k*nbolo*npixbeam] += htmp[l1].w*htmp[l1].listofpix[m];
    #####: 2092:              dpixq[nbolo*m+htmp[l1].ib+k*nbolo*npixbeam] += htmp[l1].w*htmp[l1].listofpix[m]*CO1;
    #####: 2093:              dpixu[nbolo*m+htmp[l1].ib+k*nbolo*npixbeam] += htmp[l1].w*htmp[l1].listofpix[m]*SI1;
        -: 2094:            }
        -: 2095:          }
        -: 2096:        }
        -: 2097:      }
        -: 2098:
    #####: 2099:      solvemap(&SI,&SQ,&SU,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
    #####: 2100:      SSI[k]=SI;
    #####: 2101:      SSQ[k]=SQ;
    #####: 2102:      SSU[k]=SU;
        -: 2103:
    #####: 2104:      for (ib=0;ib<nbolo;ib++) {
        -: 2105:
        -: 2106:#ifdef USEDII
    #####: 2107:        for (j=0;j<GAINSTEP;j++) {
    #####: 2108:          solvemap(dii+j+ib*GAINSTEP,dqq+j+ib*GAINSTEP,duu+j+ib*GAINSTEP,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
        -: 2109:
        -: 2110:        }
        -: 2111:#endif
        -: 2112:
    #####: 2113:        if (nmatco>0) {
    #####: 2114:          solvemap(dcoi+ib+k*nbolo,dcoq+ib+k*nbolo,dcou+ib+k*nbolo,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
        -: 2115:        }
    #####: 2116:        if (nmatdust>0) {
    #####: 2117:          solvemap(ddusti+ib+k*nbolo,ddustq+ib+k*nbolo,ddustu+ib+k*nbolo,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
        -: 2118:        }
    #####: 2119:        if (nfreefree>0) {
    #####: 2120:          solvemap(dfri+ib+k*nbolo,dfrq+ib+k*nbolo,dfru+ib+k*nbolo,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
        -: 2121:        }
        -: 2122:
    #####: 2123:        if (ittt>0) {
    #####: 2124:          for (m=0;m<npixbeam;m++)  {
    #####: 2125:            solvemap(dpixi+ib+m*nbolo+k*nbolo*npixbeam,
    #####: 2126:                     dpixq+ib+m*nbolo+k*nbolo*npixbeam,
    #####: 2127:                     dpixu+ib+m*nbolo+k*nbolo*npixbeam,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
        -: 2128:          }
        -: 2129:        }
        -: 2130:      }
    #####: 2131:      for (l1=0;l1<ndata;l1++) {
    #####: 2132:	htmp[l1].vi=UNSEENPIX;
    #####: 2133:        long ri1=htmp[l1].rg-globalBeginRing;
        -: 2134:
    #####: 2135:        double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 2136:                                          -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 2137:        double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 2138:                                          +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 2139:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####: 2140:          double li=htmp[l1].w,lco=CO1*htmp[l1].w,lsi=SI1*htmp[l1].w;
    #####: 2141:          solvemap(&li,&lco,&lsi,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
    #####: 2142:          htmp[l1].vi=li;
    #####: 2143:          htmp[l1].vq=lco;
    #####: 2144:          htmp[l1].vu=lsi;
        -: 2145:#ifndef USEDII
        -: 2146:          li=htmp[l1].w*htmp[l1].model;
        -: 2147:          lco=CO1*htmp[l1].w*htmp[l1].model;
        -: 2148:          lsi=SI1*htmp[l1].w*htmp[l1].model;
        -: 2149:
        -: 2150:          solvemap(&li,&lco,&lsi,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
        -: 2151:          htmp[l1].lvi=li;
        -: 2152:          htmp[l1].lvq=lco;
        -: 2153:          htmp[l1].lvu=lsi;
        -: 2154:#endif
        -: 2155:        }
        -: 2156:      }
    #####: 2157:      for (l1=0;l1<ndata;l1++) {
    #####: 2158:        long ri1=htmp[l1].rg-globalBeginRing;
        -: 2159:
    #####: 2160:        double g1=gaingi[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 2161:
    #####: 2162:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####: 2163:          double divi=NEP_tab[htmp[l1].ib]*htmp[l1].hit*g1;
    #####: 2164:          divi=divi*divi;
        -: 2165:
    #####: 2166:          if (divi==0) htmp[l1].wp=0;
    #####: 2167:          else htmp[l1].wp=1/divi;
        -: 2168:
    #####: 2169:          if (itbogo==0) normaoff+=NEP_tab[htmp[l1].ib]*htmp[l1].hit;
        -: 2170:
        -: 2171:        }
        -: 2172:      }
        -: 2173:
    #####: 2174:      for (l1=0;l1<ndata;l1++) {
    #####: 2175:        long ri1=htmp[l1].rg-globalBeginRing;
    #####: 2176:        long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
        -: 2177:
    #####: 2178:        double g1=gaingi[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 2179:
    #####: 2180:        double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 2181:                                          -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 2182:        double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 2183:                                          +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 2184:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####: 2185:          double ww=htmp[l1].wp;
        -: 2186:          double tmp;
    #####: 2187:          if (REMHDIP==0) {
    #####: 2188:            tmp=((htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].dip-htmp[l1].corr_nl-htmp[l1].corr_cnn)-(SI+CO1*SQ+SI1*SU));
        -: 2189:          }
        -: 2190:          else {
    #####: 2191:            tmp=((htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].freefree-htmp[l1].corr_nl-htmp[l1].corr_cnn)-(SI+CO1*SQ+SI1*SU));
        -: 2192:          }
        -: 2193:
        -: 2194:          long l3;
        -: 2195:#ifndef USEDII
        -: 2196:          memset(cdip,0,GAINSTEP*nbolo*sizeof(double));
        -: 2197:#endif
        -: 2198:
    #####: 2199:          for (l3=0;l3<ndata;l3++) {
    #####: 2200:            long ri3=htmp[l3].rg-globalBeginRing;
    #####: 2201:            if (flg_rg[htmp[l3].ib][ri3]!=0) {
    #####: 2202:              long ir3=rgord[htmp[l3].ib][ri3]+newnr[htmp[l3].ib];
    #####: 2203:              ctmp[ir3]=-(htmp[l3].vi+CO1*htmp[l3].vq+SI1*htmp[l3].vu);
        -: 2204:#ifndef USEDII
        -: 2205:              cdip[htmp[l3].ib*GAINSTEP+htmp[l3].gi]-=(htmp[l3].lvi+CO1*htmp[l3].lvq+SI1*htmp[l3].lvu);
        -: 2206:#endif
        -: 2207:            }
        -: 2208:          }
    #####: 2209:          ctmp[iri1]+=1;
        -: 2210:
        -: 2211:#ifdef USEDII
    #####: 2212:          for (ib=0;ib<nbolo;ib++)
    #####: 2213:            for (j=0;j<GAINSTEP;j++) {
    #####: 2214:              cdip[ib*GAINSTEP+j]=-(dii[j+ib*GAINSTEP]+CO1*dqq[j+ib*GAINSTEP]+SI1*duu[j+ib*GAINSTEP]);
        -: 2215:	    }
        -: 2216:#endif
    #####: 2217:          cdip[htmp[l1].ib*GAINSTEP+htmp[l1].gi]+=htmp[l1].model;
        -: 2218:
    #####: 2219:          for (ib=0;ib<nbolo;ib++) cco[ib]=-(dcoi[ib+k*nbolo]+CO1*dcoq[ib+k*nbolo]+SI1*dcou[ib+k*nbolo]);
    #####: 2220:          cco[htmp[l1].ib]+=htmp[l1].comap;
        -: 2221:
    #####: 2222:          for (ib=0;ib<nbolo;ib++) cdust[ib]=-(ddusti[ib+k*nbolo]+CO1*ddustq[ib+k*nbolo]+SI1*ddustu[ib+k*nbolo]);
    #####: 2223:          cdust[htmp[l1].ib]+=htmp[l1].dustmap;
        -: 2224:
    #####: 2225:          for (ib=0;ib<nbolo;ib++) ccfree[ib]=-(dfri[ib+k*nbolo]+CO1*dfrq[ib+k*nbolo]+SI1*dfru[ib+k*nbolo]);
    #####: 2226:          ccfree[htmp[l1].ib]+=htmp[l1].freefree;
        -: 2227:
    #####: 2228:          for (m=0;m<npixbeam;m++) {
    #####: 2229:            for (ib=0;ib<nbolo;ib++) cpix[ib+m*nbolo]=-(dpixi[ib+m*nbolo+k*nbolo*npixbeam]
    #####: 2230:                                                        +CO1*dpixq[ib+m*nbolo+k*nbolo*npixbeam]
    #####: 2231:                                                        +SI1*dpixu[ib+m*nbolo+k*nbolo*npixbeam]);
    #####: 2232:            cpix[htmp[l1].ib+m*nbolo]+=htmp[l1].listofpix[m];
        -: 2233:          }
        -: 2234:          long ir;
        -: 2235:          /////////////////  OFFSET
        -: 2236:
    #####: 2237:          for (l2=0;l2<ndata;l2++) {
    #####: 2238:            long ri2=htmp[l2].rg-globalBeginRing;
    #####: 2239:            if (flg_rg[htmp[l2].ib][ri2]!=0) {
    #####: 2240:              long ir=rgord[htmp[l2].ib][ri2]+newnr[htmp[l2].ib];
    #####: 2241:              b2[ir]+=ww*tmp*ctmp[ir];
    #####: 2242:              hit2[ir]+=ww*ctmp[ir]*ctmp[ir];
        -: 2243:#ifndef USEDII
        -: 2244:              b2[newnr[nbolo]+htmp[l2].ib*GAINSTEP+htmp[l2].gi]+=ww*tmp*cdip[htmp[l2].ib*GAINSTEP+htmp[l2].gi];
        -: 2245:              hit2[newnr[nbolo]+htmp[l2].ib*GAINSTEP+htmp[l2].gi]+=ww*cdip[htmp[l2].ib*GAINSTEP+htmp[l2].gi]
        -: 2246:                *cdip[htmp[l2].ib*GAINSTEP+htmp[l2].gi];
        -: 2247:#endif
        -: 2248:            }
        -: 2249:          }
        -: 2250:
        -: 2251:
        -: 2252:          /////////////////  DIPOLE FIT
        -: 2253:
    #####: 2254:          for (ir=0;ir<nbolo;ir++) {
        -: 2255:
        -: 2256:#ifdef USEDII
        -: 2257:
    #####: 2258:            for (j=0;j<GAINSTEP;j++) {
    #####: 2259:              b2[newnr[nbolo]+ir*GAINSTEP+j]+=ww*tmp*cdip[ir*GAINSTEP+j];
    #####: 2260:              hit2[newnr[nbolo]+ir*GAINSTEP+j]+=ww*cdip[ir*GAINSTEP+j]*cdip[ir*GAINSTEP+j];
        -: 2261:            }
        -: 2262:
        -: 2263:#endif
        -: 2264:
        -: 2265:            ///////////// CO
    #####: 2266:            if (nmatco>0) {
    #####: 2267:              b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ir]+=ww*tmp*cco[ir];
    #####: 2268:              hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ir]+=ww*cco[ir]*cco[ir];
        -: 2269:            }
        -: 2270:
        -: 2271:            ///////////// DUST
        -: 2272:
    #####: 2273:            if (nmatdust>0) {
    #####: 2274:              b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ir]+=ww*tmp*cdust[ir];
    #####: 2275:              hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ir]+=ww*cdust[ir]*cdust[ir];
        -: 2276:            }
        -: 2277:
        -: 2278:            ///////////// FREEFREE
        -: 2279:
    #####: 2280:            if (nfreefree>0) {
    #####: 2281:              b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ir]+=ww*tmp*ccfree[ir];
    #####: 2282:              hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ir]+=ww*ccfree[ir]*ccfree[ir];
        -: 2283:            }
        -: 2284:
        -: 2285:            ////////// PIXBEAM
    #####: 2286:            for (j=0;j<npixbeam;j++) {
    #####: 2287:              b2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+ir]+=ww*tmp*cpix[ir+j*nbolo];
    #####: 2288:              hit2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+ir]+=ww*cpix[ir+j*nbolo]*cpix[ir+j*nbolo];
        -: 2289:            }
        -: 2290:          }
        -: 2291:        }
        -: 2292:      }
        -: 2293:    }
        -: 2294:  }
        -: 2295:
        -: 2296:#ifdef OPTIMPI
        -: 2297:  {
    #####: 2298:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
    #####: 2299:    MPI_Reduce(b2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 2300:
    #####: 2301:    memcpy(b2,lb,sizeof(double)*(nmatres));
    #####: 2302:    free(lb);
        -: 2303:  }
        -: 2304:#else
        -: 2305:  if (rank==0) {
        -: 2306:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 2307:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 2308:      MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
        -: 2309:      for (l=0;l<nmatres;l++) b2[l]+=lb[l];
        -: 2310:    }
        -: 2311:    free(lb);
        -: 2312:
        -: 2313:  }
        -: 2314:  else MPI_Send(b2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1031, MPI_COMM_WORLD);
        -: 2315: #endif
        -: 2316:
        -: 2317:
        -: 2318:#ifdef OPTIMPI
        -: 2319:  {
    #####: 2320:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
    #####: 2321:    MPI_Reduce(hit2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 2322:
    #####: 2323:    memcpy(hit2,lb,sizeof(double)*(nmatres));
    #####: 2324:    free(lb);
        -: 2325:  }
        -: 2326:#else
        -: 2327:  if (rank==0) {
        -: 2328:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 2329:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 2330:      MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1033, MPI_COMM_WORLD,&statu);
        -: 2331:
        -: 2332:      for (l=0;l<nmatres;l++) hit2[l]+=lb[l];
        -: 2333:    }
        -: 2334:    free(lb);
        -: 2335:  }
        -: 2336:  else {
        -: 2337:    MPI_Send(hit2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1033, MPI_COMM_WORLD);
        -: 2338:  }
        -: 2339:#endif
        -: 2340:
        -: 2341:
        -: 2342:  //==========================================================
        -: 2343:  // Compute Ax
        -: 2344:  //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, x, q);
        -: 2345:  // +
        -: 2346:  // Preconditionnement
        -: 2347:  //
        -: 2348:  //
        -: 2349:
    #####: 2350:  for (l=0;l<nmatres;l++) q2[l]=0;
    #####: 2351:  if (rank==0) {
        -: 2352:
    #####: 2353:    double soff=0;
    #####: 2354:    for (i=0;i<newnr[nbolo];i++) soff+=hit2[0]*ix2[i];
    #####: 2355:    for (i=0;i<newnr[nbolo];i++) q2[i]=soff;
        -: 2356:
    #####: 2357:    if (Param->REMHDIP==1) {
    #####: 2358:      soff=0;
    #####: 2359:      for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) soff+=hit2[newnr[nbolo]]*ix2[i];
    #####: 2360:      for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) q2[i]=soff;
        -: 2361:    }
        -: 2362:
    #####: 2363:    if (Param->flag_AVGR0==_PAR_TRUE) {
    #####: 2364:      soff=0;
    #####: 2365:      for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2)]*
    #####: 2366:                              ix2[newnr[nbolo]+nbolo*(GAINSTEP2)+i];
    #####: 2367:      for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2)+i]=soff;
    #####: 2368:      for (i=0;i<nbolo;i++) b2[newnr[nbolo]+nbolo*(GAINSTEP2)+i]+=
    #####: 2369:                              hit2[newnr[nbolo]+nbolo*(GAINSTEP2)]*Param->AVGR0;
        -: 2370:
        -: 2371:    }
        -: 2372:
    #####: 2373:    if (nmatco>0) {
    #####: 2374:      soff=0;
    #####: 2375:      if ((singleFreq == 0) && (Param->flag_AVG12CO == _PAR_TRUE)) {
    #####: 2376:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 2377:            soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
    #####: 2378:                    * ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
    #####: 2379:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 2380:            q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i] = soff;
    #####: 2381:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 2382:            b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i] +=
    #####: 2383:            hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)] * Param->AVG12CO;
        -: 2384:      }
        -: 2385:      else {
    #####: 2386:        for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
    #####: 2387:                                *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
    #####: 2388:        for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i]=soff;
    #####: 2389:        for (i=0;i<nbolo;i++) b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i]+=
    #####: 2390:                                hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]*Param->AVG12CO;
        -: 2391:      }
        -: 2392:    }
    #####: 2393:    if (nmatdust>0) {
    #####: 2394:      soff=0;
    #####: 2395:      if ((singleFreq == 0) && (Param->flag_AVGDUST100 == _PAR_TRUE)) {
    #####: 2396:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 2397:            soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]
    #####: 2398:                    * ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
    #####: 2399:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 2400:            q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i] = soff;
    #####: 2401:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 2402:            b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i] +=
    #####: 2403:            hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco] * Param->AVGDUST100;
        -: 2404:      }
        -: 2405:      else {
    #####: 2406:        for (i=0;i<nbolo;i++)
    #####: 2407:          soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]*
    #####: 2408:            ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
    #####: 2409:        for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i]=soff;
    #####: 2410:        for (i=0;i<nbolo;i++) b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i]+=
    #####: 2411:                                hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]*Param->AVGDUST;
        -: 2412:      }
        -: 2413:    }
    #####: 2414:    if (nfreefree>0) {
    #####: 2415:      soff=0;
    #####: 2416:      if ((singleFreq == 0) && (Param->flag_AVGFREEFREE == _PAR_TRUE)) {
    #####: 2417:	for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF)
    #####: 2418:	  soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]*
    #####: 2419:	    ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 2420:	for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF)
    #####: 2421:				q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i]=soff;
    #####: 2422:	for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF)
    #####: 2423:				b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i]+=
    #####: 2424:                                hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]*Param->AVGFREEFREE;
        -: 2425:      }
        -: 2426:      else {
    #####: 2427:	for (i=0;i<nbolo;i++)
    #####: 2428:	  soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]*
    #####: 2429:	    ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 2430:	for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i]=soff;
        -: 2431:      }
        -: 2432:    }
    #####: 2433:    long nj=0;
    #####: 2434:    if (DOFITANGLE==1) nj++;
    #####: 2435:    if (DOFITPOLEFF==1) nj++;
    #####: 2436:    if (DOTDUST==1) nj++;
    #####: 2437:    if (DOCO13==1) nj++;
    #####: 2438:    if (DOSYNCHRO==1) nj++;
        -: 2439:
    #####: 2440:    if (DOFITPOLEFF==1) {
    #####: 2441:      j=1+DOCO13+DOSYNCHRO+DOTDUST;
    #####: 2442:      soff=0;
    #####: 2443:      for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 2444:			      ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 2445:      for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 2446:    }
        -: 2447:
    #####: 2448:    if (DOCO13==1) {
    #####: 2449:      j=1+DOSYNCHRO;
    #####: 2450:      soff=0;
    #####: 2451:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 2452:						   ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 2453:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
    #####: 2454:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) b2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]+=
    #####: 2455:							    hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)] * Param->AVG13CO;
        -: 2456:    }
        -: 2457:
    #####: 2458:    if (DOTDUST==1) {
    #####: 2459:      j=1+DOCO13+DOSYNCHRO;
    #####: 2460:      soff=0;
    #####: 2461:      for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 2462:						       ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 2463:      for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 2464:    }
        -: 2465:
    #####: 2466:    if (DOSYNCHRO==1) {
    #####: 2467:      soff=0;
    #####: 2468:      j=1;
    #####: 2469:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 2470:						 ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 2471:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
    #####: 2472:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC)
    #####: 2473:			      b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2-j)+i]+=
    #####: 2474:                                hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2-j)]*Param->AVGSYNCHRO;
        -: 2475:
        -: 2476:    }
        -: 2477:  }
    #####: 2478:  for (k=0;k<nnbpix;k++) if (flgpix[k]>0) {
        -: 2479:
    #####: 2480:    long ndata = loc_nhpix[k];
    #####: 2481:    if (ndata>0) {
        -: 2482:#ifdef TIMING
        -: 2483:      gettimeofday(&tp1,NULL);
        -: 2484:#endif
    #####: 2485:      hpix *htmp = loc_hpix[k];
        -: 2486:
    #####: 2487:      double vali=0,valq=0,valu=0;
        -: 2488:
        -: 2489:#ifdef USEDII
    #####: 2490:      memset(dii ,0,sizeof(double)*nbolo*GAINSTEP);
    #####: 2491:      memset(dqq ,0,sizeof(double)*nbolo*GAINSTEP);
    #####: 2492:      memset(duu ,0,sizeof(double)*nbolo*GAINSTEP);
        -: 2493:
        -: 2494:
    #####: 2495:      for (l1=0;l1<ndata;l1++) {
    #####: 2496:        long ri1=htmp[l1].rg-globalBeginRing;
    #####: 2497:        double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 2498:                                          -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 2499:        double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 2500:                                          +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 2501:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 2502:
    #####: 2503:          dii[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model;
    #####: 2504:          dqq[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model*CO1;
    #####: 2505:          duu[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model*SI1;
        -: 2506:        }
        -: 2507:      }
        -: 2508:
    #####: 2509:      for (ib=0;ib<nbolo;ib++) {
    #####: 2510:        for (j=0;j<GAINSTEP;j++) {
    #####: 2511:          solvemap(dii+j+ib*GAINSTEP,dqq+j+ib*GAINSTEP,duu+j+ib*GAINSTEP,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
        -: 2512:        }
        -: 2513:      }
        -: 2514:#endif
        -: 2515:
        -: 2516:
        -: 2517:      long l3;
    #####: 2518:      for (l3=0;l3<ndata;l3++) {
    #####: 2519:        long ri3=htmp[l3].rg-globalBeginRing;
    #####: 2520:        if (flg_rg[htmp[l3].ib][ri3]!=0) {
    #####: 2521:          long ir3=rgord[htmp[l3].ib][ri3]+newnr[htmp[l3].ib];
    #####: 2522:          vali+=htmp[l3].vi*ix2[ir3];
    #####: 2523:          valq+=htmp[l3].vq*ix2[ir3];
    #####: 2524:          valu+=htmp[l3].vu*ix2[ir3];
        -: 2525:#ifndef USEDII
        -: 2526:          vali+=htmp[l3].lvi*ix2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 2527:          valq+=htmp[l3].lvq*ix2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 2528:          valu+=htmp[l3].lvu*ix2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 2529:#endif
        -: 2530:        }
        -: 2531:      }
        -: 2532:      //fprintf(stderr,"I0 vali %lg %lg %lg\n",vali,valq,valu);
        -: 2533:
    #####: 2534:      for (ib=0;ib<nbolo;ib++) {
        -: 2535:#ifdef USEDII
    #####: 2536:        for (j=0;j<GAINSTEP;j++) {
    #####: 2537:          vali+=dii[j+ib*GAINSTEP]  *ix2[newnr[nbolo]+ib*GAINSTEP+j];
    #####: 2538:          valq+=dqq[j+ib*GAINSTEP]  *ix2[newnr[nbolo]+ib*GAINSTEP+j];
    #####: 2539:          valu+=duu[j+ib*GAINSTEP]  *ix2[newnr[nbolo]+ib*GAINSTEP+j];
        -: 2540:        }
        -: 2541:        //fprintf(stderr,"I1 vali %lg %lg %lg\n",vali,valq,valu);
        -: 2542:#endif
        -: 2543:
    #####: 2544:        if (nmatco>0) {
    #####: 2545:          vali+=dcoi[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
    #####: 2546:          valq+=dcoq[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
    #####: 2547:          valu+=dcou[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
        -: 2548:        }
    #####: 2549:        if (nmatdust>0) {
    #####: 2550:          vali+=ddusti[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
    #####: 2551:          valq+=ddustq[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
    #####: 2552:          valu+=ddustu[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
        -: 2553:        }
    #####: 2554:        if (nfreefree>0) {
    #####: 2555:          vali+=dfri[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
    #####: 2556:          valq+=dfrq[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
    #####: 2557:          valu+=dfru[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
        -: 2558:        }
        -: 2559:        //fprintf(stderr,"I3 vali %lg %lg %lg : %lg %lg %lg %lg\n",vali,valq,valu,
        -: 2560:        //dfri[ib+k*nbolo],dfrq[ib+k*nbolo],dfru[ib+k*nbolo],
        -: 2561:        //ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib]);
        -: 2562:
    #####: 2563:        for (m=0;m<npixbeam;m++) {
    #####: 2564:          vali+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixi[ib+m*nbolo+k*nbolo*npixbeam];
    #####: 2565:          valq+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixq[ib+m*nbolo+k*nbolo*npixbeam];
    #####: 2566:          valu+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixu[ib+m*nbolo+k*nbolo*npixbeam];
        -: 2567:        }
        -: 2568:
        -: 2569:        //fprintf(stderr,"I4 vali %lg %lg %lg\n",vali,valq,valu);
        -: 2570:      }
    #####: 2571:      double qri=0;
    #####: 2572:      double qrq=0;
    #####: 2573:      double qru=0;
        -: 2574:
    #####: 2575:      for (l1=0;l1<ndata;l1++) {
    #####: 2576:        long ri1=htmp[l1].rg-globalBeginRing;
    #####: 2577:        long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
        -: 2578:
    #####: 2579:        double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 2580:                                          -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 2581:        double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 2582:                                          +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 2583:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####: 2584:          double ww=htmp[l1].wp;
    #####: 2585:          double val2=ix2[iri1]-(vali+CO1*valq+SI1*valu);
        -: 2586:
        -: 2587:          //fprintf(stderr,"I1 val2 %lg %lg %lg\n",val2,ix2[iri1],vali+CO1*valq+SI1*valu);
    #####: 2588:          val2+=ix2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]*htmp[l1].model;
        -: 2589:
        -: 2590:          //fprintf(stderr,"I2 val2 %lg\n",val2);
    #####: 2591:          if (nmatco>0)
    #####: 2592:            val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]*htmp[l1].comap;
    #####: 2593:          if (nmatdust>0)
    #####: 2594:            val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]*htmp[l1].dustmap;
    #####: 2595:          if (nfreefree>0)
    #####: 2596:            val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+htmp[l1].ib]*htmp[l1].freefree;
        -: 2597:
        -: 2598:          //fprintf(stderr,"I3 val2 %lg\n",val2);
    #####: 2599:          for (m=0;m<npixbeam;m++) {
    #####: 2600:            val2+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+htmp[l1].ib+m*nbolo]*htmp[l1].listofpix[m];
        -: 2601:          }
        -: 2602:
        -: 2603:
    #####: 2604:          qri-=ww*val2;
    #####: 2605:          qrq-=ww*val2*CO1;
    #####: 2606:          qru-=ww*val2*SI1;
        -: 2607:
        -: 2608:	//fprintf(stderr,"val2 I4 %lg\n",val2);
    #####: 2609:          q2[iri1]+=ww*val2;
        -: 2610:
    #####: 2611:          q2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]+=ww*val2*htmp[l1].model;
        -: 2612:
        -: 2613:          ///////////// CO
    #####: 2614:          if (nmatco>0) {
    #####: 2615:            q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]+=ww*val2*htmp[l1].comap;
        -: 2616:          }
        -: 2617:
        -: 2618:          ///////////// DUST
    #####: 2619:          if (nmatdust>0) {
    #####: 2620:            q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]+=ww*val2*htmp[l1].dustmap;
        -: 2621:          }
        -: 2622:
        -: 2623:          ///////////// FREEFREE
    #####: 2624:          if (nfreefree>0) {
    #####: 2625:            q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+htmp[l1].ib]+=ww*val2*htmp[l1].freefree;
        -: 2626:          }
        -: 2627:
        -: 2628:          ////////// SYSTE
    #####: 2629:          for (j=0;j<npixbeam;j++) {
    #####: 2630:            q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+htmp[l1].ib]+=ww*val2*htmp[l1].listofpix[j];
        -: 2631:          }
        -: 2632:
        -: 2633:
        -: 2634:        }
        -: 2635:      }
        -: 2636:
        -: 2637:
    #####: 2638:      for (l2=0;l2<ndata;l2++) {
    #####: 2639:        long ri2=htmp[l2].rg-globalBeginRing;
    #####: 2640:        if (flg_rg[htmp[l2].ib][ri2]!=0) {
    #####: 2641:          long ir=rgord[htmp[l2].ib][ri2]+newnr[htmp[l2].ib];
    #####: 2642:          q2[ir]+=qri*htmp[l2].vi+qrq*htmp[l2].vq+qru*htmp[l2].vu;
        -: 2643:#ifndef USEDII
        -: 2644:          q2[newnr[nbolo]+htmp[l2].ib*GAINSTEP+htmp[l2].gi]+=qri*htmp[l2].lvi+qrq*htmp[l2].lvq+qru*htmp[l2].lvu;
        -: 2645:#endif
        -: 2646:        }
        -: 2647:      }
        -: 2648:
        -: 2649:
    #####: 2650:      for (ib=0;ib<nbolo;ib++) {
        -: 2651:
        -: 2652:#ifdef USEDII
    #####: 2653:        for (j=0;j<GAINSTEP;j++) {
    #####: 2654:          q2[newnr[nbolo]+GAINSTEP*ib+j]+=qri*dii[j+ib*GAINSTEP]+qrq*dqq[j+ib*GAINSTEP]+qru*duu[j+ib*GAINSTEP];
        -: 2655:        }
        -: 2656:#endif
        -: 2657:
        -: 2658:        ///////////// CO
    #####: 2659:        if (nmatco>0) {
    #####: 2660:          q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib]+=qri*dcoi[ib+k*nbolo]+qrq*dcoq[ib+k*nbolo]+qru*dcou[ib+k*nbolo];
        -: 2661:        }
        -: 2662:        ///////////// DUST
    #####: 2663:        if (nmatdust>0) {
    #####: 2664:          q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib]+=qri*ddusti[ib+k*nbolo]+qrq*ddustq[ib+k*nbolo]+qru*ddustu[ib+k*nbolo];
        -: 2665:        }
        -: 2666:        ///////////// FREEFREE
    #####: 2667:        if (nfreefree>0) {
    #####: 2668:          q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib]+=qri*dfri[ib+k*nbolo]+qrq*dfrq[ib+k*nbolo]+qru*dfru[ib+k*nbolo];
        -: 2669:        }
        -: 2670:
    #####: 2671:        for (j=0;j<npixbeam;j++) {
    #####: 2672:          q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+ib]+=qri*dpixi[ib+j*nbolo+k*nbolo*npixbeam]+qrq*dpixq[ib+j*nbolo+k*nbolo*npixbeam]+qru*dpixu[ib+j*nbolo+k*nbolo*npixbeam];
        -: 2673:        }
        -: 2674:      }
        -: 2675:    }
        -: 2676:
        -: 2677:#ifdef TIMING
        -: 2678:      gettimeofday(&tp2,NULL);
        -: 2679:      double dt=(double)(tp2.tv_sec-tp1.tv_sec)+(1E-6)*(tp2.tv_usec-tp1.tv_usec);
        -: 2680:      dthit[ndata]+=dt;
        -: 2681:      ndthit[ndata]+=1;
        -: 2682:#endif
        -: 2683:    }
        -: 2684:
        -: 2685:
        -: 2686:#ifdef OPTIMPI
        -: 2687:  {
    #####: 2688:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
    #####: 2689:    MPI_Reduce(q2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 2690:
    #####: 2691:    memcpy(q2,lb,sizeof(double)*(nmatres));
    #####: 2692:    free(lb);
        -: 2693:  }
        -: 2694:#else
        -: 2695:  if (rank==0) {
        -: 2696:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 2697:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 2698:      MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1032, MPI_COMM_WORLD,&statu);
        -: 2699:      for (l=0;l<nmatres;l++) q2[l]+=lb[l];
        -: 2700:    }
        -: 2701:    free(lb);
        -: 2702:  }
        -: 2703:  else {
        -: 2704:    MPI_Send(q2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1032, MPI_COMM_WORLD);
        -: 2705:  }
        -: 2706:#endif
        -: 2707:
    #####: 2708:  if (rank==0) fprintf(stderr,"QQ2 %lg\n",q2[0]);
        -: 2709:
    #####: 2710:  if (rank==0) {
    #####: 2711:    for (i=0; i < nmatres; i++)
        -: 2712:      {
    #####: 2713:        r2[i] = b2[i] - q2[i];
    #####: 2714:        d2[i] = r2[i] / hit2[i];
        -: 2715:      }
        -: 2716:  }
        -: 2717:
    #####: 2718:  double delta_new_tmp = 0.0;
    #####: 2719:  if (rank==0) {
    #####: 2720:    for (i = 0; i < nmatres; i++) {
    #####: 2721:      delta_new_tmp += b2[i] ;
    #####: 2722:      if (isnan(b2[i])) {
    #####: 2723:        fprintf(stderr,"NAN B2 PBS %ld\n",(long) i);
        -: 2724:      }
    #####: 2725:      if (isnan(d2[i])) {
    #####: 2726:        fprintf(stderr,"NAN D2 PBS %ld %lg %lg %lg\n",(long) i,hit2[i],b2[i],q2[i]);
    #####: 2727:	exit(0);
        -: 2728:      }
        -: 2729:    }
        -: 2730:    //fprintf(stderr,"B2 %lg\n",delta_new_tmp);
        -: 2731:
    #####: 2732:    delta_new_tmp = 0.0;
    #####: 2733:    for (i = 0; i < nmatres; i++) {
    #####: 2734:      delta_new_tmp += q2[i] ;
    #####: 2735:      if (isnan(q2[i])) {
    #####: 2736:        fprintf(stderr,"NAN Q2 PBS %ld\n",(long) i);
        -: 2737:      }
        -: 2738:    }
        -: 2739:    //fprintf(stderr,"Q2 %lg\n",delta_new_tmp);
    #####: 2740:    delta_new_tmp = 0.0;
    #####: 2741:    for (i = 0; i < nmatres; i++) {
    #####: 2742:      delta_new_tmp += q2[i]-b2[i] ;
        -: 2743:      //fprintf(stderr,"B2 Q2 B2-Q2 [%ld]: %lg\t%lg\t%lg\n",(long) i,b2[i],q2[i],q2[i]-b2[i]);
        -: 2744:    }
        -: 2745:  }
        -: 2746:
    #####: 2747:  MPI_Barrier(MPI_COMM_WORLD);
    #####: 2748:  delta_new_tmp = 0.0;
    #####: 2749:  if (rank==0) for (i=0; i < nmatres; i++) {
    #####: 2750:    delta_new_tmp += r2[i] * d2[i];
        -: 2751:  }
        -: 2752:
    #####: 2753:  delta_new=0;
    #####: 2754:  for (i=0;i<mpi_size;i++) {
    #####: 2755:    double tmp=delta_new_tmp;
    #####: 2756:    MPI_Bcast(&tmp, sizeof(double), MPI_BYTE, i, MPI_COMM_WORLD);
    #####: 2757:    delta_new+=tmp;
        -: 2758:  }
    #####: 2759:  if (itbogo==0) delta0 = delta_new;
    #####: 2760:  if (rank==0) {
    #####: 2761:    fprintf (stderr, "iter = %d - delta0 = %lg - delta_new = %lg\n", iter, delta0, delta_new);
        -: 2762:  }
    #####: 2763:  int testwrit=0;
        -: 2764:
    #####: 2765:  if (itbogo==0) MPI_Bcast(&normaoff, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
    #####: 2766:  MPI_Bcast(&delta0, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
    #####: 2767:  MPI_Bcast(&delta_new, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 2768:
        -: 2769:
    #####: 2770:  while ((iter < itermax)  && ((delta_new) > delta0*1E-24) && ((delta_new) > 1E-20)) //Param->XI2STOP))
        -: 2771:    {
        -: 2772:      // q <= Ad
        -: 2773:      //if (rank==0&&mindelta>delta_new) {
    #####: 2774:      if (rank==0) {
    #####: 2775:        memcpy(x2old,ix2,nmatres*sizeof(double));
    #####: 2776:        testwrit=1;
        -: 2777:      }
    #####: 2778:      else testwrit=0;
        -: 2779:
        -: 2780:      //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, d, q);
        -: 2781:      //for (i=0;i<mpi_size;i++) {
        -: 2782:      //MPI_Bcast(d+tab_begr[i]*2, sizeof(double)*(tab_edr[i]-tab_begr[i]+1)*2, MPI_BYTE, i, MPI_COMM_WORLD);
        -: 2783:      //}
    #####: 2784:      MPI_Bcast(d2, sizeof(double)*(nmatres), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 2785:
    #####: 2786:      gettimeofday(&tp1,NULL);
        -: 2787:      // ===========================================================================
        -: 2788:      // PROJECTION DE d dans q
        -: 2789:      //
        -: 2790:
    #####: 2791:      for (l=0;l<nmatres;l++) q2[l]=0;
    #####: 2792:      if (rank==0) {
    #####: 2793:        double soff=0;
    #####: 2794:        for (i=0;i<newnr[nbolo];i++) soff+=hit2[0]*d2[i];
    #####: 2795:        for (i=0;i<newnr[nbolo];i++) q2[i]=soff;
        -: 2796:
    #####: 2797:        if (Param->REMHDIP==1) {
    #####: 2798:          soff=0;
    #####: 2799:          for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) soff+=hit2[newnr[nbolo]]*d2[i];
    #####: 2800:          for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) q2[i]=soff;
        -: 2801:        }
        -: 2802:
    #####: 2803:        if (Param->flag_AVGR0==_PAR_TRUE) {
    #####: 2804:          soff=0;
    #####: 2805:          for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2)]*
    #####: 2806:                                  d2[newnr[nbolo]+nbolo*(GAINSTEP2)+i];
    #####: 2807:          for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2)+i]=soff;
        -: 2808:        }
        -: 2809:
    #####: 2810:        if (nmatco>0) {
    #####: 2811:          soff=0;
    #####: 2812:          if ((singleFreq == 0) && (Param->flag_AVG12CO == _PAR_TRUE)) {
    #####: 2813:            for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 2814:                soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
    #####: 2815:                        * d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
    #####: 2816:            for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 2817:                q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i] = soff;
        -: 2818:          }
        -: 2819:          else {
    #####: 2820:            for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
    #####: 2821:                                    *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
    #####: 2822:            for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i]=soff;
        -: 2823:          }
        -: 2824:        }
        -: 2825:
    #####: 2826:        if (nfreefree>0) {
    #####: 2827:          soff=0;
    #####: 2828:	  if ((singleFreq == 0) && (Param->flag_AVGFREEFREE == _PAR_TRUE)) {
    #####: 2829:	    for (i=0;i<nbolo;i++)  if (freqs[i] == Param->AVFFF) soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]
    #####: 2830:				                              *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 2831:	    for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF)  q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i+nmatco+nmatdust]=soff;
        -: 2832:	  }
        -: 2833:	  else {
    #####: 2834:	    for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]
    #####: 2835:				    *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 2836:	    for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i+nmatco+nmatdust]=soff;
        -: 2837:	  }
        -: 2838:	}
        -: 2839:
    #####: 2840:        if (nmatdust>0) {
    #####: 2841:          soff=0;
    #####: 2842:          if ((singleFreq == 0) && (Param->flag_AVGDUST100 == _PAR_TRUE)) {
    #####: 2843:            for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 2844:                soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]
    #####: 2845:                        * d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
    #####: 2846:            for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 2847:                q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i] = soff;
        -: 2848:          }
        -: 2849:          else {
    #####: 2850:            for (i=0;i<nbolo;i++)
    #####: 2851:              soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]*
    #####: 2852:                d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
    #####: 2853:            for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i]=soff;
        -: 2854:          }
        -: 2855:        }
        -: 2856:
    #####: 2857:        long nj=0;
    #####: 2858:        if (DOFITANGLE==1) nj++;
    #####: 2859:        if (DOFITPOLEFF==1) nj++;
    #####: 2860:	if (DOTDUST==1) nj++;
    #####: 2861:        if (DOCO13==1) nj++;
    #####: 2862:	if (DOSYNCHRO==1) nj++;
        -: 2863:
    #####: 2864:	if (DOFITPOLEFF==1) {
    #####: 2865:	  j=1+DOCO13+DOSYNCHRO+DOTDUST;
    #####: 2866:	  soff=0;
    #####: 2867:	  for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 2868:				  d2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 2869:	  for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 2870:	}
        -: 2871:
    #####: 2872:	if (DOCO13==1) {
    #####: 2873:	  j=1+DOSYNCHRO;
    #####: 2874:	  soff=0;
    #####: 2875:	  for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 2876:						       d2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 2877:	  for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 2878:	}
        -: 2879:
    #####: 2880:	if (DOTDUST==1) {
    #####: 2881:	  j=1+DOCO13+DOSYNCHRO;
    #####: 2882:	  soff=0;
    #####: 2883:	  for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 2884:							   d2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 2885:	  for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 2886:	}
        -: 2887:
    #####: 2888:	if (DOSYNCHRO==1) {
    #####: 2889:	    soff=0;
    #####: 2890:	    j=1;
    #####: 2891:	    for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC)  soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 2892:						       d2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 2893:	    for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC)  q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 2894:	}
        -: 2895:      }
    #####: 2896:      for (k=0;k<nnbpix;k++) if (flgpix[k]>0) {
        -: 2897:
        -: 2898:        //long imat=the_stat_pix[k];
    #####: 2899:        long ndata = loc_nhpix[k];
    #####: 2900:        if (ndata>0) {
    #####: 2901:          hpix *htmp = loc_hpix[k];
        -: 2902:
    #####: 2903:          double vali=0,valq=0,valu=0;
        -: 2904:
        -: 2905:#ifdef USEDII
    #####: 2906:          memset(dii ,0,sizeof(double)*nbolo*GAINSTEP);
    #####: 2907:          memset(dqq ,0,sizeof(double)*nbolo*GAINSTEP);
    #####: 2908:          memset(duu ,0,sizeof(double)*nbolo*GAINSTEP);
        -: 2909:
        -: 2910:
    #####: 2911:          for (l1=0;l1<ndata;l1++) {
    #####: 2912:            long ri1=htmp[l1].rg-globalBeginRing;
    #####: 2913:            double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 2914:                                              -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 2915:            double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 2916:                                              +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 2917:            if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 2918:
    #####: 2919:              dii[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model;
    #####: 2920:              dqq[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model*CO1;
    #####: 2921:              duu[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model*SI1;
        -: 2922:            }
        -: 2923:          }
    #####: 2924:          for (ib=0;ib<nbolo;ib++) {
    #####: 2925:            for (j=0;j<GAINSTEP;j++) {
    #####: 2926:              solvemap(dii+j+ib*GAINSTEP,dqq+j+ib*GAINSTEP,duu+j+ib*GAINSTEP,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
        -: 2927:            }
        -: 2928:          }
        -: 2929:#endif
        -: 2930:          long l3;
    #####: 2931:          for (l3=0;l3<ndata;l3++) {
    #####: 2932:            long ri3=htmp[l3].rg-globalBeginRing;
    #####: 2933:            if (flg_rg[htmp[l3].ib][ri3]!=0) {
    #####: 2934:              long ir3=rgord[htmp[l3].ib][ri3]+newnr[htmp[l3].ib];
    #####: 2935:              vali+=htmp[l3].vi*d2[ir3];
    #####: 2936:              valq+=htmp[l3].vq*d2[ir3];
    #####: 2937:              valu+=htmp[l3].vu*d2[ir3];
        -: 2938:#ifndef USEDII
        -: 2939:              vali+=htmp[l3].lvi*d2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 2940:              valq+=htmp[l3].lvq*d2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 2941:              valu+=htmp[l3].lvu*d2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 2942:#endif
        -: 2943:            }
        -: 2944:          }
    #####: 2945:          for (ib=0;ib<nbolo;ib++) {
        -: 2946:
        -: 2947:
        -: 2948:#ifdef USEDII
    #####: 2949:            for (j=0;j<GAINSTEP;j++) {
    #####: 2950:              vali+=dii[j+ib*GAINSTEP]  *d2[newnr[nbolo]+ib*GAINSTEP+j];
    #####: 2951:              valq+=dqq[j+ib*GAINSTEP]  *d2[newnr[nbolo]+ib*GAINSTEP+j];
    #####: 2952:              valu+=duu[j+ib*GAINSTEP]  *d2[newnr[nbolo]+ib*GAINSTEP+j];
        -: 2953:            }
        -: 2954:#endif
        -: 2955:
    #####: 2956:            if (nmatco>0) {
    #####: 2957:              vali+=dcoi[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
    #####: 2958:              valq+=dcoq[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
    #####: 2959:              valu+=dcou[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
        -: 2960:            }
    #####: 2961:            if (nmatdust>0) {
    #####: 2962:              vali+=ddusti[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
    #####: 2963:              valq+=ddustq[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
    #####: 2964:              valu+=ddustu[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
        -: 2965:            }
    #####: 2966:            if (nfreefree>0) {
    #####: 2967:              vali+=dfri[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
    #####: 2968:              valq+=dfrq[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
    #####: 2969:              valu+=dfru[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
        -: 2970:            }
    #####: 2971:            for (m=0;m<npixbeam;m++) {
    #####: 2972:              vali+=d2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixi[ib+m*nbolo+k*nbolo*npixbeam];
    #####: 2973:              valq+=d2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixq[ib+m*nbolo+k*nbolo*npixbeam];
    #####: 2974:              valu+=d2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixu[ib+m*nbolo+k*nbolo*npixbeam];
        -: 2975:            }
        -: 2976:          }
        -: 2977:
    #####: 2978:          double qri=0;
    #####: 2979:          double qrq=0;
    #####: 2980:          double qru=0;
        -: 2981:
    #####: 2982:          for (l1=0;l1<ndata;l1++) {
    #####: 2983:            long ri1=htmp[l1].rg-globalBeginRing;
    #####: 2984:            long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
        -: 2985:
    #####: 2986:            double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 2987:                                              -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 2988:            double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 2989:                                              +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 2990:            if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####: 2991:              double ww=htmp[l1].wp;
    #####: 2992:              double val2=d2[iri1]-(vali+CO1*valq+SI1*valu);
        -: 2993:
    #####: 2994:              val2+=d2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]*htmp[l1].model;
    #####: 2995:              if (nmatco>0)
    #####: 2996:                val2+=d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]*htmp[l1].comap;
    #####: 2997:              if (nmatdust>0)
    #####: 2998:                val2+=d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]*htmp[l1].dustmap;
    #####: 2999:              if (nfreefree>0)
    #####: 3000:                val2+=d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+htmp[l1].ib]*htmp[l1].freefree;
        -: 3001:
    #####: 3002:              for (m=0;m<npixbeam;m++) {
    #####: 3003:                val2+=d2[newnr[nbolo]+nbolo*GAINSTEP2+htmp[l1].ib+m*nbolo]*htmp[l1].listofpix[m];
        -: 3004:              }
        -: 3005:
        -: 3006:
    #####: 3007:              qri-=ww*val2;
    #####: 3008:              qrq-=ww*val2*CO1;
    #####: 3009:              qru-=ww*val2*SI1;
        -: 3010:
    #####: 3011:              q2[iri1]+=ww*val2;
        -: 3012:
    #####: 3013:              q2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]+=ww*val2*htmp[l1].model;
        -: 3014:
        -: 3015:              ///////////// CO
    #####: 3016:              if (nmatco>0) {
    #####: 3017:                q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]+=ww*val2*htmp[l1].comap;
        -: 3018:              }
        -: 3019:
        -: 3020:              ///////////// DUST
    #####: 3021:              if (nmatdust>0) {
    #####: 3022:                q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]+=ww*val2*htmp[l1].dustmap;
        -: 3023:              }
        -: 3024:
        -: 3025:              ///////////// FREEFREE
    #####: 3026:              if (nfreefree>0) {
    #####: 3027:                q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+htmp[l1].ib]+=ww*val2*htmp[l1].freefree;
        -: 3028:              }
        -: 3029:
        -: 3030:
    #####: 3031:              for (j=0;j<npixbeam;j++) {
    #####: 3032:                q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+htmp[l1].ib]+=ww*val2*htmp[l1].listofpix[j];
        -: 3033:              }
        -: 3034:
        -: 3035:            }
        -: 3036:          }
        -: 3037:
        -: 3038:
    #####: 3039:          for (l2=0;l2<ndata;l2++) {
    #####: 3040:            long ri2=htmp[l2].rg-globalBeginRing;
    #####: 3041:            if (flg_rg[htmp[l2].ib][ri2]!=0) {
    #####: 3042:              long ir=rgord[htmp[l2].ib][ri2]+newnr[htmp[l2].ib];
    #####: 3043:              q2[ir]+=qri*htmp[l2].vi+qrq*htmp[l2].vq+qru*htmp[l2].vu;
        -: 3044:#ifndef USEDII
        -: 3045:              q2[newnr[nbolo]+htmp[l2].ib*GAINSTEP+htmp[l2].gi]+=qri*htmp[l2].lvi+qrq*htmp[l2].lvq+qru*htmp[l2].lvu;
        -: 3046:#endif
        -: 3047:            }
        -: 3048:          }
        -: 3049:
    #####: 3050:          for (ib=0;ib<nbolo;ib++) {
        -: 3051:
        -: 3052:
        -: 3053:#ifdef USEDII
    #####: 3054:            for (j=0;j<GAINSTEP;j++) {
    #####: 3055:              q2[newnr[nbolo]+GAINSTEP*ib+j]+=qri*dii[j+ib*GAINSTEP]+qrq*dqq[j+ib*GAINSTEP]+qru*duu[j+ib*GAINSTEP];
        -: 3056:            }
        -: 3057:#endif
        -: 3058:
        -: 3059:            ///////////// CO
    #####: 3060:            if (nmatco>0) {
    #####: 3061:              q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib]+=qri*dcoi[ib+k*nbolo]+qrq*dcoq[ib+k*nbolo]+qru*dcou[ib+k*nbolo];
        -: 3062:            }
        -: 3063:            ///////////// DUST
    #####: 3064:            if (nmatdust>0) {
    #####: 3065:              q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib]+=qri*ddusti[ib+k*nbolo]+qrq*ddustq[ib+k*nbolo]+qru*ddustu[ib+k*nbolo];
        -: 3066:            }
        -: 3067:            ///////////// FREEFREE
    #####: 3068:            if (nfreefree>0) {
    #####: 3069:              q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib]+=qri*dfri[ib+k*nbolo]+qrq*dfrq[ib+k*nbolo]+qru*dfru[ib+k*nbolo];
        -: 3070:            }
        -: 3071:
    #####: 3072:            for (j=0;j<npixbeam;j++) {
    #####: 3073:              q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+ib]+=qri*dpixi[ib+j*nbolo+k*nbolo*npixbeam]+qrq*dpixq[ib+j*nbolo+k*nbolo*npixbeam]+qru*dpixu[ib+j*nbolo+k*nbolo*npixbeam];
        -: 3074:            }
        -: 3075:          }
        -: 3076:        }
        -: 3077:      }
        -: 3078:
        -: 3079:
        -: 3080:#ifdef OPTIMPI
        -: 3081:      {
    #####: 3082:	double *lb = (double *) malloc(sizeof(double)*(nmatres));
    #####: 3083:	MPI_Reduce(q2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 3084:
    #####: 3085:	memcpy(q2,lb,sizeof(double)*(nmatres));
    #####: 3086:	free(lb);
        -: 3087:      }
        -: 3088:#else
        -: 3089:      if (rank==0) {
        -: 3090:        double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 3091:        for (rrk=1;rrk<mpi_size;rrk++) {
        -: 3092:          MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1034, MPI_COMM_WORLD,&statu);
        -: 3093:          for (l=0;l<nmatres;l++) q2[l]+=lb[l];
        -: 3094:        }
        -: 3095:        free(lb);
        -: 3096:      }
        -: 3097:      else {
        -: 3098:        MPI_Send(q2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1034, MPI_COMM_WORLD);
        -: 3099:      }
        -: 3100:#endif
        -: 3101:
    #####: 3102:      double dtq = 0.0;
    #####: 3103:      if (rank==0) {
    #####: 3104:        for (i=0; i < nmatres; i++) dtq += d2[i] * q2[i];
    #####: 3105:        alpha = delta_new / dtq;
    #####: 3106:        for (i=0; i < nmatres ; i++) ix2[i] += alpha * d2[i];
        -: 3107:      }
        -: 3108:
        -: 3109:
    #####: 3110:      gettimeofday(&tp2,NULL);
    #####: 3111:      if ((Param->verbose > 0) || (iter%10 == 9)) {
    #####: 3112:        if (rank==0) {
    #####: 3113:          fprintf (stderr,"iter = %ld-%d - delta_new = %.3lg %ld %.3lfs\n", itbogo, iter, delta_new,
    #####: 3114:                          (long) testwrit,(double)(tp2.tv_sec-tp1.tv_sec)+(1E-6)*(tp2.tv_usec-tp1.tv_usec));
        -: 3115:	}
        -: 3116:      }
        -: 3117:
        -: 3118:      //if (rank==0) fprintf (stderr,".");
    #####: 3119:      gettimeofday(&tp1,NULL);
        -: 3120:
    #####: 3121:      if (iter % 100 == 0 && iter !=0)
        -: 3122:        {
        -: 3123:          // Use the best case
    #####: 3124:          memcpy(ix2,x2old,nmatres*sizeof(double));
        -: 3125:          //for (i=0;i<mpi_size;i++) {
        -: 3126:          //  MPI_Bcast(x+tab_begr[i]*2, sizeof(double)*(tab_edr[i]-tab_begr[i]+1)*2, MPI_BYTE, i, MPI_COMM_WORLD);
        -: 3127:          //}
    #####: 3128:          MPI_Bcast(ix2, sizeof(double)*(nmatres), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 3129:
        -: 3130:
        -: 3131:      // ===========================================================================
        -: 3132:      // PROJECTION DE x dans q
        -: 3133:      //
        -: 3134:
    #####: 3135:          for (l=0;l<nmatres;l++) q2[l]=0;
    #####: 3136:          if (rank==0) {
    #####: 3137:            double soff=0;
    #####: 3138:            for (i=0;i<newnr[nbolo];i++) soff+=hit2[0]*ix2[i];
    #####: 3139:            for (i=0;i<newnr[nbolo];i++) q2[i]=soff;
        -: 3140:
    #####: 3141:            if (Param->REMHDIP==1) {
    #####: 3142:              soff=0;
    #####: 3143:              for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) soff+=hit2[newnr[nbolo]]*ix2[i];
    #####: 3144:              for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) q2[i]=soff;
        -: 3145:            }
        -: 3146:
    #####: 3147:            if (Param->flag_AVGR0==_PAR_TRUE) {
    #####: 3148:              soff=0;
    #####: 3149:              for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2)]*
    #####: 3150:                                      ix2[newnr[nbolo]+nbolo*(GAINSTEP2)+i];
    #####: 3151:              for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2)+i]=soff;
        -: 3152:            }
        -: 3153:
    #####: 3154:            if (nmatco>0) {
    #####: 3155:              soff=0;
    #####: 3156:              if ((singleFreq == 0) && (Param->flag_AVG12CO == _PAR_TRUE)) {
    #####: 3157:                for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 3158:                    soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
    #####: 3159:                            * ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
    #####: 3160:                for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 3161:                    q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i] = soff;
        -: 3162:              }
        -: 3163:              else {
    #####: 3164:                for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
    #####: 3165:                                        *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
    #####: 3166:                for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i]=soff;
        -: 3167:              }
        -: 3168:            }
        -: 3169:
    #####: 3170:            if (nmatdust>0) {
    #####: 3171:              soff=0;
    #####: 3172:              if ((singleFreq == 0) && (Param->flag_AVGDUST100 == _PAR_TRUE)) {
    #####: 3173:                for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 3174:                  soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]
    #####: 3175:                          * ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
    #####: 3176:                for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 3177:                  q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i] = soff;
        -: 3178:              }
        -: 3179:              else {
    #####: 3180:                for (i=0;i<nbolo;i++)
    #####: 3181:                  soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]*
    #####: 3182:                    ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
    #####: 3183:                for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i]=soff;
        -: 3184:              }
        -: 3185:            }
        -: 3186:
    #####: 3187:            if (nfreefree>0) {
    #####: 3188:              soff=0;
    #####: 3189:	      if ((singleFreq == 0) && (Param->flag_AVGFREEFREE == _PAR_TRUE)) {
    #####: 3190:		for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF)
    #####: 3191:		  soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]*
    #####: 3192:		    ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 3193:		for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i]=soff;
        -: 3194:	      }
        -: 3195:	      else  {
    #####: 3196:		for (i=0;i<nbolo;i++)
    #####: 3197:		  soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]*
    #####: 3198:		    ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 3199:		for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i]=soff;
        -: 3200:	      }
        -: 3201:	    }
        -: 3202:
    #####: 3203:            long nj=0;
    #####: 3204:            if (DOFITANGLE==1) nj++;
    #####: 3205:            if (DOFITPOLEFF==1) nj++;
    #####: 3206:	    if (DOTDUST==1) nj++;
    #####: 3207:            if (DOCO13==1) nj++;
    #####: 3208:	    if (DOSYNCHRO==1) nj++;
        -: 3209:
    #####: 3210:	    if (DOFITPOLEFF==1) {
    #####: 3211:	      j=1+DOCO13+DOSYNCHRO+DOTDUST;
    #####: 3212:	      soff=0;
    #####: 3213:	      for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 3214:				      ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 3215:	      for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 3216:	    }
    #####: 3217:	    if (DOCO13==1) {
    #####: 3218:	      j=1+DOSYNCHRO;
    #####: 3219:	      soff=0;
    #####: 3220:	      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 3221:							   ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 3222:	      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 3223:	    }
        -: 3224:
    #####: 3225:	    if (DOTDUST==1) {
    #####: 3226:	      j=1+DOCO13+DOSYNCHRO;
    #####: 3227:	      soff=0;
    #####: 3228:	      for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 3229:							       ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 3230:	      for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 3231:	    }
        -: 3232:
    #####: 3233:	    if (DOSYNCHRO==1) {
    #####: 3234:	      soff=0;
    #####: 3235:	      j=1;
    #####: 3236:	      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC)  soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 3237:							 ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 3238:	      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC)  q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 3239:
        -: 3240:	    }
        -: 3241:          }
        -: 3242:
    #####: 3243:          for (k=0;k<nnbpix;k++) if (flgpix[k]>0) {
        -: 3244:
        -: 3245:            //long imat=the_stat_pix[k];
    #####: 3246:            long ndata = loc_nhpix[k];
    #####: 3247:            if (ndata>0) {
    #####: 3248:              hpix *htmp = loc_hpix[k];
        -: 3249:
    #####: 3250:              double vali=0,valq=0,valu=0;
        -: 3251:
        -: 3252:#ifdef USEDII
    #####: 3253:              memset(dii ,0,sizeof(double)*nbolo*GAINSTEP);
    #####: 3254:              memset(dqq ,0,sizeof(double)*nbolo*GAINSTEP);
    #####: 3255:              memset(duu ,0,sizeof(double)*nbolo*GAINSTEP);
        -: 3256:
    #####: 3257:              for (l1=0;l1<ndata;l1++) {
    #####: 3258:                long ri1=htmp[l1].rg-globalBeginRing;
    #####: 3259:                double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 3260:                                                  -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 3261:                double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 3262:                                                  +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 3263:                if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 3264:
    #####: 3265:                  dii[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model;
    #####: 3266:                  dqq[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model*CO1;
    #####: 3267:                  duu[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].model*SI1;
        -: 3268:                }
        -: 3269:              }
    #####: 3270:              for (ib=0;ib<nbolo;ib++) {
    #####: 3271:                for (j=0;j<GAINSTEP;j++) {
    #####: 3272:                  solvemap(dii+j+ib*GAINSTEP,dqq+j+ib*GAINSTEP,duu+j+ib*GAINSTEP,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
        -: 3273:                }
        -: 3274:              }
        -: 3275:#endif
        -: 3276:              long l3;
    #####: 3277:              for (l3=0;l3<ndata;l3++) {
    #####: 3278:                long ri3=htmp[l3].rg-globalBeginRing;
    #####: 3279:                if (flg_rg[htmp[l3].ib][ri3]!=0) {
    #####: 3280:                  long ir3=rgord[htmp[l3].ib][ri3]+newnr[htmp[l3].ib];
    #####: 3281:                  vali+=htmp[l3].vi*ix2[ir3];
    #####: 3282:                  valq+=htmp[l3].vq*ix2[ir3];
    #####: 3283:                  valu+=htmp[l3].vu*ix2[ir3];
        -: 3284:#ifndef USEDII
        -: 3285:                  vali+=htmp[l3].lvi*ix2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 3286:                  valq+=htmp[l3].lvq*ix2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 3287:                  valu+=htmp[l3].lvu*ix2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 3288:#endif
        -: 3289:                }
        -: 3290:              }
        -: 3291:
    #####: 3292:              for (ib=0;ib<nbolo;ib++) {
        -: 3293:
        -: 3294:
        -: 3295:#ifdef USEDII
    #####: 3296:                for (j=0;j<GAINSTEP;j++) {
    #####: 3297:                  vali+=dii[j+ib*GAINSTEP]  *ix2[newnr[nbolo]+ib*GAINSTEP+j];
    #####: 3298:                  valq+=dqq[j+ib*GAINSTEP]  *ix2[newnr[nbolo]+ib*GAINSTEP+j];
    #####: 3299:                  valu+=duu[j+ib*GAINSTEP]  *ix2[newnr[nbolo]+ib*GAINSTEP+j];
        -: 3300:                }
        -: 3301:#endif
        -: 3302:
    #####: 3303:                if (nmatco>0) {
    #####: 3304:                  vali+=dcoi[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
    #####: 3305:                  valq+=dcoq[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
    #####: 3306:                  valu+=dcou[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
        -: 3307:                }
    #####: 3308:                if (nmatdust>0) {
    #####: 3309:                  vali+=ddusti[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
    #####: 3310:                  valq+=ddustq[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
    #####: 3311:                  valu+=ddustu[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
        -: 3312:                }
    #####: 3313:                if (nfreefree>0) {
    #####: 3314:                  vali+=dfri[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
    #####: 3315:                  valq+=dfrq[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
    #####: 3316:                  valu+=dfru[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
        -: 3317:                }
    #####: 3318:                for (m=0;m<npixbeam;m++) {
    #####: 3319:                  vali+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixi[ib+m*nbolo+k*nbolo*npixbeam];
    #####: 3320:                  valq+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixq[ib+m*nbolo+k*nbolo*npixbeam];
    #####: 3321:                  valu+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixu[ib+m*nbolo+k*nbolo*npixbeam];
        -: 3322:                }
        -: 3323:              }
        -: 3324:
    #####: 3325:              double qri=0;
    #####: 3326:              double qrq=0;
    #####: 3327:              double qru=0;
        -: 3328:
    #####: 3329:              for (l1=0;l1<ndata;l1++) {
    #####: 3330:                long ri1=htmp[l1].rg-globalBeginRing;
    #####: 3331:                long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
        -: 3332:
    #####: 3333:                double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 3334:                                                  -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 3335:                double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 3336:                                                  +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 3337:                if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####: 3338:                  double ww=htmp[l1].wp;
    #####: 3339:                  double val2=ix2[iri1]-(vali+CO1*valq+SI1*valu);
        -: 3340:
    #####: 3341:                  val2+=ix2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]*htmp[l1].model;
    #####: 3342:                  if (nmatco>0)
    #####: 3343:                    val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]*htmp[l1].comap;
    #####: 3344:                  if (nmatdust>0)
    #####: 3345:                    val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]*htmp[l1].dustmap;
    #####: 3346:                  if (nfreefree>0)
    #####: 3347:                    val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nfreefree+htmp[l1].ib]*htmp[l1].freefree;
        -: 3348:
    #####: 3349:                  for (m=0;m<npixbeam;m++) {
    #####: 3350:                    val2+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+htmp[l1].ib+m*nbolo]*htmp[l1].listofpix[m];
        -: 3351:                  }
        -: 3352:
    #####: 3353:                  qri-=ww*val2;
    #####: 3354:                  qrq-=ww*val2*CO1;
    #####: 3355:                  qru-=ww*val2*SI1;
        -: 3356:
    #####: 3357:                  q2[iri1]+=ww*val2;
        -: 3358:
    #####: 3359:                  q2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]+=ww*val2*htmp[l1].model;
        -: 3360:
        -: 3361:                  ///////////// CO
    #####: 3362:                  if (nmatco>0) {
    #####: 3363:                    q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]+=ww*val2*htmp[l1].comap;
        -: 3364:                  }
        -: 3365:
        -: 3366:                  ///////////// DUST
    #####: 3367:                  if (nmatdust>0) {
    #####: 3368:                    q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]+=ww*val2*htmp[l1].dustmap;
        -: 3369:                  }
        -: 3370:
        -: 3371:                  ///////////// FREEFREE
    #####: 3372:                  if (nfreefree>0) {
    #####: 3373:                    q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nfreefree+htmp[l1].ib]+=ww*val2*htmp[l1].freefree;
        -: 3374:                  }
        -: 3375:
    #####: 3376:                  for (j=0;j<npixbeam;j++) {
    #####: 3377:                    q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+htmp[l1].ib]+=ww*val2*htmp[l1].listofpix[j];
        -: 3378:                  }
        -: 3379:
        -: 3380:                }
        -: 3381:              }
        -: 3382:
    #####: 3383:              for (l2=0;l2<ndata;l2++) {
    #####: 3384:                long ri2=htmp[l2].rg-globalBeginRing;
    #####: 3385:                if (flg_rg[htmp[l2].ib][ri2]!=0) {
    #####: 3386:                  long ir=rgord[htmp[l2].ib][ri2]+newnr[htmp[l2].ib];
    #####: 3387:                  q2[ir]+=qri*htmp[l2].vi+qrq*htmp[l2].vq+qru*htmp[l2].vu;
        -: 3388:#ifndef USEDII
        -: 3389:                  q2[newnr[nbolo]+htmp[l2].ib*GAINSTEP+htmp[l2].gi]+=qri*htmp[l2].lvi+qrq*htmp[l2].lvq+qru*htmp[l2].lvu;
        -: 3390:#endif
        -: 3391:                }
        -: 3392:              }
        -: 3393:
    #####: 3394:              for (ib=0;ib<nbolo;ib++) {
        -: 3395:
        -: 3396:
        -: 3397:#ifdef USEDII
    #####: 3398:                for (j=0;j<GAINSTEP;j++) {
    #####: 3399:                  q2[newnr[nbolo]+GAINSTEP*ib+j]+=qri*dii[j+ib*GAINSTEP]+qrq*dqq[j+ib*GAINSTEP]+qru*duu[j+ib*GAINSTEP];
        -: 3400:                }
        -: 3401:#endif
        -: 3402:
        -: 3403:                ///////////// CO
    #####: 3404:                if (nmatco>0) {
    #####: 3405:                  q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib]+=qri*dcoi[ib+k*nbolo]+qrq*dcoq[ib+k*nbolo]+qru*dcou[ib+k*nbolo];
        -: 3406:                }
        -: 3407:                ///////////// DUST
    #####: 3408:                if (nmatdust>0) {
    #####: 3409:                  q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib]+=qri*ddusti[ib+k*nbolo]+qrq*ddustq[ib+k*nbolo]+qru*ddustu[ib+k*nbolo];
        -: 3410:                }
        -: 3411:
        -: 3412:                ///////////// FREEFREE
    #####: 3413:                if (nfreefree>0) {
    #####: 3414:                  q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib]+=qri*dfri[ib+k*nbolo]+qrq*dfrq[ib+k*nbolo]+qru*dfru[ib+k*nbolo];
        -: 3415:                }
        -: 3416:
    #####: 3417:                for (j=0;j<npixbeam;j++) {
    #####: 3418:                  q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+ib]+=qri*dpixi[ib+j*nbolo+k*nbolo*npixbeam]+qrq*dpixq[ib+j*nbolo+k*nbolo*npixbeam]+qru*dpixu[ib+j*nbolo+k*nbolo*npixbeam];
        -: 3419:                }
        -: 3420:              }
        -: 3421:            }
        -: 3422:          }
        -: 3423:#ifdef OPTIMPI
        -: 3424:	  {
    #####: 3425:	    double *lb = (double *) malloc(sizeof(double)*(nmatres));
    #####: 3426:	    MPI_Reduce(q2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 3427:
    #####: 3428:	    memcpy(q2,lb,sizeof(double)*(nmatres));
    #####: 3429:	    free(lb);
        -: 3430:	  }
        -: 3431:#else
        -: 3432:          if (rank==0) {
        -: 3433:            double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 3434:            for (rrk=1;rrk<mpi_size;rrk++) {
        -: 3435:              MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1034, MPI_COMM_WORLD,&statu);
        -: 3436:              for (l=0;l<nmatres;l++) q2[l]+=lb[l];
        -: 3437:            }
        -: 3438:
        -: 3439:            free(lb);
        -: 3440:          }
        -: 3441:          else {
        -: 3442:            MPI_Send(q2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1034, MPI_COMM_WORLD);
        -: 3443:          }
        -: 3444:#endif
        -: 3445:
    #####: 3446:          if (rank==0) for (i=0; i < nmatres; i++) {
    #####: 3447:            r2[i] = b2[i] - q2[i];
        -: 3448:          }
        -: 3449:
        -: 3450:        }
        -: 3451:      else
        -: 3452:        {
    #####: 3453:          if (rank==0) for (i=0; i < nmatres; i++) r2[i] -= alpha * q2[i];
        -: 3454:        }
        -: 3455:
    #####: 3456:      if (rank==0) for (i=0; i < nmatres; i++) s2[i] = r2[i] / hit2[i];
        -: 3457:
    #####: 3458:      delta_old = delta_new;
    #####: 3459:      if (rank==0) {
    #####: 3460:        delta_new=0;
    #####: 3461:        for (i=0; i < nmatres ; i++) delta_new += r2[i] * s2[i];
    #####: 3462:        beta = delta_new / delta_old;
    #####: 3463:        for (i=0; i < nmatres ; i++) d2[i] = s2[i] + beta * d2[i];
        -: 3464:      }
    #####: 3465:      iter ++;
    #####: 3466:      MPI_Bcast(&delta_new, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 3467:
        -: 3468:    }
        -: 3469:
    #####: 3470:  if (rank==0) fprintf (stderr,"\niter = %d - delta0 = %lg - delta_new = %lg\n",
        -: 3471:                        iter, delta0, delta_new);
    #####: 3472:  if (rank==0) fprintf (stderr,"CG in iter = %d (max=%d)\n", iter, itermax);
        -: 3473:
    #####: 3474:  if (rank==0) memcpy(ix2  ,x2old,nmatres*sizeof (double));
    #####: 3475:  MPI_Bcast(ix2, sizeof(double)*(nmatres), MPI_BYTE, 0, MPI_COMM_WORLD);
    #####: 3476:  itbogo++;
    #####: 3477:}
        -: 3478:
        -: 3479:#ifdef UPDATE_DIP
        -: 3480:#define UPDATE_DIP
        -: 3481:#endif
        -: 3482:
        -: 3483:// version of fit_adu_nl of r56 nadufit+1 is used instead of nadufit
        -: 3484:// this version checked manytimes, it works, and it is needed if GAINSTEP =! 1
        -: 3485:// the sliglt worst results  were caused by the activation of fit_adu_nl only after the 3rd iteration
        -: 3486:// VS after the first iteration in the old code aka r38
        -: 3487:
        -: 3488://=========================================================================
        -: 3489:// OPTIMIZED IN MEMORY TO AVOID CRASH WHEN nbolo>8 : loop on bolometer
        -: 3490://=========================================================================
        -: 3491:
       36: 3492:void fit_adu_nl_opt(double *x3,double *gain,double *outtemp,double *nouttemp)
        -: 3493:{
        -: 3494:  int rank,i,k,j,l,rrk;
        -: 3495:  int size;
        -: 3496:  MPI_Status statu;
        -: 3497:  int mpi_size;
        -: 3498:  int rank_size;
       36: 3499:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
       36: 3500:  rank=rank_size;
       36: 3501:  MPI_Comm_size(MPI_COMM_WORLD,&size);
       36: 3502:  mpi_size=size;
        -: 3503:  int ib;
        -: 3504:
       36: 3505:  double *lgain=(double *) malloc(sizeof(double)*nbolo);
      180: 3506:  for (i=0;i<nbolo;i++) {
      144: 3507:    double gtmp=0;
      144: 3508:    for (k=0;k<GAINSTEP;k++) gtmp+=gain[k+i*GAINSTEP];
      144: 3509:    lgain[i]=gtmp/((double) GAINSTEP);
        -: 3510:  }
        -: 3511:
        -: 3512:
       36: 3513:  double **ivec = (double **) malloc(sizeof(double *)*nbolo);
       36: 3514:  double *imat=NULL;
        -: 3515:
       36: 3516:  double *mapsi= (double *) malloc(sizeof(double)*nnbpix);
       36: 3517:  double *mapsq= (double *) malloc(sizeof(double)*nnbpix);
       36: 3518:  double *mapsu= (double *) malloc(sizeof(double)*nnbpix);
        -: 3519:
        -: 3520:  int l1,m;
452984868: 3521:  for (k=0;k<nnbpix;k++) {
452984832: 3522:    mapsi[k]=-1.6E30;
452984832: 3523:    if (flgpix[k]>0) {
   175383: 3524:      long ndata = loc_nhpix[k];
   175383: 3525:      hpix *htmp = loc_hpix[k];
        -: 3526:
   175383: 3527:      double SII=0;
   175383: 3528:      double SIQ=0;
   175383: 3529:      double SIU=0;
   175383: 3530:      double SQQ=0;
   175383: 3531:      double SUU=0;
   175383: 3532:      double SQU=0;
        -: 3533:
   175383: 3534:      double SI=0;
   175383: 3535:      double SQ=0;
   175383: 3536:      double SU=0;
        -: 3537:
        -: 3538:
   803529: 3539:      for (l1=0;l1<ndata;l1++) {
   628146: 3540:	long ri1=htmp[l1].rg-globalBeginRing;
   628146: 3541:	long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
   628146: 3542:	if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 3543:
  1256292: 3544:	  double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
   628146: 3545:					    -dpsisi[htmp[l1].ib]*htmp[l1].si);
  1256292: 3546:	  double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
   628146: 3547:					    +dpsisi[htmp[l1].ib]*htmp[l1].co);
        -: 3548:
   628146: 3549:	  double gg2=gain[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 3550:
   628146: 3551:	  double sig_corr = htmp[l1].sig*gg2-htmp[l1].fsl;
   628146: 3552:	  if (REMHDIP==0) sig_corr-=htmp[l1].dip;
   628146: 3553:	  else sig_corr-=htmp[l1].freefree;
        -: 3554:
   628146: 3555:	  sig_corr-=htmp[l1].corr_nl+htmp[l1].corr_cnn;
        -: 3556:
   628146: 3557:	  sig_corr-=x3[iri1];
        -: 3558:
        -: 3559:	  // ATTENTION GAINSTEP EST FORCE A 1
   628146: 3560:	  sig_corr-=x3[newnr[nbolo]+htmp[l1].ib]*htmp[l1].model;
        -: 3561:
   628146: 3562:	  if (nmatco!=0) {
   628146: 3563:	    sig_corr -=htmp[l1].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib];
        -: 3564:	  }
   628146: 3565:	  if (nmatdust!=0) {
   628146: 3566:	    sig_corr -=htmp[l1].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib];
        -: 3567:	  }
   628146: 3568:	  if (nfreefree!=0) {
    #####: 3569:	    sig_corr -=htmp[l1].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib];
        -: 3570:	  }
  5653314: 3571:	  for (m=0;m<npixbeam;m++)  {
  5025168: 3572:	    sig_corr -= htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -: 3573:	  }
   628146: 3574:	  SI +=htmp[l1].w*sig_corr;
   628146: 3575:	  SQ +=htmp[l1].w*CO1*sig_corr;
   628146: 3576:	  SU +=htmp[l1].w*SI1*sig_corr;
        -: 3577:
   628146: 3578:	  SII +=htmp[l1].w;
   628146: 3579:	  SIQ +=htmp[l1].w*CO1;
   628146: 3580:	  SIU +=htmp[l1].w*SI1;
   628146: 3581:	  SQQ +=htmp[l1].w*CO1*CO1;
   628146: 3582:	  SQU +=htmp[l1].w*CO1*SI1;
   628146: 3583:	  SUU +=htmp[l1].w*SI1*SI1;
        -: 3584:	}
        -: 3585:      }
        -: 3586:
   175383: 3587:      if (Param->OUT_NOPOL[0]%2==0) {
    #####: 3588:	double cond=cond_3_3_thres(SII,SIQ,SIU,
        -: 3589:				   SIQ,SQQ,SQU,
        -: 3590:				   SIU,SQU,SUU);
        -: 3591:
    #####: 3592:	if (cond<Param->seuilcond) {
    #####: 3593:	  solvemap(&SI,&SQ,&SU,SII,SIQ,SIU,SQQ,SQU,SUU);
    #####: 3594:	  mapsi[k]=SI;
    #####: 3595:	  mapsq[k]=SQ;
    #####: 3596:	  mapsu[k]=SU;
        -: 3597:	}
        -: 3598:      }
        -: 3599:      else {
   175383: 3600:	if (SII>0) {
   175383: 3601:	  mapsi[k]=SI/SII;
        -: 3602:	}
        -: 3603:      }
        -: 3604:    }
        -: 3605:  }
        -: 3606:
        -: 3607:  // BUILD MATRIX ADU IF IT IS THE FIRST TIME
       36: 3608:  if (mat1_adu==NULL) {
        4: 3609:    mat1_adu=(double *)(1); // TO AVOID RECOMPUTING THIS MATRIX
       20: 3610:    for (ib=0;ib<nbolo;ib++) {
       16: 3611:      double *v1 = (double *) malloc(sizeof(double)*(newnr[nbolo]));
       16: 3612:      memset(v1,0,sizeof(double)*(newnr[nbolo]));
       16: 3613:      if (rank==0) fprintf(stderr,"BUILD ADU MATRIX BOLO %d\n",(int) ib);
       16: 3614:      double *mat1 = (double *) malloc(sizeof(double)*((nadufit[ib]+1)*(nadufit[ib]+1)));
       16: 3615:      memset(mat1,0,sizeof(double)*((nadufit[ib]+1)*(nadufit[ib]+1)));
       16: 3616:      double *mat2 =(double *) malloc(sizeof(double)*((newnr[ib+1]-newnr[ib])*(nadufit[ib]+1)));
       16: 3617:      memset(mat2,0,sizeof(double)*((newnr[ib+1]-newnr[ib])*(nadufit[ib]+1)));
        -: 3618:
201326608: 3619:      for (k=0;k<nnbpix;k++) {
201326592: 3620:	if (mapsi[k]!=-1.6E30) {
    77948: 3621:	  long ndata = loc_nhpix[k];
    77948: 3622:	  hpix *htmp = loc_hpix[k];
        -: 3623:
    77948: 3624:	  if (Param->OUT_NOPOL[0]%2==0) {
    #####: 3625:	    for (l1=0;l1<ndata;l1++) {
    #####: 3626:	      if (htmp[l1].ib==ib) {
        -: 3627:		int iii,jjj;
        -: 3628:
    #####: 3629:		long ri1=htmp[l1].rg-globalBeginRing;
    #####: 3630:		long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
    #####: 3631:		if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 3632:
    #####: 3633:		  v1[iri1]+=htmp[l1].w;
        -: 3634:
    #####: 3635:		  mat2[nadufit[htmp[l1].ib]+rgord[htmp[l1].ib][ri1]*(nadufit[htmp[l1].ib]+1)]
    #####: 3636:		    +=htmp[l1].adu/1000.*htmp[l1].w;
        -: 3637:
    #####: 3638:		  mat1[nadufit[htmp[l1].ib]+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]
    #####: 3639:		    +=htmp[l1].w*htmp[l1].adu/1000.*htmp[l1].adu/1000.;
        -: 3640:
    #####: 3641:		  if (ADURGSTEP[htmp[l1].ib]>2) {
    #####: 3642:		    for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 3643:		      for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
    #####: 3644:			int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
    #####: 3645:			mat2[l_idx+rgord[htmp[l1].ib][ri1]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3646:			  htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 3647:			  rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 3648:
    #####: 3649:			mat1[l_idx+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3650:			  htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 3651:			  rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].adu/1000.*htmp[l1].w;
    #####: 3652:			mat1[nadufit[htmp[l1].ib]+l_idx*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3653:			  htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 3654:			  rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].adu/1000.*htmp[l1].w;
        -: 3655:
        -: 3656:			int iii2,jjj2;
    #####: 3657:			for (iii2=htmp[l1].istart;iii2<=htmp[l1].iend;iii2++) {
    #####: 3658:			  for (jjj2=rg_start[htmp[l1].ib][htmp[l1].rg];jjj2<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj2++) {
    #####: 3659:			    int l_idx2=jjj2+ADURGSTEP[htmp[l1].ib]*iii2;
        -: 3660:
    #####: 3661:			    mat1[l_idx+l_idx2*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3662:			      htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 3663:			      *rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]
    #####: 3664:			      *htmp[l1].vspline[iii2-htmp[l1].istart]
    #####: 3665:			      *rg_vals[htmp[l1].ib][jjj2-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 3666:			  }
        -: 3667:			}
        -: 3668:		      }
        -: 3669:		    }
        -: 3670:		  }
        -: 3671:		  else {
        -: 3672:
    #####: 3673:		    for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 3674:		      mat2[iii+rgord[htmp[l1].ib][ri1]*(nadufit[htmp[l1].ib]+1)]+=htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].w;
        -: 3675:
    #####: 3676:		      mat1[iii+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3677:			htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].adu/1000.*htmp[l1].w;
    #####: 3678:		      mat1[nadufit[htmp[l1].ib]+iii*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3679:			htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].adu/1000.*htmp[l1].w;
        -: 3680:
    #####: 3681:		      for (jjj=htmp[l1].istart;jjj<=htmp[l1].iend;jjj++) {
    #####: 3682:			mat1[iii+jjj*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3683:			  htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 3684:			  *htmp[l1].vspline[jjj-htmp[l1].istart]*htmp[l1].w;
        -: 3685:		      }
        -: 3686:		    }
        -: 3687:		  }
        -: 3688:		}
        -: 3689:	      }
        -: 3690:	    }
        -: 3691:	  }
        -: 3692:	  else {
   357124: 3693:	    for (l1=0;l1<ndata;l1++) {
   279176: 3694:	      if (htmp[l1].ib==ib) {
    69794: 3695:		long ri1=htmp[l1].rg-globalBeginRing;
    69794: 3696:		long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
    69794: 3697:		if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 3698:
        -: 3699:		  long iii,jjj;
        -: 3700:
    69794: 3701:		  v1[iri1]+=htmp[l1].w;
        -: 3702:
    69794: 3703:		  mat2[nadufit[htmp[l1].ib]+rgord[htmp[l1].ib][ri1]*(nadufit[htmp[l1].ib]+1)]+=htmp[l1].adu/1000.*htmp[l1].w;
   279176: 3704:		  mat1[nadufit[htmp[l1].ib]+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]
   279176: 3705:		    +=htmp[l1].w*htmp[l1].adu/1000.*htmp[l1].adu/1000.;
        -: 3706:
    69794: 3707:		  if (ADURGSTEP[htmp[l1].ib]>2) {
    #####: 3708:		    for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 3709:		      for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
    #####: 3710:			int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
    #####: 3711:			mat2[l_idx+rgord[htmp[l1].ib][ri1]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3712:			  htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 3713:			  rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 3714:
    #####: 3715:			mat1[l_idx+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3716:			  htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 3717:			  rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].adu/1000*htmp[l1].w;
    #####: 3718:			mat1[nadufit[htmp[l1].ib]+l_idx*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3719:			  htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 3720:			  rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].adu/1000.*htmp[l1].w;
        -: 3721:
        -: 3722:			int iii2,jjj2;
    #####: 3723:			for (iii2=htmp[l1].istart;iii2<=htmp[l1].iend;iii2++) {
    #####: 3724:			  for (jjj2=rg_start[htmp[l1].ib][htmp[l1].rg];jjj2<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj2++) {
    #####: 3725:			    int l_idx2=jjj2+ADURGSTEP[htmp[l1].ib]*iii2;
        -: 3726:
    #####: 3727:			    mat1[l_idx+l_idx2*(nadufit[htmp[l1].ib]+1)]+=
    #####: 3728:			      htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 3729:			      *rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]
    #####: 3730:			      *htmp[l1].vspline[iii2-htmp[l1].istart]
    #####: 3731:			      *rg_vals[htmp[l1].ib][jjj2-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 3732:			  }
        -: 3733:			}
        -: 3734:		      }
        -: 3735:		    }
        -: 3736:		  }
        -: 3737:		  else {
   348970: 3738:		    for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
  1116704: 3739:		      mat2[iii+rgord[htmp[l1].ib][ri1]*nadufit[htmp[l1].ib]]
  1116704: 3740:			+=htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].w;
   558352: 3741:		      mat1[iii+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]+=
   279176: 3742:			htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].adu/1000*htmp[l1].w;
   558352: 3743:		      mat1[nadufit[htmp[l1].ib]+iii*(nadufit[htmp[l1].ib]+1)]+=
   279176: 3744:			htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].adu/1000*htmp[l1].w;
        -: 3745:
  1395880: 3746:		      for (jjj=htmp[l1].istart;jjj<=htmp[l1].iend;jjj++) {
  2233408: 3747:			mat1[iii+jjj*(nadufit[htmp[l1].ib]+1)]+=
  1116704: 3748:			  htmp[l1].vspline[iii-htmp[l1].istart]
  1116704: 3749:			  *htmp[l1].vspline[jjj-htmp[l1].istart]*htmp[l1].w;
        -: 3750:		      }
        -: 3751:		    }
        -: 3752:		  }
        -: 3753:		}
        -: 3754:	      }
        -: 3755:	    }
        -: 3756:	  }
        -: 3757:	}
        -: 3758:      }
        -: 3759:
       16: 3760:      double *lb = (double *) malloc(sizeof(double)*(newnr[nbolo]));
       16: 3761:      MPI_Reduce(v1,lb,newnr[nbolo],MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
       16: 3762:      memcpy(v1,lb,sizeof(double)*(newnr[nbolo]));
       16: 3763:      free(lb);
        -: 3764:
       16: 3765:      lb = (double *) malloc(sizeof(double)*((nadufit[ib]+1)*(nadufit[ib]+1)));
       16: 3766:      MPI_Reduce(mat1,lb,((nadufit[ib]+1)*(nadufit[ib]+1)),MPI_DOUBLE,MPI_SUM,ib,MPI_COMM_WORLD);
       16: 3767:      memcpy(mat1,lb,sizeof(double)*((nadufit[ib]+1)*(nadufit[ib]+1)));
       16: 3768:      free(lb);
        -: 3769:
       16: 3770:      lb = (double *) malloc(sizeof(double)*((newnr[ib+1]-newnr[ib])*(nadufit[ib]+1)));
       16: 3771:      MPI_Reduce(mat2,lb,((newnr[ib+1]-newnr[ib])*(nadufit[ib]+1)),MPI_DOUBLE,MPI_SUM,ib,MPI_COMM_WORLD);
       16: 3772:      memcpy(mat2,lb,sizeof(double)*((newnr[ib+1]-newnr[ib])*(nadufit[ib]+1)));
       16: 3773:      free(lb);
        -: 3774:
        -: 3775:/*==============================================================================
        -: 3776:  AND NOW STORE THE MATRIX TO INVERT
        -: 3777:  ==============================================================================*/
        -: 3778:
       16: 3779:    if (rank==ib) {
        -: 3780:
        4: 3781:      for (j=newnr[ib];j<newnr[ib];j++) {
    #####: 3782:        for (k=0;k<(nadufit[ib]+1);k++) {
    #####: 3783:          for (l=0;l<(nadufit[ib]+1);l++) {
    #####: 3784:            mat1[k+l*(nadufit[ib]+1)]-=mat2[k+(j-newnr[ib])*(nadufit[ib]+1)]
    #####: 3785:	      *mat2[l+(j-newnr[ib])*(nadufit[ib]+1)]/v1[j];
        -: 3786:          }
        -: 3787:        }
        -: 3788:      }
        -: 3789:
        4: 3790:      for (j=newnr[ib];j<newnr[ib];j++) {
    #####: 3791:        for (k=0;k<nadufit[ib]+1;k++) {
    #####: 3792:          mat2[k+(j-newnr[ib])*(nadufit[ib]+1)]=mat2[k+(j-newnr[ib])*(nadufit[ib]+1)]/v1[j];
        -: 3793:        }
        -: 3794:      }
        -: 3795:
        -: 3796:
        -: 3797:#ifdef ADDNADUFITP1
        -: 3798:      for (k=0;k<nadufit[ib];k++) {
        -: 3799:	for (j=0;j<nadufit[ib];j++) mat1[j+k*nadufit[ib]]=mat1[j+k*(nadufit[ib]+1)];
        -: 3800:      }
        -: 3801:#endif
        -: 3802:    }
        -: 3803:
       16: 3804:    if (rank!=ib) {
       12: 3805:      free(mat1);
        -: 3806:    }
        4: 3807:    else mat1_adu = mat1;
       16: 3808:    if (rank!=ib) free(mat2);
        4: 3809:    else mat2_adu = mat2;
       16: 3810:    free(v1);
        -: 3811:    }
        -: 3812:  }
        -: 3813:
      180: 3814:  for (ib=0;ib<nbolo;ib++) {
      144: 3815:    if (rank==0) fprintf(stderr,"Fit ADU BOLO %d\n",(int) ib);
      144: 3816:    ivec[ib] = (double *) malloc(sizeof(double)*((nadufit[ib]+1)));
      144: 3817:    double *vec = (double *) malloc(sizeof(double)*((nadufit[ib]+1)+newnr[ib+1]-newnr[ib]));
      144: 3818:    memset(vec,0,sizeof(double)*((nadufit[ib]+1)+newnr[ib+1]-newnr[ib]));
        -: 3819:
1811939472: 3820:    for (k=0;k<nnbpix;k++) {
1811939328: 3821:      if (mapsi[k]!=-1.6E30) {
   701532: 3822:	long ndata = loc_nhpix[k];
   701532: 3823:	hpix *htmp = loc_hpix[k];
        -: 3824:
   701532: 3825:	if (Param->OUT_NOPOL[0]%2==0) {
    #####: 3826:	  for (l1=0;l1<ndata;l1++) if (htmp[l1].ib==ib) {
    #####: 3827:	      long ri1=htmp[l1].rg-globalBeginRing;
    #####: 3828:	      long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
    #####: 3829:	      if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####: 3830:		double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 3831:						  -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 3832:		double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 3833:						  +dpsisi[htmp[l1].ib]*htmp[l1].co);
        -: 3834:
        -: 3835:		long iii,jjj;
    #####: 3836:		double gg2=lgain[htmp[l1].ib];
        -: 3837:
    #####: 3838:		double sig_corr = (htmp[l1].sig*gg2-htmp[l1].fsl);
    #####: 3839:		if (REMHDIP==0) sig_corr-=htmp[l1].dip;
    #####: 3840:		else sig_corr-=htmp[l1].freefree;
        -: 3841:
    #####: 3842:		sig_corr-=htmp[l1].corr_cnn;
        -: 3843:
    #####: 3844:		sig_corr-=x3[iri1];
        -: 3845:
        -: 3846:		// ATTENTION GAINSTEP EST FORCE A 1
    #####: 3847:		sig_corr-=x3[newnr[nbolo]+htmp[l1].ib]*htmp[l1].model;
        -: 3848:
    #####: 3849:		if (nmatco!=0) {
    #####: 3850:		  sig_corr -=htmp[l1].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib];
        -: 3851:		}
    #####: 3852:		if (nmatdust!=0) {
    #####: 3853:		  sig_corr -=htmp[l1].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib];
        -: 3854:		}
    #####: 3855:		if (nfreefree!=0) {
    #####: 3856:		  sig_corr -=htmp[l1].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib];
        -: 3857:		}
    #####: 3858:		for (m=0;m<npixbeam;m++)  {
    #####: 3859:		  sig_corr -= htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -: 3860:		}
        -: 3861:
    #####: 3862:		double residu=sig_corr-mapsi[k]-CO1*mapsq[k]-SI1*mapsu[k];
        -: 3863:
    #####: 3864:		vec[nadufit[htmp[l1].ib]]+=residu*htmp[l1].adu/1000.*htmp[l1].w;
    #####: 3865:		if (ADURGSTEP[htmp[l1].ib]>2) {
    #####: 3866:		  for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 3867:		    for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
    #####: 3868:		      int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
    #####: 3869:		      vec[l_idx]+=residu*htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 3870:			*rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 3871:		    }
        -: 3872:		  }
        -: 3873:		}
        -: 3874:		else {
    #####: 3875:		  for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 3876:		    vec[iii]+=residu*htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].w;
        -: 3877:		  }
        -: 3878:		}
    #####: 3879:		vec[(nadufit[htmp[l1].ib]+1)+iri1-newnr[htmp[l1].ib]]+=residu*htmp[l1].w;
        -: 3880:	      }
        -: 3881:	    }
        -: 3882:	}
        -: 3883:	else {
  3214116: 3884:	  for (l1=0;l1<ndata;l1++) if (htmp[l1].ib==ib) {
   628146: 3885:	      long ri1=htmp[l1].rg-globalBeginRing;
   628146: 3886:	      long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
   628146: 3887:	      if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 3888:
        -: 3889:		long iii,jjj;
   628146: 3890:		double gg2=lgain[htmp[l1].ib];
        -: 3891:
   628146: 3892:		double sig_corr = (htmp[l1].sig*gg2-htmp[l1].fsl);
   628146: 3893:		if (REMHDIP==0) sig_corr-=htmp[l1].dip;
   628146: 3894:		else sig_corr-=htmp[l1].freefree;
        -: 3895:
   628146: 3896:		sig_corr-=htmp[l1].corr_cnn;
        -: 3897:
   628146: 3898:		sig_corr-=x3[iri1];
        -: 3899:
        -: 3900:		// ATTENTION GAINSTEP EST FORCE A 1
   628146: 3901:		sig_corr-=x3[newnr[nbolo]+htmp[l1].ib]*htmp[l1].model;
        -: 3902:
   628146: 3903:		if (nmatco!=0) {
   628146: 3904:		  sig_corr -=htmp[l1].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib];
        -: 3905:		}
   628146: 3906:		if (nmatdust!=0) {
   628146: 3907:		  sig_corr -=htmp[l1].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib];
        -: 3908:		}
   628146: 3909:		if (nfreefree!=0) {
    #####: 3910:		  sig_corr -=htmp[l1].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib];
        -: 3911:		}
  5653314: 3912:		for (m=0;m<npixbeam;m++)  {
  5025168: 3913:		  sig_corr -= htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -: 3914:		}
        -: 3915:
   628146: 3916:		double residu=sig_corr-mapsi[k];
        -: 3917:
   628146: 3918:		vec[nadufit[htmp[l1].ib]]+=residu*htmp[l1].adu/1000.*htmp[l1].w;
   628146: 3919:		if (ADURGSTEP[htmp[l1].ib]>2) {
    #####: 3920:		  for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 3921:		    for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
    #####: 3922:		      int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
    #####: 3923:		      vec[l_idx]+=residu*htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 3924:			*rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 3925:		    }
        -: 3926:		  }
        -: 3927:		}
        -: 3928:		else {
  3140730: 3929:		  for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
  2512584: 3930:		    vec[iii]+=residu*htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].w;
        -: 3931:		  }
        -: 3932:		}
   628146: 3933:		vec[(nadufit[htmp[l1].ib]+1)+iri1-newnr[htmp[l1].ib]]+=residu*htmp[l1].w;
        -: 3934:	      }
        -: 3935:	    }
        -: 3936:	}
        -: 3937:      }
        -: 3938:    }
        -: 3939:
        -: 3940:
        -: 3941:#ifdef OPTIMPI
      144: 3942:    double *lb = (double *) malloc(sizeof(double)*((nadufit[ib]+1)+newnr[ib+1]-newnr[ib]));
      144: 3943:    MPI_Reduce(vec,lb,((nadufit[ib]+1)+newnr[ib+1]-newnr[ib]),MPI_DOUBLE,MPI_SUM,ib,MPI_COMM_WORLD);
      144: 3944:    memcpy(vec,lb,sizeof(double)*((nadufit[ib]+1)+newnr[ib+1]-newnr[ib]));
      144: 3945:    free(lb);
        -: 3946:#else
        -: 3947:    if (rank==ib) {
        -: 3948:
        -: 3949:      double *lb = (double *) malloc(sizeof(double)*((nadufit[ib]+1)+newnr[ib+1]-newnr[ib]));
        -: 3950:
        -: 3951:      for (rrk=0;rrk<mpi_size;rrk++) if (rrk!=ib) {
        -: 3952:	MPI_Recv(lb,sizeof(double)*((nadufit[ib]+1)+newnr[ib+1]-newnr[ib]), MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
        -: 3953:	for (l=0;l<(nadufit[ib]+1)+newnr[ib+1]-newnr[ib];l++) vec[l]+=lb[l];
        -: 3954:      }
        -: 3955:      free(lb);
        -: 3956:
        -: 3957:    }
        -: 3958:    else {
        -: 3959:      MPI_Send(vec,sizeof(double)*((nadufit[ib]+1)+newnr[ib+1]-newnr[ib]), MPI_BYTE, ib, 1031, MPI_COMM_WORLD);
        -: 3960:    }
        -: 3961:
        -: 3962:#endif
        -: 3963:
        -: 3964:/*==============================================================================
        -: 3965:  AND NOW STORE THE MATRIX TO INVERT
        -: 3966:  ==============================================================================*/
        -: 3967:
      144: 3968:    if (rank==ib) {
       36: 3969:      for (j=newnr[ib];j<newnr[ib];j++) {
    #####: 3970:        for (k=0;k<nadufit[ib]+1;k++) {
    #####: 3971:          vec[k]-=mat2_adu[k+(j-newnr[ib])*(nadufit[ib]+1)]*vec[(nadufit[ib]+1)+j];
        -: 3972:        }
        -: 3973:      }
        -: 3974:
       36: 3975:      memcpy(ivec[ib],vec,sizeof(double)*((nadufit[ib]+1)));
       36: 3976:      imat = (double *) malloc(sizeof(double)*(nadufit[ib]+1)*(nadufit[ib]+1));
       36: 3977:      memcpy(imat,mat1_adu,sizeof(double)*(nadufit[ib]+1)*(nadufit[ib]+1));
        -: 3978:    }
      144: 3979:    free(vec);
        -: 3980:  }
        -: 3981:
       36: 3982:  free(mapsi);
       36: 3983:  free(mapsq);
       36: 3984:  free(mapsu);
        -: 3985:
       36: 3986:  if (rank<nbolo) {
       36: 3987:    fprintf(stderr,"Invert FIT_ADU MATRIX bolo=%d proc=%d %ld %ld\n",(int) rank,(int) rank,(long) imat,(long) ivec[rank]);
        -: 3988:#if 0
        -: 3989:    fprintf(stderr,"WRITE MATRIX %d\n",rank);
        -: 3990:    char path[512];
        -: 3991:    sprintf(path,"mat1opt_%d",rank);
        -: 3992:    FILE *fp=fopen(path,"w");
        -: 3993:    fwrite(imat,(nadufit[rank]+1)*(nadufit[rank]+1)*sizeof(double),1,fp);
        -: 3994:    fclose(fp);
        -: 3995:    sprintf(path,"vecopt_%d",rank);
        -: 3996:    fp=fopen(path,"w");
        -: 3997:    fwrite(ivec[rank],(nadufit[rank]+1)*sizeof(double),1,fp);
        -: 3998:    fclose(fp);
        -: 3999:
        -: 4000:#endif
        -: 4001:
        -: 4002:#ifdef ADDNADUFITP1
        -: 4003:    lusol(imat,ivec[rank],(nadufit[rank]/*+1*/));
        -: 4004:#else
       36: 4005:    lusol(imat,ivec[rank],(nadufit[rank]+1));
        -: 4006:#endif
        -: 4007:
       36: 4008:    free(imat);
        -: 4009:
        -: 4010:#ifdef TESTFITADU
        -: 4011:    PIOSTRING saveg;
        -: 4012:    sprintf(saveg,"%s_OUTNL",Param->Out_Offset[i]);
        -: 4013:    fprintf(stderr,"Write OUTNL  %lld\n",(long long) (PIOWriteVECT(saveg,ivec[rank],0,sizeof(PIODOUBLE)*(nadufit[rank]+1)))/sizeof(double));
        -: 4014:#endif
        -: 4015:
        -: 4016:  }
        -: 4017:
        -: 4018:  /// MODIF
       36: 4019:  for (ib=0;ib<nbolo;ib++) MPI_Bcast(ivec[ib],sizeof(double)*(nadufit[ib]+1),MPI_BYTE, ib, MPI_COMM_WORLD);
        -: 4020:
       36: 4021:  memset(outtemp,0,sizeof(double)*320*320*nbolo);
       36: 4022:  memset(nouttemp,0,sizeof(double)*320*320*nbolo);
        -: 4023:
452984868: 4024:  for (k=0;k<nnbpix;k++) {
452984832: 4025:    long ndata = loc_nhpix[k];
452984832: 4026:    hpix *htmp = loc_hpix[k];
        -: 4027:    int l1;
        -: 4028:
454752297: 4029:    for (l1=0;l1<ndata;l1++) {
  1767465: 4030:      long ri1=htmp[l1].rg-globalBeginRing;
  1767465: 4031:      if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 4032:	long iii,jjj;
        -: 4033:
        -: 4034:#ifdef ADDNADUFITP1
        -: 4035:	htmp[l1].corr_nl=0
        -: 4036:#else
  1767465: 4037:	htmp[l1].corr_nl=ivec[htmp[l1].ib][nadufit[htmp[l1].ib]]*htmp[l1].adu/1000.;
        -: 4038:#endif
        -: 4039:
  1767465: 4040:	if (ADURGSTEP[htmp[l1].ib]>2) {
    #####: 4041:	  for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4042:	    for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
    #####: 4043:              int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
    #####: 4044:		htmp[l1].corr_nl+=htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 4045:		  *rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*ivec[htmp[l1].ib][l_idx];
        -: 4046:	    }
        -: 4047:	  }
        -: 4048:	}
        -: 4049:	else {
  8837325: 4050:	  for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
  7069860: 4051:	    htmp[l1].corr_nl+=htmp[l1].vspline[iii-htmp[l1].istart]*ivec[htmp[l1].ib][iii];
        -: 4052:	  }
        -: 4053:	}
        -: 4054:
  1767465: 4055:	outtemp[htmp[l1].adu/100+320*(htmp[l1].rg/100)+320*320*htmp[l1].ib]+=htmp[l1].corr_nl;
  1767465: 4056:	nouttemp[htmp[l1].adu/100+320*(htmp[l1].rg/100)+320*320*htmp[l1].ib]+=1;
        -: 4057:      }
        -: 4058:    }
        -: 4059:  }
        -: 4060:
        -: 4061:#ifdef OPTIMPI
       36: 4062:  double *lb = (double *) malloc(sizeof(double)*320*320*nbolo);
       36: 4063:  MPI_Reduce(outtemp,lb,320*320*nbolo,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
       36: 4064:  memcpy(outtemp,lb,sizeof(double)*320*320*nbolo);
       36: 4065:  MPI_Reduce(nouttemp,lb,320*320*nbolo,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
       36: 4066:  memcpy(nouttemp,lb,sizeof(double)*320*320*nbolo);
       36: 4067:  free(lb);
        -: 4068:#else
        -: 4069:  if (rank==0) {
        -: 4070:    double *lb = (double *) malloc(sizeof(double)*320*320*nbolo);
        -: 4071:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 4072:      MPI_Recv(lb,sizeof(double)*320*320*nbolo, MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
        -: 4073:      for (l=0;l<320*320*nbolo;l++) outtemp[l]+=lb[l];
        -: 4074:      MPI_Recv(lb,sizeof(double)*320*320*nbolo, MPI_BYTE, rrk,1032, MPI_COMM_WORLD,&statu);
        -: 4075:      for (l=0;l<320*320*nbolo;l++) nouttemp[l]+=lb[l];
        -: 4076:    }
        -: 4077:    free(lb);
        -: 4078:    for (l=0;l<320*320*nbolo;l++) if (nouttemp[l]>0) outtemp[l]/=nouttemp[l];
        -: 4079:  }
        -: 4080:  else {
        -: 4081:    MPI_Send(outtemp,sizeof(double)*320*320*nbolo, MPI_BYTE, 0, 1031, MPI_COMM_WORLD);
        -: 4082:    MPI_Send(nouttemp,sizeof(double)*320*320*nbolo, MPI_BYTE, 0, 1032, MPI_COMM_WORLD);
        -: 4083:  }
        -: 4084:#endif
        -: 4085:
       36: 4086:  free(lgain);
        -: 4087:
       36: 4088:  for (i=0;i<nbolo;i++) free(ivec[i]);
       36: 4089:  free(ivec);
       36: 4090:}
        -: 4091:
        -: 4092:
        -: 4093://=========================================================================
        -: 4094:// TO BE OPTIMIZED IN MEMORY TO AVOID CRASH WHEN nbolo>8
        -: 4095://=========================================================================
        -: 4096:
    #####: 4097:void fit_adu_nl(double *x3,double *gain,double *outtemp,double *nouttemp)
        -: 4098:{
        -: 4099:  int rank,i,k,j,l,rrk;
        -: 4100:  int size;
        -: 4101:  MPI_Status statu;
        -: 4102:  int mpi_size;
        -: 4103:  int rank_size;
    #####: 4104:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
    #####: 4105:  rank=rank_size;
    #####: 4106:  MPI_Comm_size(MPI_COMM_WORLD,&size);
    #####: 4107:  mpi_size=size;
        -: 4108:
    #####: 4109:  double *lgain=(double *) malloc(sizeof(double)*nbolo);
    #####: 4110:  for (i=0;i<nbolo;i++) {
    #####: 4111:    double gtmp=0;
    #####: 4112:    for (k=0;k<GAINSTEP;k++) gtmp+=gain[k+i*GAINSTEP];
    #####: 4113:    lgain[i]=gtmp/((double) GAINSTEP);
        -: 4114:  }
    #####: 4115:  double **vec = (double **) malloc(sizeof(double *)*nbolo);
    #####: 4116:  for (i=0;i<nbolo;i++) {
    #####: 4117:    vec[i]= (double *) malloc(sizeof(double)*((nadufit[i]+1)+newnr[i+1]-newnr[i]));
    #####: 4118:    memset(vec[i],0,sizeof(double)*((nadufit[i]+1)+newnr[i+1]-newnr[i]));
        -: 4119:  }
        -: 4120:
    #####: 4121:  double *v1 = (double *) malloc(sizeof(double)*(newnr[nbolo]));
    #####: 4122:  memset(v1,0,sizeof(double)*(newnr[nbolo]));
        -: 4123:
    #####: 4124:  double **mat1 = (double **) malloc(sizeof(double *)*nbolo);
    #####: 4125:  for (i=0;i<nbolo;i++) {
    #####: 4126:    mat1[i] = (double *) malloc(sizeof(double)*((nadufit[i]+1)*(nadufit[i]+1)));
    #####: 4127:    memset(mat1[i],0,sizeof(double)*((nadufit[i]+1)*(nadufit[i]+1)));
        -: 4128:  }
        -: 4129:
    #####: 4130:  double **mat2 = (double **) malloc(sizeof(double *)*(nbolo));
    #####: 4131:  for (i=0;i<nbolo;i++) mat2[i]=(double *) malloc(sizeof(double)*((newnr[i+1]-newnr[i])*(nadufit[i]+1)));
    #####: 4132:  for (i=0;i<nbolo;i++) memset(mat2[i],0,sizeof(double)*((newnr[i+1]-newnr[i])*(nadufit[i]+1)));
        -: 4133:
    #####: 4134:  for (k=0;k<nnbpix;k++) {
    #####: 4135:    if (flgpix[k]>0) {
    #####: 4136:      long ndata = loc_nhpix[k];
    #####: 4137:      hpix *htmp = loc_hpix[k];
        -: 4138:
    #####: 4139:      double SII=0;
    #####: 4140:      double SIQ=0;
    #####: 4141:      double SIU=0;
    #####: 4142:      double SQQ=0;
    #####: 4143:      double SUU=0;
    #####: 4144:      double SQU=0;
        -: 4145:
    #####: 4146:      double SI=0;
    #####: 4147:      double SQ=0;
    #####: 4148:      double SU=0;
        -: 4149:
        -: 4150:      int l1,m;
        -: 4151:
    #####: 4152:      for (l1=0;l1<ndata;l1++) {
    #####: 4153:        long ri1=htmp[l1].rg-globalBeginRing;
    #####: 4154:        long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
    #####: 4155:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 4156:
    #####: 4157:          double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 4158:                                            -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 4159:          double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 4160:                                            +dpsisi[htmp[l1].ib]*htmp[l1].co);
        -: 4161:
    #####: 4162:          double gg2=gain[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 4163:
    #####: 4164:          double sig_corr = htmp[l1].sig*gg2-htmp[l1].fsl;
    #####: 4165:          if (REMHDIP==0) sig_corr-=htmp[l1].dip;
    #####: 4166:          else sig_corr-=htmp[l1].freefree;
        -: 4167:
    #####: 4168:	  sig_corr-=htmp[l1].corr_nl+htmp[l1].corr_cnn;
        -: 4169:
    #####: 4170:          sig_corr-=x3[iri1];
        -: 4171:
        -: 4172:          // ATTENTION GAINSTEP EST FORCE A 1
    #####: 4173:          sig_corr-=x3[newnr[nbolo]+htmp[l1].ib]*htmp[l1].model;
        -: 4174:
    #####: 4175:          if (nmatco!=0) {
    #####: 4176:            sig_corr -=htmp[l1].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib];
        -: 4177:          }
    #####: 4178:          if (nmatdust!=0) {
    #####: 4179:            sig_corr -=htmp[l1].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib];
        -: 4180:          }
    #####: 4181:          if (nfreefree!=0) {
    #####: 4182:            sig_corr -=htmp[l1].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib];
        -: 4183:          }
    #####: 4184:          for (m=0;m<npixbeam;m++)  {
    #####: 4185:            sig_corr -= htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -: 4186:          }
    #####: 4187:          SI +=htmp[l1].w*sig_corr;
    #####: 4188:          SQ +=htmp[l1].w*CO1*sig_corr;
    #####: 4189:          SU +=htmp[l1].w*SI1*sig_corr;
        -: 4190:
    #####: 4191:          SII +=htmp[l1].w;
    #####: 4192:          SIQ +=htmp[l1].w*CO1;
    #####: 4193:          SIU +=htmp[l1].w*SI1;
    #####: 4194:          SQQ +=htmp[l1].w*CO1*CO1;
    #####: 4195:          SQU +=htmp[l1].w*CO1*SI1;
    #####: 4196:          SUU +=htmp[l1].w*SI1*SI1;
        -: 4197:        }
        -: 4198:      }
        -: 4199:
    #####: 4200:      if (Param->OUT_NOPOL[0]%2==0) {
    #####: 4201:        double cond=cond_3_3_thres(SII,SIQ,SIU,
        -: 4202:                                   SIQ,SQQ,SQU,
        -: 4203:                                   SIU,SQU,SUU);
        -: 4204:
    #####: 4205:        if (cond<Param->seuilcond) {
    #####: 4206:          solvemap(&SI,&SQ,&SU,SII,SIQ,SIU,SQQ,SQU,SUU);
        -: 4207:
    #####: 4208:          for (l1=0;l1<ndata;l1++) {
    #####: 4209:            long ri1=htmp[l1].rg-globalBeginRing;
    #####: 4210:            long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
    #####: 4211:            if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####: 4212:              double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 4213:                                                -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 4214:              double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 4215:                                                +dpsisi[htmp[l1].ib]*htmp[l1].co);
        -: 4216:
        -: 4217:              long iii,jjj;
    #####: 4218:              double gg2=lgain[htmp[l1].ib];
        -: 4219:
    #####: 4220:              double sig_corr = (htmp[l1].sig*gg2-htmp[l1].fsl);
    #####: 4221:              if (REMHDIP==0) sig_corr-=htmp[l1].dip;
    #####: 4222:              else sig_corr-=htmp[l1].freefree;
        -: 4223:
    #####: 4224:              sig_corr-=x3[iri1];
        -: 4225:
        -: 4226:              // ATTENTION GAINSTEP EST FORCE A 1
    #####: 4227:              sig_corr-=x3[newnr[nbolo]+htmp[l1].ib]*htmp[l1].model;
        -: 4228:
    #####: 4229:              if (nmatco!=0) {
    #####: 4230:                sig_corr -=htmp[l1].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib];
        -: 4231:              }
    #####: 4232:              if (nmatdust!=0) {
    #####: 4233:                sig_corr -=htmp[l1].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib];
        -: 4234:              }
    #####: 4235:              if (nfreefree!=0) {
    #####: 4236:                sig_corr -=htmp[l1].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib];
        -: 4237:              }
    #####: 4238:              for (m=0;m<npixbeam;m++)  {
    #####: 4239:                sig_corr -= htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -: 4240:              }
        -: 4241:
    #####: 4242:              double residu=sig_corr-SI-CO1*SQ-SI1*SU;
        -: 4243:
    #####: 4244:	      vec[htmp[l1].ib][nadufit[htmp[l1].ib]]+=residu*htmp[l1].adu/1000.*htmp[l1].w;
    #####: 4245:	      if (ADURGSTEP[htmp[l1].ib]>2) {
    #####: 4246:		for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4247:		  for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
    #####: 4248:		    int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
    #####: 4249:		      vec[htmp[l1].ib][l_idx]+=residu*htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 4250:			*rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 4251:		  }
        -: 4252:		}
        -: 4253:	      }
        -: 4254:	      else {
    #####: 4255:		for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4256:		  vec[htmp[l1].ib][iii]+=residu*htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].w;
        -: 4257:		}
        -: 4258:	      }
    #####: 4259:              vec[htmp[l1].ib][(nadufit[htmp[l1].ib]+1)+iri1-newnr[htmp[l1].ib]]+=residu*htmp[l1].w;
    #####: 4260:              v1[iri1]+=htmp[l1].w;
        -: 4261:
    #####: 4262:	      mat2[htmp[l1].ib][nadufit[htmp[l1].ib]+rgord[htmp[l1].ib][ri1]*(nadufit[htmp[l1].ib]+1)]
    #####: 4263:		+=htmp[l1].adu/1000.*htmp[l1].w;
        -: 4264:
    #####: 4265:	      mat1[htmp[l1].ib][nadufit[htmp[l1].ib]+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]
    #####: 4266:		+=htmp[l1].w*htmp[l1].adu/1000.*htmp[l1].adu/1000.;
        -: 4267:
    #####: 4268:	      if (ADURGSTEP[htmp[l1].ib]>2) {
    #####: 4269:		for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4270:		  for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
    #####: 4271:		    int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
    #####: 4272:		    mat2[htmp[l1].ib][l_idx+rgord[htmp[l1].ib][ri1]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4273:		      htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 4274:		      rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 4275:
    #####: 4276:		    mat1[htmp[l1].ib][l_idx+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4277:		      htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 4278:		      rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].adu/1000.*htmp[l1].w;
    #####: 4279:		    mat1[htmp[l1].ib][nadufit[htmp[l1].ib]+l_idx*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4280:		      htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 4281:		      rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].adu/1000.*htmp[l1].w;
        -: 4282:
        -: 4283:		    int iii2,jjj2;
    #####: 4284:		    for (iii2=htmp[l1].istart;iii2<=htmp[l1].iend;iii2++) {
    #####: 4285:		      for (jjj2=rg_start[htmp[l1].ib][htmp[l1].rg];jjj2<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj2++) {
    #####: 4286:			int l_idx2=jjj2+ADURGSTEP[htmp[l1].ib]*iii2;
        -: 4287:
    #####: 4288:			mat1[htmp[l1].ib][l_idx+l_idx2*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4289:			  htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 4290:			  *rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]
    #####: 4291:			  *htmp[l1].vspline[iii2-htmp[l1].istart]
    #####: 4292:			  *rg_vals[htmp[l1].ib][jjj2-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 4293:		      }
        -: 4294:		    }
        -: 4295:		  }
        -: 4296:		}
        -: 4297:	      }
        -: 4298:	      else {
        -: 4299:
    #####: 4300:		for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4301:		  mat2[htmp[l1].ib][iii+rgord[htmp[l1].ib][ri1]*(nadufit[htmp[l1].ib]+1)]+=htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].w;
        -: 4302:
    #####: 4303:		  mat1[htmp[l1].ib][iii+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4304:		    htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].adu/1000.*htmp[l1].w;
    #####: 4305:		  mat1[htmp[l1].ib][nadufit[htmp[l1].ib]+iii*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4306:		    htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].adu/1000.*htmp[l1].w;
        -: 4307:
    #####: 4308:		  for (jjj=htmp[l1].istart;jjj<=htmp[l1].iend;jjj++) {
    #####: 4309:		    mat1[htmp[l1].ib][iii+jjj*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4310:		      htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 4311:		      *htmp[l1].vspline[jjj-htmp[l1].istart]*htmp[l1].w;
        -: 4312:		  }
        -: 4313:		}
        -: 4314:	      }
        -: 4315:	    }
        -: 4316:          }
        -: 4317:        }
        -: 4318:      } // END POL
        -: 4319:      else {
    #####: 4320:        if (SII>0) {
    #####: 4321:          SI/=SII;
    #####: 4322:          for (l1=0;l1<ndata;l1++) {
    #####: 4323:            long ri1=htmp[l1].rg-globalBeginRing;
    #####: 4324:            long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
    #####: 4325:            if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 4326:
        -: 4327:              long iii,jjj;
    #####: 4328:              double gg2=lgain[htmp[l1].ib];
        -: 4329:
    #####: 4330:              double sig_corr = (htmp[l1].sig*gg2-htmp[l1].fsl);
    #####: 4331:              if (REMHDIP==0) sig_corr-=htmp[l1].dip;
    #####: 4332:              else sig_corr-=htmp[l1].freefree;
        -: 4333:
    #####: 4334:              sig_corr-=x3[iri1];
        -: 4335:
        -: 4336:              // ATTENTION GAINSTEP EST FORCE A 1
    #####: 4337:              sig_corr-=x3[newnr[nbolo]+htmp[l1].ib]*htmp[l1].model;
        -: 4338:
    #####: 4339:              if (nmatco!=0) {
    #####: 4340:                sig_corr -=htmp[l1].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib];
        -: 4341:              }
    #####: 4342:              if (nmatdust!=0) {
    #####: 4343:                sig_corr -=htmp[l1].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib];
        -: 4344:              }
    #####: 4345:              if (nfreefree!=0) {
    #####: 4346:                sig_corr -=htmp[l1].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib];
        -: 4347:              }
    #####: 4348:              for (m=0;m<npixbeam;m++)  {
    #####: 4349:                sig_corr -= htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -: 4350:              }
        -: 4351:
    #####: 4352:              double residu=sig_corr-SI;
        -: 4353:
    #####: 4354:	      vec[htmp[l1].ib][nadufit[htmp[l1].ib]]+=residu*htmp[l1].adu/1000.*htmp[l1].w;
    #####: 4355:	      if (ADURGSTEP[htmp[l1].ib]>2) {
    #####: 4356:		for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4357:		  for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
    #####: 4358:		    int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
    #####: 4359:		      vec[htmp[l1].ib][l_idx]+=residu*htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 4360:			*rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 4361:		  }
        -: 4362:}
        -: 4363:	      }
        -: 4364:	      else {
    #####: 4365:		for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4366:		  vec[htmp[l1].ib][iii]+=residu*htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].w;
        -: 4367:		}
        -: 4368:	      }
    #####: 4369:              vec[htmp[l1].ib][iri1-newnr[htmp[l1].ib]]+=residu*htmp[l1].w;
    #####: 4370:              v1[iri1]+=htmp[l1].w;
        -: 4371:
    #####: 4372:	      mat2[htmp[l1].ib][nadufit[htmp[l1].ib]+rgord[htmp[l1].ib][ri1]*(nadufit[htmp[l1].ib]+1)]+=htmp[l1].adu/1000.*htmp[l1].w;
    #####: 4373:	      mat1[htmp[l1].ib][nadufit[htmp[l1].ib]+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]
    #####: 4374:		+=htmp[l1].w*htmp[l1].adu/1000.*htmp[l1].adu/1000.;
        -: 4375:
    #####: 4376:	      if (ADURGSTEP[htmp[l1].ib]>2) {
    #####: 4377:		for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4378:		  for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
    #####: 4379:		    int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
    #####: 4380:		      mat2[htmp[l1].ib][l_idx+rgord[htmp[l1].ib][ri1]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4381:			htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 4382:			rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 4383:
    #####: 4384:		      mat1[htmp[l1].ib][l_idx+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4385:			htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 4386:			rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].adu/1000*htmp[l1].w;
    #####: 4387:		      mat1[htmp[l1].ib][nadufit[htmp[l1].ib]+l_idx*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4388:			htmp[l1].vspline[iii-htmp[l1].istart]*
    #####: 4389:			rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].adu/1000.*htmp[l1].w;
        -: 4390:
        -: 4391:		      int iii2,jjj2;
    #####: 4392:		      for (iii2=htmp[l1].istart;iii2<=htmp[l1].iend;iii2++) {
    #####: 4393:			for (jjj2=rg_start[htmp[l1].ib][htmp[l1].rg];jjj2<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj2++) {
    #####: 4394:			  int l_idx2=jjj2+ADURGSTEP[htmp[l1].ib]*iii2;
        -: 4395:
    #####: 4396:			    mat1[htmp[l1].ib][l_idx+l_idx2*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4397:			      htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 4398:			      *rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]
    #####: 4399:			      *htmp[l1].vspline[iii2-htmp[l1].istart]
    #####: 4400:			      *rg_vals[htmp[l1].ib][jjj2-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*htmp[l1].w;
        -: 4401:			  }
        -: 4402:			}
        -: 4403:		    }
        -: 4404:		}
        -: 4405:	      }
        -: 4406:	      else {
    #####: 4407:		for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4408:		  mat2[htmp[l1].ib][iii+rgord[htmp[l1].ib][ri1]*nadufit[htmp[l1].ib]]
    #####: 4409:		    +=htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].w;
    #####: 4410:		  mat1[htmp[l1].ib][iii+nadufit[htmp[l1].ib]*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4411:		    htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].adu/1000*htmp[l1].w;
    #####: 4412:		  mat1[htmp[l1].ib][nadufit[htmp[l1].ib]+iii*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4413:		    htmp[l1].vspline[iii-htmp[l1].istart]*htmp[l1].adu/1000*htmp[l1].w;
        -: 4414:
    #####: 4415:		  for (jjj=htmp[l1].istart;jjj<=htmp[l1].iend;jjj++) {
    #####: 4416:		    mat1[htmp[l1].ib][iii+jjj*(nadufit[htmp[l1].ib]+1)]+=
    #####: 4417:		      htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 4418:		      *htmp[l1].vspline[jjj-htmp[l1].istart]*htmp[l1].w;
        -: 4419:		  }
        -: 4420:		}
        -: 4421:	      }
        -: 4422:	    }
        -: 4423:          }
        -: 4424:        }
        -: 4425:      }
        -: 4426:    }
        -: 4427:  }
        -: 4428:
        -: 4429:
        -: 4430:#ifdef OPTIMPI
        -: 4431:  {
    #####: 4432:    for (i=0;i<nbolo;i++) {
    #####: 4433:      double *lb = (double *) malloc(sizeof(double)*((nadufit[i]+1)+newnr[i+1]-newnr[i]));
    #####: 4434:      MPI_Reduce(vec[i],lb,((nadufit[i]+1)+newnr[i+1]-newnr[i]),MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 4435:
    #####: 4436:      memcpy(vec[i],lb,sizeof(double)*((nadufit[i]+1)+newnr[i+1]-newnr[i]));
    #####: 4437:      free(lb);
        -: 4438:    }
    #####: 4439:    double *lb = (double *) malloc(sizeof(double)*(newnr[nbolo]));
    #####: 4440:    MPI_Reduce(v1,lb,(newnr[nbolo]),MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 4441:
    #####: 4442:    memcpy(v1,lb,sizeof(double)*(newnr[nbolo]));
    #####: 4443:    free(lb);
        -: 4444:  }
        -: 4445:#else
        -: 4446:
        -: 4447:  if (rank==0) {
        -: 4448:    for (i=0;i<nbolo;i++) {
        -: 4449:      double *lb = (double *) malloc(sizeof(double)*((nadufit[i]+1)+newnr[i+1]-newnr[i]));
        -: 4450:
        -: 4451:      for (rrk=1;rrk<mpi_size;rrk++) {
        -: 4452:	MPI_Recv(lb,sizeof(double)*((nadufit[i]+1)+newnr[i+1]-newnr[i]), MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
        -: 4453:	for (l=0;l<(nadufit[i]+1)+newnr[i+1]-newnr[i];l++) vec[i][l]+=lb[l];
        -: 4454:      }
        -: 4455:      free(lb);
        -: 4456:    }
        -: 4457:    double *lb = (double *) malloc(sizeof(double)*((newnr[nbolo])));
        -: 4458:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 4459:      MPI_Recv(lb,sizeof(double)*(newnr[nbolo]), MPI_BYTE, rrk,1032, MPI_COMM_WORLD,&statu);
        -: 4460:      for (l=0;l<newnr[nbolo];l++) v1[l]+=lb[l];
        -: 4461:    }
        -: 4462:    free(lb);
        -: 4463:  }
        -: 4464:  else {
        -: 4465:    for (i=0;i<nbolo;i++) {
        -: 4466:      MPI_Send(vec[i],sizeof(double)*((nadufit[i]+1)+newnr[i+1]-newnr[i]), MPI_BYTE, 0, 1031, MPI_COMM_WORLD);
        -: 4467:    }
        -: 4468:    MPI_Send(v1,sizeof(double)*(newnr[nbolo]), MPI_BYTE, 0, 1032, MPI_COMM_WORLD);
        -: 4469:  }
        -: 4470:#endif
    #####: 4471:  if (rank==0) {
    #####: 4472:    for (i=0;i<nbolo;i++) {
    #####: 4473:      double *lb = (double *) malloc(sizeof(double)*((nadufit[i]+1)*(nadufit[i]+1)));
    #####: 4474:      for (rrk=1;rrk<mpi_size;rrk++) {
    #####: 4475:	MPI_Recv(lb,sizeof(double)*((nadufit[i]+1)*(nadufit[i]+1)), MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
    #####: 4476:	for (l=0;l<(nadufit[i]+1)*(nadufit[i]+1);l++) mat1[i][l]+=lb[l];
        -: 4477:      }
    #####: 4478:      free(lb);
        -: 4479:    }
        -: 4480:  }
        -: 4481:  else {
    #####: 4482:    for (i=0;i<nbolo;i++) {
    #####: 4483:      MPI_Send(mat1[i],sizeof(double)*((nadufit[i]+1)*(nadufit[i]+1)), MPI_BYTE, 0, 1031, MPI_COMM_WORLD);
        -: 4484:    }
        -: 4485:  }
        -: 4486:
    #####: 4487:  for (i=0;i<nbolo;i++) {
    #####: 4488:    if (rank==0) {
    #####: 4489:      double *lb = (double *) malloc(sizeof(double)*((newnr[i+1]-newnr[i])*(nadufit[i]+1)));
    #####: 4490:      for (rrk=1;rrk<mpi_size;rrk++) {
    #####: 4491:        MPI_Recv(lb,sizeof(double)*((newnr[i+1]-newnr[i])*(nadufit[i]+1)), MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
    #####: 4492:        for (l=0;l<((newnr[i+1]-newnr[i])*(nadufit[i]+1));l++) mat2[i][l]+=lb[l];
        -: 4493:      }
    #####: 4494:      free(lb);
        -: 4495:    }
        -: 4496:    else {
    #####: 4497:      MPI_Send(mat2[i],sizeof(double)*((newnr[i+1]-newnr[i])*(nadufit[i]+1)), MPI_BYTE, 0, 1031, MPI_COMM_WORLD);
        -: 4498:    }
        -: 4499:  }
        -: 4500:
        -: 4501:/*==============================================================================
        -: 4502:  AND NOW INVERT THE MATRIX
        -: 4503:  ==============================================================================*/
    #####: 4504:  if (rank==0) {
    #####: 4505:    for (i=0;i<nbolo;i++) {
        -: 4506:
    #####: 4507:      for (j=newnr[i];j<newnr[i];j++) {
    #####: 4508:        for (k=0;k<nadufit[i]+1;k++) {
    #####: 4509:          vec[i][k]-=mat2[i][k+(j-newnr[i])*(nadufit[i]+1)]*vec[i][(nadufit[i]+1)+j]/v1[j];
        -: 4510:        }
        -: 4511:      }
        -: 4512:
    #####: 4513:      for (j=newnr[i];j<newnr[i];j++) {
    #####: 4514:        for (k=0;k<(nadufit[i]+1);k++) {
    #####: 4515:          for (l=0;l<(nadufit[i]+1);l++) {
    #####: 4516:            mat1[i][k+l*(nadufit[i]+1)]-=mat2[i][k+(j-newnr[i])*(nadufit[i]+1)]
    #####: 4517:	      *mat2[i][l+(j-newnr[i])*(nadufit[i]+1)]/v1[j];
        -: 4518:          }
        -: 4519:        }
        -: 4520:      }
        -: 4521:#if 0
        -: 4522:      char path[512];
        -: 4523:      sprintf(path,"mat1_%d",i);
        -: 4524:      fp=fopen(path,"w");
        -: 4525:      fwrite(mat1[i],(nadufit[i]+1)*(nadufit[i]+1)*sizeof(double),1,fp);
        -: 4526:      fclose(fp);
        -: 4527:
        -: 4528:      sprintf(path,"vec_%d",i);
        -: 4529:      fp=fopen(path,"w");
        -: 4530:      fwrite(vec[i],(nadufit[i]+1)*sizeof(double),1,fp);
        -: 4531:      fclose(fp);
        -: 4532:      fprintf(stderr,"WRITE MATRIX %d\n",i);
        -: 4533:#endif
        -: 4534:
        -: 4535:#ifdef ADDNADUFITP1
        -: 4536:      for (k=0;k<nadufit[i];k++) {
        -: 4537:	for (j=0;j<nadufit[i];j++) mat1[i][j+k*nadufit[i]]=mat1[i][j+k*(nadufit[i]+1)];
        -: 4538:      }
        -: 4539:
        -: 4540:      lusol(mat1[i],vec[i],(nadufit[i]/*+1*/));
        -: 4541:#else
    #####: 4542:      lusol(mat1[i],vec[i],(nadufit[i]+1));
        -: 4543:#endif
        -: 4544:
        -: 4545:#ifdef TESTFITADU
        -: 4546:      PIOSTRING saveg;
        -: 4547:      sprintf(saveg,"%s_OUTNL",Param->Out_Offset[i]);
        -: 4548:      fprintf(stderr,"Write OUTNL  %lld\n",(long long) (PIOWriteVECT(saveg,vec[i],0,sizeof(PIODOUBLE)*(nadufit[i]+1)))/sizeof(double));
        -: 4549:#endif
        -: 4550:
        -: 4551:#if 0
        -: 4552:      sprintf(path,"vecr_%d",i);
        -: 4553:      fp=fopen(path,"w");
        -: 4554:      fwrite(vec[i],(nadufit[i]+1)*sizeof(double),1,fp);
        -: 4555:      fclose(fp);
        -: 4556:#endif
        -: 4557:    }
        -: 4558:  }
        -: 4559:  /// MODIF
    #####: 4560:  for (i=0;i<nbolo;i++) MPI_Bcast(vec[i],sizeof(double)*(nadufit[i]+1),MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 4561:
    #####: 4562:  memset(outtemp,0,sizeof(double)*320*320*nbolo);
    #####: 4563:  memset(nouttemp,0,sizeof(double)*320*320*nbolo);
        -: 4564:
    #####: 4565:  for (k=0;k<nnbpix;k++) {
    #####: 4566:    long ndata = loc_nhpix[k];
    #####: 4567:    hpix *htmp = loc_hpix[k];
        -: 4568:    int l1;
        -: 4569:
    #####: 4570:    for (l1=0;l1<ndata;l1++) {
    #####: 4571:      long ri1=htmp[l1].rg-globalBeginRing;
    #####: 4572:      if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 4573:	long iii,jjj;
        -: 4574:
        -: 4575:#if 1
        -: 4576:#ifdef ADDNADUFITP1
        -: 4577:	htmp[l1].corr_nl=0
        -: 4578:#else
    #####: 4579:	htmp[l1].corr_nl=vec[htmp[l1].ib][nadufit[htmp[l1].ib]]*htmp[l1].adu/1000.;
        -: 4580:#endif
        -: 4581:
    #####: 4582:	if (ADURGSTEP[htmp[l1].ib]>2) {
    #####: 4583:	  for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4584:	    for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
    #####: 4585:              int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
    #####: 4586:		htmp[l1].corr_nl+=htmp[l1].vspline[iii-htmp[l1].istart]
    #####: 4587:		  *rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg]*vec[htmp[l1].ib][l_idx];
        -: 4588:	    }
        -: 4589:	  }
        -: 4590:	}
        -: 4591:	else {
    #####: 4592:	  for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
    #####: 4593:	    htmp[l1].corr_nl+=htmp[l1].vspline[iii-htmp[l1].istart]*vec[htmp[l1].ib][iii];
        -: 4594:	  }
        -: 4595:	}
        -: 4596:#endif
    #####: 4597:	outtemp[htmp[l1].adu/100+320*(htmp[l1].rg/100)+320*320*htmp[l1].ib]+=htmp[l1].corr_nl;
    #####: 4598:	nouttemp[htmp[l1].adu/100+320*(htmp[l1].rg/100)+320*320*htmp[l1].ib]+=1;
        -: 4599:      }
        -: 4600:    }
        -: 4601:  }
        -: 4602:
    #####: 4603:  if (rank==0) {
    #####: 4604:    double *lb = (double *) malloc(sizeof(double)*320*320*nbolo);
    #####: 4605:    for (rrk=1;rrk<mpi_size;rrk++) {
    #####: 4606:      MPI_Recv(lb,sizeof(double)*320*320*nbolo, MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
    #####: 4607:      for (l=0;l<320*320*nbolo;l++) outtemp[l]+=lb[l];
    #####: 4608:      MPI_Recv(lb,sizeof(double)*320*320*nbolo, MPI_BYTE, rrk,1032, MPI_COMM_WORLD,&statu);
    #####: 4609:      for (l=0;l<320*320*nbolo;l++) nouttemp[l]+=lb[l];
        -: 4610:    }
    #####: 4611:    free(lb);
    #####: 4612:    for (l=0;l<320*320*nbolo;l++) if (nouttemp[l]>0) outtemp[l]/=nouttemp[l];
        -: 4613:  }
        -: 4614:  else {
    #####: 4615:    MPI_Send(outtemp,sizeof(double)*320*320*nbolo, MPI_BYTE, 0, 1031, MPI_COMM_WORLD);
    #####: 4616:    MPI_Send(nouttemp,sizeof(double)*320*320*nbolo, MPI_BYTE, 0, 1032, MPI_COMM_WORLD);
        -: 4617:  }
        -: 4618:
    #####: 4619:  free(lgain);
    #####: 4620:  free(v1);
        -: 4621:
    #####: 4622:  for (i=0;i<nbolo;i++) free(mat2[i]);
    #####: 4623:  free(mat2);
    #####: 4624:  for (i=0;i<nbolo;i++) free(mat1[i]);
    #####: 4625:  free(mat1);
    #####: 4626:  for (i=0;i<nbolo;i++) free(vec[i]);
    #####: 4627:  free(vec);
    #####: 4628: }
        -: 4629:
       40: 4630:void minimize_gain_nopol(double *ix2,double *gaingi)
        -: 4631:{
        -: 4632:  MPI_Status statu;
        -: 4633:  long i,rrk,j,k,l1,l2,ib;
       40: 4634:  int itermax = (NUMBEROFITER);
        -: 4635:  int iter;
        -: 4636:  double  delta_new, delta_old, beta;
       40: 4637:  double  alpha=1.0; // get rid of gcc "maybe-uninitialized" warning depending on optimsation level
        -: 4638:
        -: 4639:  PIOLONG GAINSTEP2;
        -: 4640:  int rank;
        -: 4641:  int size;
        -: 4642:  int mpi_size;
        -: 4643:  int rank_size;
       40: 4644:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
       40: 4645:  rank=rank_size;
       40: 4646:  MPI_Comm_size(MPI_COMM_WORLD,&size);
       40: 4647:  mpi_size=size;
        -: 4648:
       40: 4649:  GAINSTEP2=GAINSTEP;
        -: 4650:
       40: 4651:  nmatres=newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+nfreefree;
        -: 4652:
       40: 4653:  if (rank==0) {
       10: 4654:    fprintf(stderr,"==============================\n\nminimize_gain_nopol(): ITERATION NOPOL %ld/%d %ld \n\n==============================\n",itbogo,Param->NITT,(long) GAINSTEP);
       10: 4655:    fprintf(stderr,"GAIN ");
       10: 4656:    for (i=0;i<nbolo;i++) fprintf(stderr,"%lg ",gaingi[i*GAINSTEP]);
       10: 4657:    fprintf(stderr,"\n");
       10: 4658:    if (GAINSTEP>1) {
    #####: 4659:      fprintf(stderr,"...\nGAIN ");
    #####: 4660:      for (i=0;i<nbolo;i++) fprintf(stderr,"%lg ",gaingi[i*GAINSTEP+(GAINSTEP-1)]);
    #####: 4661:      fprintf(stderr,"\n");
        -: 4662:    }
        -: 4663:  }
       40: 4664:  if (itbogo==0) delta0=0;
       40: 4665:  MPI_Barrier(MPI_COMM_WORLD);
        -: 4666:
        -: 4667:  struct timeval tp1,tp2;
       40: 4668:  gettimeofday(&tp1,NULL);
        -: 4669:
        -: 4670:
       40: 4671:  iter = 0;
       40: 4672:  memset(b2  ,0,nmatres*sizeof (double));
       40: 4673:  memset(d2  ,0,nmatres*sizeof (double));
       40: 4674:  memset(q2  ,0,nmatres*sizeof (double));
       40: 4675:  memset(r2  ,0,nmatres*sizeof (double));
       40: 4676:  memset(s2  ,0,nmatres*sizeof (double));
       40: 4677:  memset(hit2,0,nmatres*sizeof (double));
        -: 4678:
        -: 4679:  //==========================================
        -: 4680:  //=  Compute second member
        -: 4681:  //=
        -: 4682:  //=
        -: 4683:  long l,m;
        -: 4684:
        -: 4685:  ////// BUILD B2
        -: 4686:  //GetProcMem(&vmem,&phymem);
        -: 4687:  //if (rank==0) fprintf(stderr,"Rank: %ld Line=%d MEM %.1lf[%.1lf]MB\n",
        -: 4688:  //                  (long) rank, __LINE__,
        -: 4689:  //                  (double) vmem/1024./1024.,
        -: 4690:  //                  (double) phymem/1024./1024.);
        -: 4691:
       40: 4692:  int ptest=0;
503316520: 4693:  for (k=0;k<nnbpix;k++)  {
        -: 4694:    //long imat=the_stat_pix[k];
503316480: 4695:    long ndata = loc_nhpix[k];
503316480: 4696:    hpix *htmp = loc_hpix[k];
        -: 4697:
503316480: 4698:    II[k]=0;
        -: 4699:
        -: 4700:
505280330: 4701:    for (l1=0;l1<ndata;l1++) {
  1963850: 4702:      long ri1=htmp[l1].rg-globalBeginRing;
  1963850: 4703:      if (flg_rg[htmp[l1].ib][ri1]!=0) {
  1963850: 4704:        II[k]+=htmp[l1].w;
        -: 4705:      }
        -: 4706:    }
503316480: 4707:    if (II[k]==0&&flgpix[k]>0) fprintf(stderr,"FLAG PROBLEM\n");
        -: 4708:
503316480: 4709:    if (ndata>0&&flgpix[k]>0) {
        -: 4710:
   194870: 4711:      double SI=0;
        -: 4712:
        -: 4713:#ifdef USEDII
   194870: 4714:      memset(dii ,0,sizeof(double)*nbolo*GAINSTEP);
        -: 4715:#endif
   194870: 4716:      memset(dcoi+k*nbolo,0,sizeof(double)*nbolo);
   194870: 4717:      memset(dfri+k*nbolo,0,sizeof(double)*nbolo);
   194870: 4718:      memset(dthetai+k*nbolo,0,sizeof(double)*nbolo);
   194870: 4719:      memset(ddusti+k*nbolo,0,sizeof(double)*nbolo);
   194870: 4720:      memset(dpixi+k*nbolo*npixbeam,0,sizeof(double)*nbolo*npixbeam);
        -: 4721:
   892810: 4722:      for (l1=0;l1<ndata;l1++) {
   697940: 4723:        long ri1=htmp[l1].rg-globalBeginRing;
        -: 4724:
   697940: 4725:        double g1=gaingi[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 4726:
   697940: 4727:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 4728:
   697940: 4729:          htmp[l1].wp=0;
        -: 4730:          //htmp[l1].thsig=0;
        -: 4731:
   697940: 4732:          if (REMHDIP==0) SI+=htmp[l1].w*(htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].dip-htmp[l1].corr_nl-htmp[l1].corr_cnn);
   697940: 4733:          else SI+=htmp[l1].w*(htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].freefree-htmp[l1].corr_nl-htmp[l1].corr_cnn);
        -: 4734:
        -: 4735:#ifdef USEDII
   697940: 4736:          dii[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].dip;
        -: 4737:#endif
        -: 4738:
   697940: 4739:          if (nmatco>0) {
   697940: 4740:            dcoi[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].comap;
        -: 4741:          }
   697940: 4742:          if (nmatdust>0) {
   697940: 4743:            ddusti[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].dustmap;
        -: 4744:          }
   697940: 4745:          if (nfreefree>0) {
    #####: 4746:            dfri[htmp[l1].ib+k*nbolo] += htmp[l1].w*htmp[l1].freefree;
        -: 4747:          }
        -: 4748:
   697940: 4749:          if (ittt>0) {
  6281460: 4750:            for (m=0;m<npixbeam;m++)  {
  5583520: 4751:	      dpixi[nbolo*m+htmp[l1].ib+k*nbolo*npixbeam] += htmp[l1].w*htmp[l1].listofpix[m];
  5583520: 4752:	      if (isnan(dpixi[nbolo*m+htmp[l1].ib+k*nbolo*npixbeam])) {
    #####: 4753:		fprintf(stderr,"v %d %ld %lf\n",__LINE__,m,htmp[l1].listofpix[m]);
    #####: 4754:		exit(0);
        -: 4755:	      }
        -: 4756:            }
        -: 4757:          }
        -: 4758:        }
        -: 4759:      }
   194870: 4760:      SI/=II[k];
   194870: 4761:      SSI[k]=SI;
        -: 4762:
   974350: 4763:      for (ib=0;ib<nbolo;ib++) {
        -: 4764:
        -: 4765:#ifdef USEDII
  1558960: 4766:        for (j=0;j<GAINSTEP;j++) {
   779480: 4767:          dii[j+ib*GAINSTEP]=dii[j+ib*GAINSTEP]/II[k];
        -: 4768:        }
        -: 4769:#endif
        -: 4770:
   779480: 4771:        if (nmatco>0) {
   779480: 4772:          dcoi[ib+k*nbolo]=dcoi[ib+k*nbolo]/II[k];
        -: 4773:        }
   779480: 4774:        if (nmatdust>0) {
   779480: 4775:          ddusti[ib+k*nbolo]=ddusti[ib+k*nbolo]/II[k];
        -: 4776:        }
   779480: 4777:        if (nfreefree>0) {
    #####: 4778:          dfri[ib+k*nbolo]=dfri[ib+k*nbolo]/II[k];
        -: 4779:        }
        -: 4780:
   779480: 4781:        if (ittt>0) {
  7015320: 4782:          for (m=0;m<npixbeam;m++)  {
  6235840: 4783:	    dpixi[ib+m*nbolo+k*nbolo*npixbeam]=dpixi[ib+m*nbolo+k*nbolo*npixbeam]/II[k];
        -: 4784:          }
        -: 4785:        }
        -: 4786:      }
        -: 4787:
   892810: 4788:      for (l1=0;l1<ndata;l1++) {
   697940: 4789:	htmp[l1].vi=UNSEENPIX;
   697940: 4790:        long ri1=htmp[l1].rg-globalBeginRing;
   697940: 4791:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
   697940: 4792:          htmp[l1].vi=htmp[l1].w/II[k];
        -: 4793:#ifndef USEDII
        -: 4794:          htmp[l1].lvi=htmp[l1].w*htmp[l1].dip/II[k];
        -: 4795:#endif
        -: 4796:        }
        -: 4797:      }
   892810: 4798:      for (l1=0;l1<ndata;l1++) {
   697940: 4799:        long ri1=htmp[l1].rg-globalBeginRing;
        -: 4800:
   697940: 4801:        double g1=gaingi[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 4802:
   697940: 4803:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
   697940: 4804:          double divi=NEP_tab[htmp[l1].ib]*htmp[l1].hit*g1;
   697940: 4805:          divi=divi*divi;
        -: 4806:
        -: 4807:
   697940: 4808:          if (divi==0) htmp[l1].wp=0;
   697940: 4809:          else htmp[l1].wp=1/divi;
        -: 4810:
   697940: 4811:          if (itbogo==0) normaoff+=NEP_tab[htmp[l1].ib]*htmp[l1].hit;
        -: 4812:
        -: 4813:        }
        -: 4814:      }
        -: 4815:
        -: 4816:
        -: 4817:
   892810: 4818:      for (l1=0;l1<ndata;l1++) {
   697940: 4819:        long ri1=htmp[l1].rg-globalBeginRing;
   697940: 4820:        long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
        -: 4821:
   697940: 4822:        double g1=gaingi[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 4823:
   697940: 4824:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
   697940: 4825:          double ww=htmp[l1].wp;
   697940: 4826:          double tmp=((htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].corr_nl-htmp[l1].corr_cnn)-(SI));
   697940: 4827:          if (REMHDIP==0) tmp-=htmp[l1].dip;
   697940: 4828:          else tmp-=htmp[l1].freefree;
        -: 4829:
        -: 4830:          long l3;
        -: 4831:#ifndef USEDII
        -: 4832:          memset(cdip,0,GAINSTEP*nbolo*sizeof(double));
        -: 4833:#endif
        -: 4834:
  3262860: 4835:          for (l3=0;l3<ndata;l3++) {
  2564920: 4836:            long ri3=htmp[l3].rg-globalBeginRing;
  2564920: 4837:            if (flg_rg[htmp[l3].ib][ri3]!=0) {
  2564920: 4838:              long ir3=rgord[htmp[l3].ib][ri3]+newnr[htmp[l3].ib];
  2564920: 4839:              ctmp[ir3]=-htmp[l3].vi;
        -: 4840:#ifndef USEDII
        -: 4841:              cdip[htmp[l3].ib*GAINSTEP+htmp[l3].gi]-=htmp[l3].lvi;
        -: 4842:#endif
        -: 4843:            }
        -: 4844:          }
   697940: 4845:          ctmp[iri1]+=1;
        -: 4846:
        -: 4847:#ifdef USEDII
  3489700: 4848:          for (ib=0;ib<nbolo;ib++)
  5583520: 4849:            for (j=0;j<GAINSTEP;j++) {
  2791760: 4850:              cdip[ib*GAINSTEP+j]=-dii[j+ib*GAINSTEP];
        -: 4851:            }
        -: 4852:#endif
   697940: 4853:          cdip[htmp[l1].ib*GAINSTEP+htmp[l1].gi]+=htmp[l1].dip; 
        -: 4854:
   697940: 4855:          for (ib=0;ib<nbolo;ib++) cco[ib]=-dcoi[ib+k*nbolo];
   697940: 4856:          cco[htmp[l1].ib]+=htmp[l1].comap;
        -: 4857:
   697940: 4858:          for (ib=0;ib<nbolo;ib++) cdust[ib]=-ddusti[ib+k*nbolo];
   697940: 4859:          cdust[htmp[l1].ib]+=htmp[l1].dustmap;
        -: 4860:
   697940: 4861:          for (ib=0;ib<nbolo;ib++) ccfree[ib]=-dfri[ib+k*nbolo];
   697940: 4862:          ccfree[htmp[l1].ib]+=htmp[l1].freefree;
        -: 4863:
  6281460: 4864:          for (m=0;m<npixbeam;m++) {
  5583520: 4865:	    for (ib=0;ib<nbolo;ib++) cpix[ib+m*nbolo]=-dpixi[ib+m*nbolo+k*nbolo*npixbeam];
  5583520: 4866:	    cpix[htmp[l1].ib+m*nbolo]+=htmp[l1].listofpix[m];
        -: 4867:          }
        -: 4868:
        -: 4869:          long ir;
        -: 4870:          /////////////////  OFFSET
        -: 4871:
  3262860: 4872:          for (l2=0;l2<ndata;l2++) {
  2564920: 4873:            long ri2=htmp[l2].rg-globalBeginRing;
  2564920: 4874:            if (flg_rg[htmp[l2].ib][ri2]!=0) {
  2564920: 4875:              long ir=rgord[htmp[l2].ib][ri2]+newnr[htmp[l2].ib];
  2564920: 4876:              b2[ir]+=ww*tmp*ctmp[ir];
  2564920: 4877:              hit2[ir]+=ww*ctmp[ir]*ctmp[ir];
        -: 4878:#ifndef USEDII
        -: 4879:              b2[newnr[nbolo]+htmp[l2].ib*GAINSTEP+htmp[l2].gi]+=ww*tmp*cdip[htmp[l2].ib*GAINSTEP+htmp[l2].gi];
        -: 4880:              hit2[newnr[nbolo]+htmp[l2].ib*GAINSTEP+htmp[l2].gi]+=ww*cdip[htmp[l2].ib*GAINSTEP+htmp[l2].gi]
        -: 4881:                *cdip[htmp[l2].ib*GAINSTEP+htmp[l2].gi];
        -: 4882:#endif
        -: 4883:            }
        -: 4884:          }
        -: 4885:
        -: 4886:
        -: 4887:          /////////////////  DIPOLE FIT
        -: 4888:
  3489700: 4889:          for (ir=0;ir<nbolo;ir++) {
        -: 4890:
        -: 4891:#ifdef USEDII
        -: 4892:
  5583520: 4893:            for (j=0;j<GAINSTEP;j++) {
  2791760: 4894:              b2[newnr[nbolo]+ir*GAINSTEP+j]+=ww*tmp*cdip[ir*GAINSTEP+j];
  2791760: 4895:              hit2[newnr[nbolo]+ir*GAINSTEP+j]+=ww*cdip[ir*GAINSTEP+j]*cdip[ir*GAINSTEP+j];
        -: 4896:            }
        -: 4897:
        -: 4898:#endif
        -: 4899:
        -: 4900:            ///////////// CO
  2791760: 4901:            if (nmatco>0) {
  2791760: 4902:              b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ir]+=ww*tmp*cco[ir];
  2791760: 4903:              hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ir]+=ww*cco[ir]*cco[ir];
        -: 4904:            }
        -: 4905:
        -: 4906:            ///////////// DUST
        -: 4907:
  2791760: 4908:            if (nmatdust>0) {
  2791760: 4909:              b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ir]+=ww*tmp*cdust[ir];
  2791760: 4910:              hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ir]+=ww*cdust[ir]*cdust[ir];
        -: 4911:            }
        -: 4912:
        -: 4913:            ///////////// FREEFREE
        -: 4914:
  2791760: 4915:            if (nfreefree>0) {
    #####: 4916:              b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ir]+=ww*tmp*ccfree[ir];
    #####: 4917:              hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ir]+=ww*ccfree[ir]*ccfree[ir];
        -: 4918:            }
        -: 4919:
        -: 4920:            ////////// PIXBEAM
 25125840: 4921:            for (j=0;j<npixbeam;j++) {
 22334080: 4922:	      if (NOMOREFITTED!=DOCNN[j]||DOCNN[j]==0) {
 14796328: 4923:		b2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+ir]+=ww*tmp*cpix[ir+j*nbolo];
        -: 4924:	      }
 22334080: 4925:	      hit2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+ir]+=ww*cpix[ir+j*nbolo]*cpix[ir+j*nbolo];
        -: 4926:            }
        -: 4927:          }
        -: 4928:        }
        -: 4929:      }
        -: 4930:    }
        -: 4931:  }
        -: 4932:
        -: 4933:#ifdef OPTIMPI
        -: 4934:  {
       40: 4935:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
       40: 4936:    MPI_Reduce(b2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 4937:
       40: 4938:    memcpy(b2,lb,sizeof(double)*(nmatres));
       40: 4939:    free(lb);
        -: 4940:  }
        -: 4941:#else
        -: 4942:  if (rank==0) {
        -: 4943:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 4944:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 4945:      MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
        -: 4946:      for (l=0;l<nmatres;l++) b2[l]+=lb[l];
        -: 4947:    }
        -: 4948:    free(lb);
        -: 4949:  }
        -: 4950:  else MPI_Send(b2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1031, MPI_COMM_WORLD);
        -: 4951:#endif
        -: 4952:#ifdef OPTIMPI
        -: 4953:  {
       40: 4954:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
       40: 4955:    MPI_Reduce(hit2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 4956:
       40: 4957:    memcpy(hit2,lb,sizeof(double)*(nmatres));
       40: 4958:    free(lb);
        -: 4959:  }
        -: 4960:#else
        -: 4961:  if (rank==0) {
        -: 4962:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 4963:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 4964:      MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1033, MPI_COMM_WORLD,&statu);
        -: 4965:
        -: 4966:      for (l=0;l<nmatres;l++) hit2[l]+=lb[l];
        -: 4967:    }
        -: 4968:    free(lb);
        -: 4969:  }
        -: 4970:  else {
        -: 4971:    MPI_Send(hit2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1033, MPI_COMM_WORLD);
        -: 4972:  }
        -: 4973:#endif
        -: 4974:
        -: 4975:
        -: 4976:  //==========================================================
        -: 4977:  // Compute Ax
        -: 4978:  //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, x, q);
        -: 4979:  // +
        -: 4980:  // Preconditionnement
        -: 4981:  //
        -: 4982:  //
        -: 4983:
       40: 4984:  for (l=0;l<nmatres;l++) q2[l]=0;
       40: 4985:  if (rank==0) {
        -: 4986:
       10: 4987:    double soff=0;
       10: 4988:    for (i=0;i<newnr[nbolo];i++) soff+=hit2[0]*ix2[i];
       10: 4989:    for (i=0;i<newnr[nbolo];i++) q2[i]=soff;
        -: 4990:
       10: 4991:    if (Param->REMHDIP==1) {
       10: 4992:      soff=0;
       10: 4993:      for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) soff+=hit2[newnr[nbolo]]*ix2[i];
       10: 4994:      for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) q2[i]=soff;
        -: 4995:    }
        -: 4996:
       10: 4997:    if (Param->flag_AVGR0==_PAR_TRUE) {
    #####: 4998:      soff=0;
    #####: 4999:      for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2)]*
    #####: 5000:                              ix2[newnr[nbolo]+nbolo*(GAINSTEP2)+i];
    #####: 5001:      for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2)+i]=soff;
    #####: 5002:      for (i=0;i<nbolo;i++) b2[newnr[nbolo]+nbolo*(GAINSTEP2)+i]+=
    #####: 5003:                              hit2[newnr[nbolo]+nbolo*(GAINSTEP2)]*Param->AVGR0;
        -: 5004:
        -: 5005:    }
        -: 5006:
       10: 5007:    if (nmatco>0) {
       10: 5008:      soff=0;
       10: 5009:      if ((singleFreq == 0) && (Param->flag_AVG12CO == _PAR_TRUE)) {
    #####: 5010:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 5011:            soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
    #####: 5012:                    * ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
    #####: 5013:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 5014:            q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i] = soff;
    #####: 5015:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 5016:            b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i] +=
    #####: 5017:            hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)] * Param->AVG12CO;
        -: 5018:      }
        -: 5019:      else {
       50: 5020:        for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
       40: 5021:                                *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
       10: 5022:        for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i]=soff;
       50: 5023:        for (i=0;i<nbolo;i++) b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i]+=
       40: 5024:                                hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]*Param->AVG12CO;
        -: 5025:      }
        -: 5026:    }
       10: 5027:    if (nmatdust>0) {
       10: 5028:      soff=0;
       10: 5029:      if ((singleFreq == 0) && (Param->flag_AVGDUST100 == _PAR_TRUE)) {
    #####: 5030:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 5031:            soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]
    #####: 5032:                    * ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
    #####: 5033:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 5034:            q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i] = soff;
    #####: 5035:        for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 5036:            b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i] +=
    #####: 5037:            hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco] * Param->AVGDUST100;
        -: 5038:      }
        -: 5039:      else {
       50: 5040:        for (i=0;i<nbolo;i++)
       80: 5041:          soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]*
       40: 5042:            ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
       10: 5043:        for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i]=soff;
       50: 5044:        for (i=0;i<nbolo;i++) b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i]+=
       40: 5045:                                hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]*Param->AVGDUST;
        -: 5046:      }
        -: 5047:    }
       10: 5048:    if (nfreefree>0) {
    #####: 5049:      soff=0;
    #####: 5050:      if ((singleFreq == 0) && (Param->flag_AVGFREEFREE == _PAR_TRUE)) {
    #####: 5051:	for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF)
    #####: 5052:	  soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]*
    #####: 5053:	    ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 5054:	for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF)
    #####: 5055:				q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i]=soff;
    #####: 5056:	for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF)
    #####: 5057:				b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i]+=
    #####: 5058:                                hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]*Param->AVGFREEFREE;
        -: 5059:      }
        -: 5060:      else {
    #####: 5061:	for (i=0;i<nbolo;i++)
    #####: 5062:	  soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]*
    #####: 5063:	    ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 5064:	for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i]=soff;
        -: 5065:      }
        -: 5066:    }
       10: 5067:    long nj=0;
       10: 5068:    if (DOFITANGLE==1) nj++;
       10: 5069:    if (DOFITPOLEFF==1) nj++;
       10: 5070:    if (DOTDUST==1) nj++;
       10: 5071:    if (DOCO13==1) nj++;
       10: 5072:    if (DOSYNCHRO==1) nj++;
        -: 5073:
        -: 5074:
       10: 5075:    if (NORMFITPOL==1) {
        -: 5076:#if 1
    #####: 5077:      if (DOFITPOLEFF==1) {
    #####: 5078:	j=1+DOCO13+DOSYNCHRO+DOTDUST;
    #####: 5079:	soff=0;
    #####: 5080:	for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 5081:				ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 5082:	for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5083:      }
        -: 5084:#endif
        -: 5085:    }
        -: 5086:    
       10: 5087:    if (DOFITANGLE==1) {
       10: 5088:      j=1+DOCO13+DOSYNCHRO+DOTDUST+DOFITPOLEFF;
       10: 5089:      soff=0;
       50: 5090:      for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
       40: 5091:			      ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
       10: 5092:      for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5093:    }
        -: 5094:
       10: 5095:    if (DOCO13==1) {
       10: 5096:      j=1+DOSYNCHRO;
       10: 5097:      soff=0;
       50: 5098:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
       40: 5099:						   ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
       10: 5100:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
       50: 5101:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) b2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]+=
       40: 5102:							    hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)] * Param->AVG13CO;
        -: 5103:    }
        -: 5104:
       10: 5105:    if (DOTDUST==1) {
    #####: 5106:      j=1+DOCO13+DOSYNCHRO;
    #####: 5107:      soff=0;
    #####: 5108:      for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 5109:						       ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 5110:      for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5111:    }
        -: 5112:
       10: 5113:    if (DOSYNCHRO==1) {
    #####: 5114:      soff=0;
    #####: 5115:      j=1;
    #####: 5116:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 5117:						 ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 5118:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
    #####: 5119:      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC)
    #####: 5120:			      b2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2-j)+i]+=
    #####: 5121:                                hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2-j)]*Param->AVGSYNCHRO;
        -: 5122:
        -: 5123:    }
        -: 5124:  }
        -: 5125:
503316520: 5126:  for (k=0;k<nnbpix;k++) if (flgpix[k]>0) {
        -: 5127:
   194870: 5128:    long ndata = loc_nhpix[k];
   194870: 5129:    if (ndata>0) {
        -: 5130:#ifdef TIMING
        -: 5131:      gettimeofday(&tp1,NULL);
        -: 5132:#endif
   194870: 5133:      hpix *htmp = loc_hpix[k];
        -: 5134:
   194870: 5135:      double vali=0;
        -: 5136:
        -: 5137:#ifdef USEDII
   194870: 5138:      memset(dii ,0,sizeof(double)*nbolo*GAINSTEP);
        -: 5139:
   892810: 5140:      for (l1=0;l1<ndata;l1++) {
   697940: 5141:        long ri1=htmp[l1].rg-globalBeginRing;
        -: 5142:
   697940: 5143:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 5144:
   697940: 5145:          dii[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].dip;
        -: 5146:
        -: 5147:        }
        -: 5148:      }
   974350: 5149:      for (ib=0;ib<nbolo;ib++) {
  1558960: 5150:        for (j=0;j<GAINSTEP;j++) {
   779480: 5151:          if(II[k]==0){
    #####: 5152:            fprintf(stderr,"nbolo = %d II[k] = %f \n",htmp[l1].ib,II[k]);
        -: 5153:          }
        -: 5154:
   779480: 5155:          dii[j+ib*GAINSTEP]=dii[j+ib*GAINSTEP]/II[k];
        -: 5156:        }
        -: 5157:      }
        -: 5158:#endif
        -: 5159:
        -: 5160:      long l3;
   892810: 5161:      for (l3=0;l3<ndata;l3++) {
   697940: 5162:        long ri3=htmp[l3].rg-globalBeginRing;
   697940: 5163:        if (flg_rg[htmp[l3].ib][ri3]!=0) {
   697940: 5164:          long ir3=rgord[htmp[l3].ib][ri3]+newnr[htmp[l3].ib];
   697940: 5165:          vali+=htmp[l3].vi*ix2[ir3];
   697940: 5166:	  if (isnan(vali))  {
    #####: 5167:	    fprintf(stderr,"v %d %lf\n",__LINE__,htmp[l3].vi);
    #####: 5168:	    exit(0);
        -: 5169:	  }
        -: 5170:
        -: 5171:#ifndef USEDII
        -: 5172:          vali+=htmp[l3].lvi*ix2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 5173:	  if (isnan(vali))  {
        -: 5174:	    fprintf(stderr,"v %d %lf\n",__LINE__,htmp[l3].lvi);
        -: 5175:	    exit(0);
        -: 5176:	  }
        -: 5177:#endif
        -: 5178:        }
        -: 5179:	}
        -: 5180:      //fprintf(stderr,"I0 vali %lg %lg %lg\n",vali,valq,valu);
        -: 5181:
   974350: 5182:	  for (ib=0;ib<nbolo;ib++) {
        -: 5183:#ifdef USEDII
  1558960: 5184:	  for (j=0;j<GAINSTEP;j++) {
   779480: 5185:          vali+=dii[j+ib*GAINSTEP]  *ix2[newnr[nbolo]+ib*GAINSTEP+j];
        -: 5186:
   779480: 5187:	  if (isnan(vali))  {
    #####: 5188:	  fprintf(stderr,"v %d %lf %lf \n",__LINE__,dii[j+ib*GAINSTEP] ,ix2[newnr[nbolo]+ib*GAINSTEP+j]);
    #####: 5189:	  exit(0);
        -: 5190:	}
        -: 5191:	}
        -: 5192:        //fprintf(stderr,"I1 vali %lg %lg %lg\n",vali,valq,valu);
        -: 5193:#endif
        -: 5194:
   779480: 5195:        if (nmatco>0) {
   779480: 5196:          vali+=dcoi[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
        -: 5197:        }
        -: 5198:
   779480: 5199:	  if (isnan(vali))  {
    #####: 5200:	  fprintf(stderr,"v %d %lf \n",__LINE__,dcoi[ib+k*nbolo] );
    #####: 5201:	  exit(0);
        -: 5202:	}
   779480: 5203:        if (nmatdust>0) {
   779480: 5204:          vali+=ddusti[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
        -: 5205:        }
   779480: 5206:	  if (isnan(vali))  {
    #####: 5207:	  fprintf(stderr,"v %d %lf \n",__LINE__,ddusti[ib+k*nbolo] );
    #####: 5208:	  exit(0);
        -: 5209:	}
   779480: 5210:        if (nfreefree>0) {
    #####: 5211:          vali+=dfri[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
        -: 5212:        }
   779480: 5213:	  if (isnan(vali))  {
    #####: 5214:	  fprintf(stderr,"v %d %lf \n",__LINE__,dfri[ib+k*nbolo] );
    #####: 5215:	  exit(0);
        -: 5216:	}
        -: 5217:        //fprintf(stderr,"I3 vali %lg %lg %lg : %lg %lg %lg %lg\n",vali,valq,valu,
        -: 5218:        //dfri[ib+k*nbolo],dfrq[ib+k*nbolo],dfru[ib+k*nbolo],
        -: 5219:        //ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib]);
        -: 5220:
  7015320: 5221:        for (m=0;m<npixbeam;m++) {
  6235840: 5222:	  if (NOMOREFITTED!=DOCNN[m]||DOCNN[m]==0) {
  4131244: 5223:	    vali+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixi[ib+m*nbolo+k*nbolo*npixbeam];
  4131244: 5224:	    if (isnan(vali))  {
    #####: 5225:	      fprintf(stderr,"v %d %lf \n",__LINE__,dpixi[ib+m*nbolo+k*nbolo*npixbeam] );
    #####: 5226:	      exit(0);
        -: 5227:	    }
        -: 5228:	  }
        -: 5229:        }
        -: 5230:
        -: 5231:        //fprintf(stderr,"I4 vali %lg %lg %lg\n",vali,valq,valu);
        -: 5232:	}
   194870: 5233:      double qri=0;
        -: 5234:
   892810: 5235:      for (l1=0;l1<ndata;l1++) {
   697940: 5236:        long ri1=htmp[l1].rg-globalBeginRing;
   697940: 5237:        long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
        -: 5238:
   697940: 5239:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
   697940: 5240:          double ww=htmp[l1].wp;
   697940: 5241:          double val2=ix2[iri1]-(vali);
        -: 5242:
   697940: 5243:          val2+=ix2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]*htmp[l1].dip;
   697940: 5244:	  if (isnan(val2))  {
    #####: 5245:	    fprintf(stderr,"v %d %lf %lf\n",__LINE__,ix2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi],htmp[l1].dip);
    #####: 5246:	    exit(0);
        -: 5247:	  }
        -: 5248:
        -: 5249:          //fprintf(stderr,"I2 val2 %lg\n",val2);
   697940: 5250:          if (nmatco>0)
   697940: 5251:            val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]*htmp[l1].comap;
   697940: 5252:	  if (isnan(val2))  {
    #####: 5253:	    fprintf(stderr,"v %d %lf %lf\n",__LINE__,ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib],htmp[l1].comap);
    #####: 5254:	    exit(0);
        -: 5255:	  }
   697940: 5256:          if (nmatdust>0)
   697940: 5257:            val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]*htmp[l1].dustmap;
   697940: 5258:	  if (isnan(val2))  {
    #####: 5259:	    fprintf(stderr,"v %d %lf %lf\n",__LINE__,ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib],htmp[l1].dustmap);
    #####: 5260:	    exit(0);
        -: 5261:	  }
   697940: 5262:          if (nfreefree>0)
    #####: 5263:            val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+htmp[l1].ib]*htmp[l1].freefree;
        -: 5264:
        -: 5265:          //fprintf(stderr,"I3 val2 %lg\n",val2);
  6281460: 5266:          for (m=0;m<npixbeam;m++) {
  5583520: 5267:	    if (NOMOREFITTED!=DOCNN[m]||DOCNN[m]==0) {
  3699082: 5268:	      val2+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+htmp[l1].ib+m*nbolo]*htmp[l1].listofpix[m];
  3699082: 5269:	      if (isnan(val2))  {
    #####: 5270:		fprintf(stderr,"v %d %lf %lf\n",__LINE__,ix2[newnr[nbolo]+nbolo*GAINSTEP2+htmp[l1].ib+m*nbolo],htmp[l1].listofpix[m]);
    #####: 5271:		exit(0);
        -: 5272:	      }
        -: 5273:	    }
        -: 5274:
        -: 5275:          }
        -: 5276:
   697940: 5277:          qri-=ww*val2;
        -: 5278:
   697940: 5279:          q2[iri1]+=ww*val2;
   697940: 5280:	  if (isnan(q2[iri1]))  {
    #####: 5281:	    fprintf(stderr,"Q2NAN %lf %lf %lf\n",ww,val2,q2[iri1]);
    #####: 5282:	    exit(0);
        -: 5283:	  }
   697940: 5284:          q2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]+=ww*val2*htmp[l1].dip;
        -: 5285:
        -: 5286:          ///////////// CO
   697940: 5287:          if (nmatco>0) {
   697940: 5288:            q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]+=ww*val2*htmp[l1].comap;
        -: 5289:          }
        -: 5290:
        -: 5291:          ///////////// DUST
   697940: 5292:          if (nmatdust>0) {
   697940: 5293:            q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]+=ww*val2*htmp[l1].dustmap;
        -: 5294:          }
        -: 5295:
        -: 5296:          ///////////// FREEFREE
   697940: 5297:          if (nfreefree>0) {
    #####: 5298:            q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+htmp[l1].ib]+=ww*val2*htmp[l1].freefree;
        -: 5299:          }
        -: 5300:
        -: 5301:          ////////// SYSTE
  6281460: 5302:          for (j=0;j<npixbeam;j++) {
  5583520: 5303:	    if (NOMOREFITTED!=DOCNN[j]||DOCNN[j]==0) {
  3699082: 5304:	      q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+htmp[l1].ib]+=ww*val2*htmp[l1].listofpix[j];
        -: 5305:	    }
        -: 5306:          }
        -: 5307:
        -: 5308:
        -: 5309:        }
        -: 5310:      }
        -: 5311:
        -: 5312:
   892810: 5313:      for (l2=0;l2<ndata;l2++) {
   697940: 5314:        long ri2=htmp[l2].rg-globalBeginRing;
   697940: 5315:        if (flg_rg[htmp[l2].ib][ri2]!=0) {
   697940: 5316:          long ir=rgord[htmp[l2].ib][ri2]+newnr[htmp[l2].ib];
   697940: 5317:          q2[ir]+=qri*htmp[l2].vi;
        -: 5318:#ifndef USEDII
        -: 5319:          q2[newnr[nbolo]+htmp[l2].ib*GAINSTEP+htmp[l2].gi]+=qri*htmp[l2].lvi;
        -: 5320:#endif
        -: 5321:        }
        -: 5322:      }
        -: 5323:
        -: 5324:
   974350: 5325:      for (ib=0;ib<nbolo;ib++) {
        -: 5326:
        -: 5327:#ifdef USEDII
  1558960: 5328:        for (j=0;j<GAINSTEP;j++) {
   779480: 5329:          q2[newnr[nbolo]+GAINSTEP*ib+j]+=qri*dii[j+ib*GAINSTEP];
        -: 5330:        }
        -: 5331:#endif
        -: 5332:
        -: 5333:        ///////////// CO
   779480: 5334:        if (nmatco>0) {
   779480: 5335:          q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib]+=qri*dcoi[ib+k*nbolo];
        -: 5336:        }
        -: 5337:        ///////////// DUST
   779480: 5338:        if (nmatdust>0) {
   779480: 5339:          q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib]+=qri*ddusti[ib+k*nbolo];
        -: 5340:        }
        -: 5341:        ///////////// FREEFREE
   779480: 5342:        if (nfreefree>0) {
    #####: 5343:          q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib]+=qri*dfri[ib+k*nbolo];
        -: 5344:        }
        -: 5345:
  7015320: 5346:        for (j=0;j<npixbeam;j++) {
  6235840: 5347:	  if (NOMOREFITTED!=DOCNN[j]||DOCNN[j]==0) {
  4131244: 5348:	    q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+ib]+=qri*dpixi[ib+j*nbolo+k*nbolo*npixbeam];
        -: 5349:	  }
        -: 5350:        }
        -: 5351:      }
        -: 5352:    }
        -: 5353:
        -: 5354:#ifdef TIMING
        -: 5355:      gettimeofday(&tp2,NULL);
        -: 5356:      double dt=(double)(tp2.tv_sec-tp1.tv_sec)+(1E-6)*(tp2.tv_usec-tp1.tv_usec);
        -: 5357:      dthit[ndata]+=dt;
        -: 5358:      ndthit[ndata]+=1;
        -: 5359:#endif
        -: 5360:  }
        -: 5361:
        -: 5362:#ifdef OPTIMPI
        -: 5363:  {
       40: 5364:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
       40: 5365:    MPI_Reduce(q2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 5366:
       40: 5367:    memcpy(q2,lb,sizeof(double)*(nmatres));
       40: 5368:    free(lb);
        -: 5369:  }
        -: 5370:#else
        -: 5371:
        -: 5372:  if (rank==0) {
        -: 5373:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 5374:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 5375:      MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1032, MPI_COMM_WORLD,&statu);
        -: 5376:      for (l=0;l<nmatres;l++) q2[l]+=lb[l];
        -: 5377:    }
        -: 5378:    free(lb);
        -: 5379:  }
        -: 5380:  else {
        -: 5381:    MPI_Send(q2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1032, MPI_COMM_WORLD);
        -: 5382:  }
        -: 5383:#endif
        -: 5384:
       40: 5385:  if (rank==0) fprintf(stderr,"QQ2 %lg\n",q2[0]);
        -: 5386:
       40: 5387:  if (rank==0) {
      570: 5388:    for (i=0; i < nmatres; i++)
        -: 5389:      {
      560: 5390:        r2[i] = b2[i] - q2[i];
      560: 5391:        d2[i] = r2[i] / hit2[i];
        -: 5392:      }
        -: 5393:  }
        -: 5394:
       40: 5395:  double delta_new_tmp = 0.0;
       40: 5396:  if (rank==0) {
      570: 5397:    for (i = 0; i < nmatres; i++) {
      560: 5398:      delta_new_tmp += b2[i] ;
      560: 5399:      if (isnan(b2[i])) {
    #####: 5400:        fprintf(stderr,"NAN B2 PBS %ld %lg\n",(long) i,q2[i]);
        -: 5401:      }
      560: 5402:      if (isnan(d2[i])) {
    #####: 5403:        fprintf(stderr,"NAN D2 PBS %ld %lg %lg\n",(long) i,hit2[i],q2[i]);
        -: 5404:      }
        -: 5405:    }
        -: 5406:    //fprintf(stderr,"B2 %lg\n",delta_new_tmp);
        -: 5407:
       10: 5408:    delta_new_tmp = 0.0;
      570: 5409:    for (i = 0; i < nmatres; i++) {
      560: 5410:      delta_new_tmp += q2[i] ;
      560: 5411:      if (isnan(q2[i])) {
    #####: 5412:        fprintf(stderr,"NAN Q2 PBS %ld\n",(long) i);
        -: 5413:      }
        -: 5414:    }
        -: 5415:    //fprintf(stderr,"Q2 %lg\n",delta_new_tmp);
       10: 5416:    delta_new_tmp = 0.0;
      570: 5417:    for (i = 0; i < nmatres; i++) {
      560: 5418:      delta_new_tmp += q2[i]-b2[i] ;
        -: 5419:      //fprintf(stderr,"B2 Q2 B2-Q2 [%ld]: %lg\t%lg\t%lg\n",(long) i,b2[i],q2[i],q2[i]-b2[i]);
        -: 5420:    }
        -: 5421:  }
        -: 5422:
       40: 5423:  MPI_Barrier(MPI_COMM_WORLD);
       40: 5424:  delta_new_tmp = 0.0;
      600: 5425:  if (rank==0) for (i=0; i < nmatres; i++) {
      560: 5426:    delta_new_tmp += r2[i] * d2[i];
        -: 5427:  }
        -: 5428:
       40: 5429:  delta_new=0;
      200: 5430:  for (i=0;i<mpi_size;i++) {
      160: 5431:    double tmp=delta_new_tmp;
      160: 5432:    MPI_Bcast(&tmp, sizeof(double), MPI_BYTE, i, MPI_COMM_WORLD);
      160: 5433:    delta_new+=tmp;
        -: 5434:  }
        -: 5435:
       40: 5436:  if (itbogo==0) delta0 = delta_new;
       40: 5437:  if (rank==0) fprintf (stderr, "iter = %d - delta0 = %lg - delta_new = %lg\n", iter, delta0, delta_new);
       40: 5438:  int testwrit=0;
        -: 5439:
       40: 5440:  if (itbogo==0) MPI_Bcast(&normaoff, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
       40: 5441:  MPI_Bcast(&delta0, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
       40: 5442:  MPI_Bcast(&delta_new, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 5443:
        -: 5444:
     9208: 5445:  while ((iter < itermax)  && ((delta_new) > delta0*1E-24) && ((delta_new) > 1E-20)) //Param->XI2STOP))
        -: 5446:    {
        -: 5447:      // q <= Ad
        -: 5448:      //if (rank==0&&mindelta>delta_new) {
     9128: 5449:      if (rank==0) {
     2282: 5450:        memcpy(x2old,ix2,nmatres*sizeof(double));
     2282: 5451:        testwrit=1;
        -: 5452:      }
        -: 5453:    //  else testwrit=0;
        -: 5454:
        -: 5455:      //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, d, q);
        -: 5456:      //for (i=0;i<mpi_size;i++) {
        -: 5457:      //MPI_Bcast(d+tab_begr[i]*2, sizeof(double)*(tab_edr[i]-tab_begr[i]+1)*2, MPI_BYTE, i, MPI_COMM_WORLD);
        -: 5458:      //}
     9128: 5459:      MPI_Bcast(d2, sizeof(double)*(nmatres), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 5460:
        -: 5461:      // ===========================================================================
        -: 5462:      // PROJECTION DE d dans q
        -: 5463:      //
     9128: 5464:      for (l=0;l<nmatres;l++) q2[l]=0;
     9128: 5465:      if (rank==0) {
     2282: 5466:        double soff=0;
     2282: 5467:        for (i=0;i<newnr[nbolo];i++) soff+=hit2[0]*d2[i];
     2282: 5468:        for (i=0;i<newnr[nbolo];i++) q2[i]=soff;
        -: 5469:
     2282: 5470:        if (Param->REMHDIP==1) {
     2282: 5471:          soff=0;
     2282: 5472:          for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) soff+=hit2[newnr[nbolo]]*d2[i];
     2282: 5473:          for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) q2[i]=soff;
        -: 5474:        }
        -: 5475:
     2282: 5476:        if (Param->flag_AVGR0==_PAR_TRUE) {
    #####: 5477:          soff=0;
    #####: 5478:          for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2)]*
    #####: 5479:                                  d2[newnr[nbolo]+nbolo*(GAINSTEP2)+i];
    #####: 5480:          for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2)+i]=soff;
        -: 5481:        }
        -: 5482:
     2282: 5483:        if (nmatco>0) {
     2282: 5484:          soff=0;
     2282: 5485:          if ((singleFreq == 0) && (Param->flag_AVG12CO == _PAR_TRUE)) {
    #####: 5486:            for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 5487:                soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
    #####: 5488:                        * d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
    #####: 5489:            for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 5490:                q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i] = soff;
        -: 5491:          }
        -: 5492:          else {
    11410: 5493:            for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
     9128: 5494:                                    *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
     2282: 5495:            for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i]=soff;
        -: 5496:          }
        -: 5497:        }
        -: 5498:
     2282: 5499:        if (nfreefree>0) {
    #####: 5500:          soff=0;
    #####: 5501:	  if ((singleFreq == 0) && (Param->flag_AVGFREEFREE == _PAR_TRUE)) {
    #####: 5502:	    for (i=0;i<nbolo;i++)  if (freqs[i] == Param->AVFFF) soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]
    #####: 5503:				                              *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 5504:	    for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF)  q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i+nmatco+nmatdust]=soff;
        -: 5505:	  }
        -: 5506:	  else {
    #####: 5507:	    for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]
    #####: 5508:				    *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 5509:	    for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i+nmatco+nmatdust]=soff;
        -: 5510:	  }
        -: 5511:	}
        -: 5512:
     2282: 5513:        if (nmatdust>0) {
     2282: 5514:          soff=0;
     2282: 5515:          if ((singleFreq == 0) && (Param->flag_AVGDUST100 == _PAR_TRUE)) {
    #####: 5516:            for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 5517:                soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]
    #####: 5518:                        * d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
    #####: 5519:            for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 5520:                q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i] = soff;
        -: 5521:          }
        -: 5522:          else {
    11410: 5523:            for (i=0;i<nbolo;i++)
    18256: 5524:              soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]*
     9128: 5525:                d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
     2282: 5526:            for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i]=soff;
        -: 5527:          }
        -: 5528:        }
        -: 5529:
     2282: 5530:        long nj=0;
     2282: 5531:        if (DOFITANGLE==1) nj++;
     2282: 5532:        if (DOFITPOLEFF==1) nj++;
     2282: 5533:	if (DOTDUST==1) nj++;
     2282: 5534:        if (DOCO13==1) nj++;
     2282: 5535:	if (DOSYNCHRO==1) nj++;
        -: 5536:
     2282: 5537:	if (NORMFITPOL==1) {
        -: 5538:#if 1
    #####: 5539:	  if (DOFITPOLEFF==1) {
    #####: 5540:	    j=1+DOCO13+DOSYNCHRO+DOTDUST;
    #####: 5541:	    soff=0;
    #####: 5542:	    for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 5543:				    d2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 5544:	    for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5545:	  }
        -: 5546:#endif
        -: 5547:	}
        -: 5548:	
     2282: 5549:	if (DOFITANGLE==1) {
     2282: 5550:	  j=1+DOCO13+DOSYNCHRO+DOTDUST+DOFITPOLEFF;
     2282: 5551:	  soff=0;
    11410: 5552:	  for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
     9128: 5553:				  d2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
     2282: 5554:	  for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5555:	}
        -: 5556:
     2282: 5557:	if (DOCO13==1) {
     2282: 5558:	  j=1+DOSYNCHRO;
     2282: 5559:	  soff=0;
    11410: 5560:	  for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
     9128: 5561:						       d2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
     2282: 5562:	  for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5563:	}
        -: 5564:
     2282: 5565:	if (DOTDUST==1) {
    #####: 5566:	  j=1+DOCO13+DOSYNCHRO;
    #####: 5567:	  soff=0;
    #####: 5568:	  for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 5569:							   d2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 5570:	  for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5571:	}
        -: 5572:
     2282: 5573:	if (DOSYNCHRO==1) {
    #####: 5574:	    soff=0;
    #####: 5575:	    j=1;
    #####: 5576:	    for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC)  soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 5577:						       d2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 5578:	    for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC)  q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5579:	}
        -: 5580:      }
114856829864: 5581:      for (k=0;k<nnbpix;k++) if (flgpix[k]>0) {
        -: 5582:
        -: 5583:        //long imat=the_stat_pix[k];
 44469334: 5584:        long ndata = loc_nhpix[k];
 44469334: 5585:        if (ndata>0) {
 44469334: 5586:          hpix *htmp = loc_hpix[k];
        -: 5587:
 44469334: 5588:          double vali=0;
        -: 5589:
        -: 5590:
        -: 5591:#ifdef USEDII
 44469334: 5592:          memset(dii ,0,sizeof(double)*nbolo*GAINSTEP);
        -: 5593:
203739242: 5594:          for (l1=0;l1<ndata;l1++) {
159269908: 5595:            long ri1=htmp[l1].rg-globalBeginRing;
        -: 5596:
159269908: 5597:            if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 5598:
159269908: 5599:              dii[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].dip;
        -: 5600:            }
        -: 5601:          }
222346670: 5602:          for (ib=0;ib<nbolo;ib++) {
355754672: 5603:            for (j=0;j<GAINSTEP;j++) {
177877336: 5604:              dii[j+ib*GAINSTEP]=dii[j+ib*GAINSTEP]/II[k];
        -: 5605:            }
        -: 5606:          }
        -: 5607:#endif
        -: 5608:          long l3;
203739242: 5609:          for (l3=0;l3<ndata;l3++) {
159269908: 5610:            long ri3=htmp[l3].rg-globalBeginRing;
159269908: 5611:            if (flg_rg[htmp[l3].ib][ri3]!=0) {
159269908: 5612:              long ir3=rgord[htmp[l3].ib][ri3]+newnr[htmp[l3].ib];
159269908: 5613:              vali+=htmp[l3].vi*d2[ir3];
        -: 5614:#ifndef USEDII
        -: 5615:              vali+=htmp[l3].lvi*d2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 5616:#endif
        -: 5617:            }
        -: 5618:          }
222346670: 5619:          for (ib=0;ib<nbolo;ib++) {
        -: 5620:
        -: 5621:
        -: 5622:#ifdef USEDII
355754672: 5623:            for (j=0;j<GAINSTEP;j++) {
177877336: 5624:              vali+=dii[j+ib*GAINSTEP]  *d2[newnr[nbolo]+ib*GAINSTEP+j];
        -: 5625:            }
        -: 5626:#endif
        -: 5627:
177877336: 5628:            if (nmatco>0) {
177877336: 5629:              vali+=dcoi[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
        -: 5630:            }
177877336: 5631:            if (nmatdust>0) {
177877336: 5632:              vali+=ddusti[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
        -: 5633:            }
177877336: 5634:            if (nfreefree>0) {
    #####: 5635:              vali+=dfri[ib+k*nbolo]  *d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
        -: 5636:            }
1600896024: 5637:            for (m=0;m<npixbeam;m++) {
1423018688: 5638:	      if (NOMOREFITTED!=DOCNN[m]||DOCNN[m]==0) {
959539880: 5639:		vali+=d2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixi[ib+m*nbolo+k*nbolo*npixbeam];
        -: 5640:	      }
        -: 5641:            }
        -: 5642:          }
        -: 5643:
 44469334: 5644:          double qri=0;
        -: 5645:
203739242: 5646:          for (l1=0;l1<ndata;l1++) {
159269908: 5647:            long ri1=htmp[l1].rg-globalBeginRing;
159269908: 5648:            long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
        -: 5649:
159269908: 5650:            if (flg_rg[htmp[l1].ib][ri1]!=0) {
159269908: 5651:              double ww=htmp[l1].wp;
159269908: 5652:              double val2=d2[iri1]-(vali);
        -: 5653:
159269908: 5654:              val2+=d2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]*htmp[l1].dip;
159269908: 5655:              if (nmatco>0)
159269908: 5656:                val2+=d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]*htmp[l1].comap;
159269908: 5657:              if (nmatdust>0)
159269908: 5658:                val2+=d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]*htmp[l1].dustmap;
159269908: 5659:              if (nfreefree>0)
    #####: 5660:                val2+=d2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+htmp[l1].ib]*htmp[l1].freefree;
        -: 5661:
1433429172: 5662:              for (m=0;m<npixbeam;m++) {
1274159264: 5663:		if (NOMOREFITTED!=DOCNN[m]||DOCNN[m]==0) {
859164140: 5664:		  val2+=d2[newnr[nbolo]+nbolo*GAINSTEP2+htmp[l1].ib+m*nbolo]*htmp[l1].listofpix[m];
        -: 5665:		}
        -: 5666:              }
        -: 5667:
        -: 5668:
159269908: 5669:              qri-=ww*val2;
        -: 5670:
159269908: 5671:              q2[iri1]+=ww*val2;
        -: 5672:
159269908: 5673:              q2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]+=ww*val2*htmp[l1].dip;
        -: 5674:
        -: 5675:              ///////////// CO
159269908: 5676:              if (nmatco>0) {
159269908: 5677:                q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]+=ww*val2*htmp[l1].comap;
        -: 5678:              }
        -: 5679:
        -: 5680:              ///////////// DUST
159269908: 5681:              if (nmatdust>0) {
159269908: 5682:                q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]+=ww*val2*htmp[l1].dustmap;
        -: 5683:              }
        -: 5684:
        -: 5685:              ///////////// FREEFREE
159269908: 5686:              if (nfreefree>0) {
    #####: 5687:                q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+htmp[l1].ib]+=ww*val2*htmp[l1].freefree;
        -: 5688:              }
        -: 5689:
        -: 5690:
1433429172: 5691:              for (j=0;j<npixbeam;j++) {
1274159264: 5692:		if (NOMOREFITTED!=DOCNN[j]||DOCNN[j]==0) {
859164140: 5693:		  q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+htmp[l1].ib]+=ww*val2*htmp[l1].listofpix[j];
        -: 5694:		}
        -: 5695:              }
        -: 5696:
        -: 5697:            }
        -: 5698:          }
        -: 5699:
        -: 5700:
203739242: 5701:          for (l2=0;l2<ndata;l2++) {
159269908: 5702:            long ri2=htmp[l2].rg-globalBeginRing;
159269908: 5703:            if (flg_rg[htmp[l2].ib][ri2]!=0) {
159269908: 5704:              long ir=rgord[htmp[l2].ib][ri2]+newnr[htmp[l2].ib];
159269908: 5705:              q2[ir]+=qri*htmp[l2].vi;
        -: 5706:#ifndef USEDII
        -: 5707:              q2[newnr[nbolo]+htmp[l2].ib*GAINSTEP+htmp[l2].gi]+=qri*htmp[l2].lvi;
        -: 5708:#endif
        -: 5709:            }
        -: 5710:          }
        -: 5711:
222346670: 5712:          for (ib=0;ib<nbolo;ib++) {
        -: 5713:
        -: 5714:
        -: 5715:#ifdef USEDII
355754672: 5716:            for (j=0;j<GAINSTEP;j++) {
177877336: 5717:              q2[newnr[nbolo]+GAINSTEP*ib+j]+=qri*dii[j+ib*GAINSTEP];
        -: 5718:            }
        -: 5719:#endif
        -: 5720:
        -: 5721:            ///////////// CO
177877336: 5722:            if (nmatco>0) {
177877336: 5723:              q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib]+=qri*dcoi[ib+k*nbolo];
        -: 5724:            }
        -: 5725:            ///////////// DUST
177877336: 5726:            if (nmatdust>0) {
177877336: 5727:              q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib]+=qri*ddusti[ib+k*nbolo];
        -: 5728:            }
        -: 5729:            ///////////// FREEFREE
177877336: 5730:            if (nfreefree>0) {
    #####: 5731:              q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib]+=qri*dfri[ib+k*nbolo];
        -: 5732:            }
        -: 5733:
1600896024: 5734:            for (j=0;j<npixbeam;j++) {
1423018688: 5735:	      if (NOMOREFITTED!=DOCNN[j]||DOCNN[j]==0) {
959539880: 5736:		q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+ib]+=qri*dpixi[ib+j*nbolo+k*nbolo*npixbeam];
        -: 5737:	      }
        -: 5738:            }
        -: 5739:          }
        -: 5740:        }
        -: 5741:      }
        -: 5742:#ifdef OPTIMPI
        -: 5743:      {
     9128: 5744:	double *lb = (double *) malloc(sizeof(double)*(nmatres));
     9128: 5745:	MPI_Reduce(q2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 5746:
     9128: 5747:	memcpy(q2,lb,sizeof(double)*(nmatres));
     9128: 5748:	free(lb);
        -: 5749:      }
        -: 5750:#else
        -: 5751:      if (rank==0) {
        -: 5752:        double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 5753:        for (rrk=1;rrk<mpi_size;rrk++) {
        -: 5754:          MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1034, MPI_COMM_WORLD,&statu);
        -: 5755:          for (l=0;l<nmatres;l++) q2[l]+=lb[l];
        -: 5756:        }
        -: 5757:        free(lb);
        -: 5758:      }
        -: 5759:      else {
        -: 5760:        MPI_Send(q2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1034, MPI_COMM_WORLD);
        -: 5761:      }
        -: 5762:#endif
     9128: 5763:      double dtq = 0.0;
     9128: 5764:      if (rank==0) {
     2282: 5765:        for (i=0; i < nmatres; i++) dtq += d2[i] * q2[i];
     2282: 5766:        alpha = delta_new / dtq;
     2282: 5767:        for (i=0; i < nmatres ; i++) ix2[i] += alpha * d2[i];
        -: 5768:      }
        -: 5769:
        -: 5770:
     9128: 5771:      gettimeofday(&tp2,NULL);
     9359: 5772:      if (rank==0&&iter%10==0) fprintf (stderr,"iter = %ld-%d - delta_new = %lg %ld %3lfs\n", itbogo, iter, delta_new,
      231: 5773:                          (long) testwrit,(double)(tp2.tv_sec-tp1.tv_sec)+(1E-6)*(tp2.tv_usec-tp1.tv_usec));
        -: 5774:
        -: 5775:      //if (rank==0) fprintf (stderr,".");
     9128: 5776:      gettimeofday(&tp1,NULL);
        -: 5777:
     9128: 5778:      if (iter % 100 == 0 && iter !=0)
        -: 5779:        {
        -: 5780:          // Use the best case
       64: 5781:          memcpy(ix2,x2old,nmatres*sizeof(double));
        -: 5782:          //for (i=0;i<mpi_size;i++) {
        -: 5783:          //  MPI_Bcast(x+tab_begr[i]*2, sizeof(double)*(tab_edr[i]-tab_begr[i]+1)*2, MPI_BYTE, i, MPI_COMM_WORLD);
        -: 5784:          //}
       64: 5785:          MPI_Bcast(ix2, sizeof(double)*(nmatres), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 5786:
        -: 5787:
        -: 5788:      // ===========================================================================
        -: 5789:      // PROJECTION DE x dans q
        -: 5790:      //
        -: 5791:
       64: 5792:          for (l=0;l<nmatres;l++) q2[l]=0;
       64: 5793:          if (rank==0) {
       16: 5794:            double soff=0;
       16: 5795:            for (i=0;i<newnr[nbolo];i++) soff+=hit2[0]*ix2[i];
       16: 5796:            for (i=0;i<newnr[nbolo];i++) q2[i]=soff;
        -: 5797:
       16: 5798:            if (Param->REMHDIP==1) {
       16: 5799:              soff=0;
       16: 5800:              for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) soff+=hit2[newnr[nbolo]]*ix2[i];
       16: 5801:              for (i=newnr[nbolo];i<newnr[nbolo]+GAINSTEP*nbolo;i++) q2[i]=soff;
        -: 5802:            }
        -: 5803:
       16: 5804:            if (Param->flag_AVGR0==_PAR_TRUE) {
    #####: 5805:              soff=0;
    #####: 5806:              for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2)]*
    #####: 5807:                                      ix2[newnr[nbolo]+nbolo*(GAINSTEP2)+i];
    #####: 5808:              for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2)+i]=soff;
        -: 5809:            }
        -: 5810:
       16: 5811:            if (nmatco>0) {
       16: 5812:              soff=0;
       16: 5813:              if ((singleFreq == 0) && (Param->flag_AVG12CO == _PAR_TRUE)) {
    #####: 5814:                for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 5815:                    soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
    #####: 5816:                            * ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
    #####: 5817:                for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO)
    #####: 5818:                    q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i] = soff;
        -: 5819:              }
        -: 5820:              else {
       80: 5821:                for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)]
       64: 5822:                                        *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i];
       16: 5823:                for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+i]=soff;
        -: 5824:              }
        -: 5825:            }
        -: 5826:
       16: 5827:            if (nmatdust>0) {
       16: 5828:              soff=0;
       16: 5829:              if ((singleFreq == 0) && (Param->flag_AVGDUST100 == _PAR_TRUE)) {
    #####: 5830:                for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 5831:                  soff += hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]
    #####: 5832:                          * ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
    #####: 5833:                for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFDUST)
    #####: 5834:                  q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i] = soff;
        -: 5835:              }
        -: 5836:              else {
       80: 5837:                for (i=0;i<nbolo;i++)
      128: 5838:                  soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco]*
       64: 5839:                    ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i];
       16: 5840:                for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+i]=soff;
        -: 5841:              }
        -: 5842:            }
        -: 5843:
       16: 5844:            if (nfreefree>0) {
    #####: 5845:              soff=0;
    #####: 5846:	      if ((singleFreq == 0) && (Param->flag_AVGFREEFREE == _PAR_TRUE)) {
    #####: 5847:		for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF)
    #####: 5848:		  soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]*
    #####: 5849:		    ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 5850:		for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFFF) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i]=soff;
        -: 5851:	      }
        -: 5852:	      else  {
    #####: 5853:		for (i=0;i<nbolo;i++)
    #####: 5854:		  soff+=hit2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust]*
    #####: 5855:		    ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i];
    #####: 5856:		for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+i]=soff;
        -: 5857:	      }
        -: 5858:	    }
        -: 5859:
       16: 5860:            long nj=0;
       16: 5861:            if (DOFITANGLE==1) nj++;
       16: 5862:            if (DOFITPOLEFF==1) nj++;
       16: 5863:	    if (DOTDUST==1) nj++;
       16: 5864:            if (DOCO13==1) nj++;
       16: 5865:	    if (DOSYNCHRO==1) nj++;
        -: 5866:
       16: 5867:	    if (NORMFITPOL==1) {
        -: 5868:#if 1
    #####: 5869:	      if (DOFITPOLEFF==1) {
    #####: 5870:		j=1+DOCO13+DOSYNCHRO+DOTDUST;
    #####: 5871:		soff=0;
    #####: 5872:		for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 5873:					ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 5874:		for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5875:	      }
        -: 5876:#endif
        -: 5877:	    }
        -: 5878:	    
       16: 5879:	    if (DOFITANGLE==1) {
       16: 5880:	      j=1+DOCO13+DOSYNCHRO+DOTDUST+DOFITPOLEFF;
       16: 5881:	      soff=0;
       80: 5882:	      for (i=0;i<nbolo;i++) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
       64: 5883:				      ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
       16: 5884:	      for (i=0;i<nbolo;i++) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5885:	    }
        -: 5886:
       16: 5887:	    if (DOCO13==1) {
       16: 5888:	      j=1+DOSYNCHRO;
       16: 5889:	      soff=0;
       80: 5890:	      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
       64: 5891:							   ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
       16: 5892:	      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFCO) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5893:	    }
        -: 5894:
       16: 5895:	    if (DOTDUST==1) {
    #####: 5896:	      j=1+DOCO13+DOSYNCHRO;
    #####: 5897:	      soff=0;
    #####: 5898:	      for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 5899:							       ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 5900:	      for (i=0;i<nbolo;i++) if (freqs[i] == MAXFREQ) q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5901:	    }
        -: 5902:
       16: 5903:	    if (DOSYNCHRO==1) {
    #####: 5904:	      soff=0;
    #####: 5905:	      j=1;
    #####: 5906:	      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC)  soff+=hit2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)]*
    #####: 5907:							 ix2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i];
    #####: 5908:	      for (i=0;i<nbolo;i++) if (freqs[i] == Param->AVFSYNC)  q2[newnr[nbolo]+nbolo*(GAINSTEP2+npixbeam-j)+i]=soff;
        -: 5909:
        -: 5910:	    }
        -: 5911:          }
        -: 5912:
        -: 5913:
805306432: 5914:          for (k=0;k<nnbpix;k++) if (flgpix[k]>0) {
        -: 5915:
        -: 5916:            //long imat=the_stat_pix[k];
   311792: 5917:            long ndata = loc_nhpix[k];
   311792: 5918:            if (ndata>0) {
   311792: 5919:              hpix *htmp = loc_hpix[k];
        -: 5920:
   311792: 5921:              double vali=0;
        -: 5922:
        -: 5923:#ifdef USEDII
   311792: 5924:              memset(dii ,0,sizeof(double)*nbolo*GAINSTEP);
        -: 5925:
        -: 5926:
  1428496: 5927:              for (l1=0;l1<ndata;l1++) {
  1116704: 5928:                long ri1=htmp[l1].rg-globalBeginRing;
        -: 5929:
  1116704: 5930:                if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 5931:
  1116704: 5932:                  dii[htmp[l1].gi+htmp[l1].ib*GAINSTEP ]+=htmp[l1].w*htmp[l1].dip;
        -: 5933:                }
        -: 5934:              }
  1558960: 5935:              for (ib=0;ib<nbolo;ib++) {
  2494336: 5936:                for (j=0;j<GAINSTEP;j++) {
  1247168: 5937:                  dii[j+ib*GAINSTEP]=dii[j+ib*GAINSTEP]/II[k];
        -: 5938:                }
        -: 5939:              }
        -: 5940:#endif
        -: 5941:              long l3;
  1428496: 5942:              for (l3=0;l3<ndata;l3++) {
  1116704: 5943:                long ri3=htmp[l3].rg-globalBeginRing;
  1116704: 5944:                if (flg_rg[htmp[l3].ib][ri3]!=0) {
  1116704: 5945:                  long ir3=rgord[htmp[l3].ib][ri3]+newnr[htmp[l3].ib];
  1116704: 5946:                  vali+=htmp[l3].vi*ix2[ir3];
        -: 5947:#ifndef USEDII
        -: 5948:                  vali+=htmp[l3].lvi*ix2[newnr[nbolo]+htmp[l3].ib*GAINSTEP+htmp[l3].gi];
        -: 5949:#endif
        -: 5950:                }
        -: 5951:              }
        -: 5952:
  1558960: 5953:              for (ib=0;ib<nbolo;ib++) {
        -: 5954:
        -: 5955:
        -: 5956:#ifdef USEDII
  2494336: 5957:                for (j=0;j<GAINSTEP;j++) {
  1247168: 5958:                  vali+=dii[j+ib*GAINSTEP]  *ix2[newnr[nbolo]+ib*GAINSTEP+j];
        -: 5959:                }
        -: 5960:#endif
        -: 5961:
  1247168: 5962:                if (nmatco>0) {
  1247168: 5963:                  vali+=dcoi[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib];
        -: 5964:                }
  1247168: 5965:                if (nmatdust>0) {
  1247168: 5966:                  vali+=ddusti[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib];
        -: 5967:                }
  1247168: 5968:                if (nfreefree>0) {
    #####: 5969:                  vali+=dfri[ib+k*nbolo]  *ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib];
        -: 5970:                }
 11224512: 5971:                for (m=0;m<npixbeam;m++) {
  9977344: 5972:		  if (NOMOREFITTED!=DOCNN[m]||DOCNN[m]==0) {
  6703528: 5973:		    vali+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+ib+m*nbolo]*dpixi[ib+m*nbolo+k*nbolo*npixbeam];
        -: 5974:		  }
        -: 5975:                }
        -: 5976:              }
        -: 5977:
   311792: 5978:              double qri=0;
        -: 5979:
  1428496: 5980:              for (l1=0;l1<ndata;l1++) {
  1116704: 5981:                long ri1=htmp[l1].rg-globalBeginRing;
  1116704: 5982:                long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
        -: 5983:
  1116704: 5984:                if (flg_rg[htmp[l1].ib][ri1]!=0) {
  1116704: 5985:                  double ww=htmp[l1].wp;
  1116704: 5986:                  double val2=ix2[iri1]-(vali);
        -: 5987:
  1116704: 5988:                  val2+=ix2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]*htmp[l1].dip;
        -: 5989:
  1116704: 5990:                  if (nmatco>0)
  1116704: 5991:                    val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]*htmp[l1].comap;
  1116704: 5992:                  if (nmatdust>0)
  1116704: 5993:                    val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]*htmp[l1].dustmap;
  1116704: 5994:                  if (nfreefree>0)
    #####: 5995:                    val2+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nfreefree+htmp[l1].ib]*htmp[l1].freefree;
        -: 5996:
 10050336: 5997:                  for (m=0;m<npixbeam;m++) {
  8933632: 5998:		    if (NOMOREFITTED!=DOCNN[m]||DOCNN[m]==0) {
  6002284: 5999:		      val2+=ix2[newnr[nbolo]+nbolo*GAINSTEP2+htmp[l1].ib+m*nbolo]*htmp[l1].listofpix[m];
        -: 6000:		    }
        -: 6001:                  }
        -: 6002:
  1116704: 6003:                  qri-=ww*val2;
        -: 6004:
  1116704: 6005:                  q2[iri1]+=ww*val2;
        -: 6006:
  1116704: 6007:                  q2[newnr[nbolo]+htmp[l1].ib*GAINSTEP+htmp[l1].gi]+=ww*val2*htmp[l1].dip;
        -: 6008:
        -: 6009:                  ///////////// CO
  1116704: 6010:                  if (nmatco>0) {
  1116704: 6011:                    q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+htmp[l1].ib]+=ww*val2*htmp[l1].comap;
        -: 6012:                  }
        -: 6013:
        -: 6014:                  ///////////// DUST
  1116704: 6015:                  if (nmatdust>0) {
  1116704: 6016:                    q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+htmp[l1].ib]+=ww*val2*htmp[l1].dustmap;
        -: 6017:                  }
        -: 6018:
        -: 6019:                  ///////////// FREEFREE
  1116704: 6020:                  if (nfreefree>0) {
    #####: 6021:                    q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nfreefree+htmp[l1].ib]+=ww*val2*htmp[l1].freefree;
        -: 6022:                  }
        -: 6023:
 10050336: 6024:                  for (j=0;j<npixbeam;j++) {
  8933632: 6025:		    if (NOMOREFITTED!=DOCNN[j]||DOCNN[j]==0) {
  6002284: 6026:		      q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+htmp[l1].ib]+=ww*val2*htmp[l1].listofpix[j];
        -: 6027:		    }
        -: 6028:                  }
        -: 6029:
        -: 6030:                }
        -: 6031:              }
        -: 6032:
  1428496: 6033:              for (l2=0;l2<ndata;l2++) {
  1116704: 6034:                long ri2=htmp[l2].rg-globalBeginRing;
  1116704: 6035:                if (flg_rg[htmp[l2].ib][ri2]!=0) {
  1116704: 6036:                  long ir=rgord[htmp[l2].ib][ri2]+newnr[htmp[l2].ib];
  1116704: 6037:                  q2[ir]+=qri*htmp[l2].vi;
        -: 6038:#ifndef USEDII
        -: 6039:                  q2[newnr[nbolo]+htmp[l2].ib*GAINSTEP+htmp[l2].gi]+=qri*htmp[l2].lvi;
        -: 6040:#endif
        -: 6041:                }
        -: 6042:              }
        -: 6043:
  1558960: 6044:              for (ib=0;ib<nbolo;ib++) {
        -: 6045:
        -: 6046:
        -: 6047:#ifdef USEDII
  2494336: 6048:                for (j=0;j<GAINSTEP;j++) {
  1247168: 6049:                  q2[newnr[nbolo]+GAINSTEP*ib+j]+=qri*dii[j+ib*GAINSTEP];
        -: 6050:                }
        -: 6051:#endif
        -: 6052:
        -: 6053:                ///////////// CO
  1247168: 6054:                if (nmatco>0) {
  1247168: 6055:                  q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+ib]+=qri*dcoi[ib+k*nbolo];
        -: 6056:                }
        -: 6057:                ///////////// DUST
  1247168: 6058:                if (nmatdust>0) {
  1247168: 6059:                  q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+ib]+=qri*ddusti[ib+k*nbolo];
        -: 6060:                }
        -: 6061:
        -: 6062:                ///////////// FREEFREE
  1247168: 6063:                if (nfreefree>0) {
    #####: 6064:                  q2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP2)+nmatco+nmatdust+ib]+=qri*dfri[ib+k*nbolo];
        -: 6065:                }
        -: 6066:
 11224512: 6067:                for (j=0;j<npixbeam;j++) {
  9977344: 6068:		  if (NOMOREFITTED!=DOCNN[j]||DOCNN[j]==0) {
  6703528: 6069:		    q2[newnr[nbolo]+nbolo*GAINSTEP2+j*nbolo+ib]+=qri*dpixi[ib+j*nbolo+k*nbolo*npixbeam];
        -: 6070:		  }
        -: 6071:                }
        -: 6072:              }
        -: 6073:            }
        -: 6074:          }
        -: 6075:#ifdef OPTIMPI
        -: 6076:	  {
       64: 6077:	    double *lb = (double *) malloc(sizeof(double)*(nmatres));
       64: 6078:	    MPI_Reduce(q2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 6079:
       64: 6080:	    memcpy(q2,lb,sizeof(double)*(nmatres));
       64: 6081:	    free(lb);
        -: 6082:	  }
        -: 6083:#else
        -: 6084:          if (rank==0) {
        -: 6085:            double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 6086:            for (rrk=1;rrk<mpi_size;rrk++) {
        -: 6087:              MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1034, MPI_COMM_WORLD,&statu);
        -: 6088:              for (l=0;l<nmatres;l++) q2[l]+=lb[l];
        -: 6089:            }
        -: 6090:
        -: 6091:            free(lb);
        -: 6092:          }
        -: 6093:          else {
        -: 6094:            MPI_Send(q2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1034, MPI_COMM_WORLD);
        -: 6095:          }
        -: 6096:#endif
        -: 6097:
      960: 6098:          if (rank==0) for (i=0; i < nmatres; i++) {
      896: 6099:            r2[i] = b2[i] - q2[i];
        -: 6100:          }
        -: 6101:
        -: 6102:        }
        -: 6103:      else
        -: 6104:        {
     9064: 6105:          if (rank==0) for (i=0; i < nmatres; i++) r2[i] -= alpha * q2[i];
        -: 6106:        }
        -: 6107:
     9128: 6108:      if (rank==0) for (i=0; i < nmatres; i++) s2[i] = r2[i] / hit2[i];
        -: 6109:
     9128: 6110:      delta_old = delta_new;
     9128: 6111:      if (rank==0) {
     2282: 6112:        delta_new=0;
     2282: 6113:        for (i=0; i < nmatres ; i++) delta_new += r2[i] * s2[i];
     2282: 6114:        beta = delta_new / delta_old;
     2282: 6115:        for (i=0; i < nmatres ; i++) d2[i] = s2[i] + beta * d2[i];
        -: 6116:      }
     9128: 6117:      iter ++;
     9128: 6118:      MPI_Bcast(&delta_new, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 6119:
        -: 6120:    }
        -: 6121:
       40: 6122:  if (rank==0) fprintf (stderr,"\niter = %d - delta0 = %lg - delta_new = %lg\n",
        -: 6123:                        iter, delta0, delta_new);
       40: 6124:  if (rank==0) fprintf (stderr,"CG in iter = %d (max=%d)\n", iter, itermax);
        -: 6125:
       40: 6126:  if (rank==0) memcpy(ix2  ,x2old,nmatres*sizeof (double));
       40: 6127:  MPI_Bcast(ix2, sizeof(double)*(nmatres), MPI_BYTE, 0, MPI_COMM_WORLD);
       40: 6128:  itbogo++;
       40: 6129:}
        -: 6130:
    #####: 6131:void minimize_optimize(double *ix2,double *x3,double *gain)
        -: 6132:{
        -: 6133:  MPI_Status statu;
        -: 6134:  long i,rrk,k,l1,l2;
    #####: 6135:  int itermax = 500;
        -: 6136:  int iter;
    #####: 6137:  double delta_new, alpha=0, delta_old, beta;
        -: 6138:
        -: 6139:
        -: 6140:  int rank;
        -: 6141:  int size;
        -: 6142:  int mpi_size;
        -: 6143:  int rank_size;
    #####: 6144:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
    #####: 6145:  rank=rank_size;
    #####: 6146:  MPI_Comm_size(MPI_COMM_WORLD,&size);
    #####: 6147:  mpi_size=size;
        -: 6148:
    #####: 6149:  if (rank==0) {
    #####: 6150:    fprintf(stderr,"==============================\n\nOPTIMIZE %ld %ld\n\n==============================\n",itbogo,newnr2[nbolo]);
    #####: 6151:    fprintf(stderr,"GAIN ");
    #####: 6152:    for (i=0;i<nbolo;i++) fprintf(stderr,"%lg ",gain[i*GAINSTEP]);
    #####: 6153:    fprintf(stderr,"\n");
    #####: 6154:    if (GAINSTEP>1) {
    #####: 6155:      fprintf(stderr,"...\nGAIN ");
    #####: 6156:      for (i=0;i<nbolo;i++) fprintf(stderr,"%lg ",gain[i*GAINSTEP+(GAINSTEP-1)]);
    #####: 6157:      fprintf(stderr,"\n");
        -: 6158:    }
        -: 6159:  }
    #####: 6160:  if (itbogo==0) delta0=0;
    #####: 6161:  MPI_Barrier(MPI_COMM_WORLD);
        -: 6162:
        -: 6163:  struct timeval tp1,tp2;
    #####: 6164:  gettimeofday(&tp1,NULL);
        -: 6165:
    #####: 6166:  nmatres=newnr2[nbolo];
        -: 6167:
    #####: 6168:  iter = 0;
    #####: 6169:  memset(b2  ,0,nmatres*sizeof (double));
    #####: 6170:  memset(d2  ,0,nmatres*sizeof (double));
    #####: 6171:  memset(q2  ,0,nmatres*sizeof (double));
    #####: 6172:  memset(r2  ,0,nmatres*sizeof (double));
    #####: 6173:  memset(s2  ,0,nmatres*sizeof (double));
    #####: 6174:  memset(hit2,0,nmatres*sizeof (double));
        -: 6175:
        -: 6176:  //==========================================
        -: 6177:  //=  Compute second member
        -: 6178:  //=
        -: 6179:  //=
        -: 6180:  long l,m;
        -: 6181:
        -: 6182:  ////// BUILD B2
        -: 6183:
    #####: 6184:  for (k=0;k<nnbpix;k++)  {
        -: 6185:    //long imat=the_stat_pix[k];
    #####: 6186:    long ndata = loc_nhpix[k];
    #####: 6187:    hpix *htmp = loc_hpix[k];
    #####: 6188:    II[k]=0;
    #####: 6189:    IQ[k]=0;
    #####: 6190:    IU[k]=0;
    #####: 6191:    QQ[k]=0;
    #####: 6192:    UU[k]=0;
    #####: 6193:    QU[k]=0;
        -: 6194:
    #####: 6195:    for (l1=0;l1<ndata;l1++) {
    #####: 6196:      long ri1=htmp[l1].hrg-globalBeginRing*CUTRG;
    #####: 6197:      double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 6198:                                        -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 6199:      double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 6200:                                        +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 6201:      if (flg_rg[htmp[l1].ib][ri1/CUTRG]!=0) {
    #####: 6202:        II[k]+=htmp[l1].w;
    #####: 6203:        IQ[k]+=htmp[l1].w*CO1;
    #####: 6204:        IU[k]+=htmp[l1].w*SI1;
    #####: 6205:        QQ[k]+=htmp[l1].w*CO1*CO1;
    #####: 6206:        QU[k]+=htmp[l1].w*SI1*CO1;
    #####: 6207:        UU[k]+=htmp[l1].w*SI1*SI1;
        -: 6208:      }
        -: 6209:    }
        -: 6210:
    #####: 6211:    if (ndata>0&&flgpix[k]>0) {
        -: 6212:
    #####: 6213:      double SI=0;
    #####: 6214:      double SQ=0;
    #####: 6215:      double SU=0;
    #####: 6216:      for (l1=0;l1<ndata;l1++) {
    #####: 6217:        long ri1=htmp[l1].rg-globalBeginRing;
        -: 6218:        //long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
        -: 6219:
    #####: 6220:        double g1=gain[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 6221:
    #####: 6222:        ri1=htmp[l1].hrg-globalBeginRing*CUTRG;
        -: 6223:        //iri1=rgord2[htmp[l1].ib][ri1]+newnr2[htmp[l1].ib];
    #####: 6224:        double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 6225:                                          -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 6226:        double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 6227:                                          +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 6228:        if (flg_rg[htmp[l1].ib][ri1/CUTRG]!=0) {
        -: 6229:
    #####: 6230:          double tmp=0;
        -: 6231:
    #####: 6232:          if (nmatco>0) {
    #####: 6233:            tmp+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib]*htmp[l1].comap;
        -: 6234:          }
    #####: 6235:          if (nmatdust>0) {
    #####: 6236:            tmp+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib]*htmp[l1].dustmap;
        -: 6237:          }
    #####: 6238:          if (nfreefree>0) {
    #####: 6239:            tmp+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib]*htmp[l1].freefree;
        -: 6240:          }
        -: 6241:
    #####: 6242:          if (ittt>0) {
    #####: 6243:            for (m=0;m<npixbeam;m++) {
    #####: 6244:              tmp+= htmp[l1].listofpix[m]*
    #####: 6245:                ix2[newnr[nbolo]+nbolo*GAINSTEP+htmp[l1].ib+m*nbolo];
        -: 6246:            }
        -: 6247:          }
        -: 6248:
    #####: 6249:          double msig=((htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].dip-htmp[l1].corr_nl-htmp[l1].corr_cnn)-tmp);
        -: 6250:
    #####: 6251:          SI+=htmp[l1].w*msig;
    #####: 6252:          SQ+=htmp[l1].w*msig*CO1;
    #####: 6253:          SU+=htmp[l1].w*msig*SI1;
        -: 6254:        }
        -: 6255:      }
        -: 6256:
        -: 6257:
    #####: 6258:      solvemap(&SI,&SQ,&SU,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
    #####: 6259:      SSI[k]=SI;
    #####: 6260:      SSQ[k]=SQ;
    #####: 6261:      SSU[k]=SU;
        -: 6262:
    #####: 6263:      for (l1=0;l1<ndata;l1++) {
    #####: 6264:	htmp[l1].vi=UNSEENPIX;
    #####: 6265:        long ri1=htmp[l1].hrg-globalBeginRing*CUTRG;
    #####: 6266:        double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 6267:                                          -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 6268:        double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 6269:                                          +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 6270:        if (flg_rg[htmp[l1].ib][ri1/CUTRG]!=0) {
    #####: 6271:          double li=htmp[l1].w,lco=CO1*htmp[l1].w,lsi=SI1*htmp[l1].w;
    #####: 6272:          solvemap(&li,&lco,&lsi,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
    #####: 6273:          htmp[l1].vi=li;
    #####: 6274:          htmp[l1].vq=lco;
    #####: 6275:          htmp[l1].vu=lsi;
        -: 6276:        }
        -: 6277:      }
        -: 6278:
        -: 6279:#if 1
    #####: 6280:      for (l1=0;l1<ndata;l1++) {
    #####: 6281:        long ri1=htmp[l1].rg-globalBeginRing;
    #####: 6282:        long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
        -: 6283:
    #####: 6284:        double g1=gain[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 6285:
    #####: 6286:        ri1=htmp[l1].hrg-globalBeginRing*CUTRG;
    #####: 6287:	if (ri1>globalRangeRing*CUTRG) {
    #####: 6288:	  fprintf(stderr,"%d : %ld %ld\n",rank,(long) htmp[l1].hrg,(long) ri1);
    #####: 6289:	  exit(0);
        -: 6290:	}
    #####: 6291:        iri1=rgord2[htmp[l1].ib][ri1]+newnr2[htmp[l1].ib];
    #####: 6292:        double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 6293:                                          -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 6294:        double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 6295:                                          +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 6296:        if (flg_rg[htmp[l1].ib][ri1/CUTRG]!=0) {
        -: 6297:
    #####: 6298:          double tmp=0;
        -: 6299:
        -: 6300:
    #####: 6301:          if (nmatco>0) {
    #####: 6302:            tmp+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib]*htmp[l1].comap;
        -: 6303:          }
    #####: 6304:          if (nmatdust>0) {
    #####: 6305:            tmp+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib]*htmp[l1].dustmap;
        -: 6306:          }
    #####: 6307:          if (nfreefree>0) {
    #####: 6308:            tmp+=ix2[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib]*htmp[l1].freefree;
        -: 6309:          }
        -: 6310:
    #####: 6311:	  if (isnan(tmp)) {
    #####: 6312:		fprintf(stderr,"%d ISNAN\n",__LINE__);
    #####: 6313:		exit(0);
        -: 6314:          }
        -: 6315:
    #####: 6316:          if (ittt>0) {
    #####: 6317:            for (m=0;m<npixbeam;m++) {
    #####: 6318:              tmp+= htmp[l1].listofpix[m]*
    #####: 6319:                ix2[newnr[nbolo]+nbolo*GAINSTEP+htmp[l1].ib+m*nbolo];
        -: 6320:            }
        -: 6321:          }
        -: 6322:
    #####: 6323:          if (isnan(tmp)) {
    #####: 6324:                fprintf(stderr,"%d ISNAN\n",__LINE__);
    #####: 6325:                exit(0);
        -: 6326:          }
        -: 6327:
    #####: 6328:          double msig=((htmp[l1].sig*g1-htmp[l1].fsl-htmp[l1].dip-htmp[l1].corr_nl-htmp[l1].corr_cnn)-tmp);
        -: 6329:
    #####: 6330:          double ww=htmp[l1].wp;
    #####: 6331:          tmp=(msig-(SSI[k]+CO1*SSQ[k]+SI1*SSU[k]));
        -: 6332:          long l3;
    #####: 6333:          for (l3=0;l3<ndata;l3++) {
    #####: 6334:            long ri3=htmp[l3].hrg-globalBeginRing*CUTRG;
    #####: 6335:            if (flg_rg[htmp[l3].ib][ri3/CUTRG]!=0) {
    #####: 6336:              long ir3=rgord2[htmp[l3].ib][ri3]+newnr2[htmp[l3].ib];
    #####: 6337:              ctmp[ir3]=-(htmp[l3].vi+CO1*htmp[l3].vq+SI1*htmp[l3].vu);
        -: 6338:            }
        -: 6339:          }
    #####: 6340:          ctmp[iri1]+=1;
        -: 6341:
    #####: 6342:          if (isnan(tmp)) {
    #####: 6343:                fprintf(stderr,"%d ISNAN\n",__LINE__);
    #####: 6344:                exit(0);
        -: 6345:          }
        -: 6346:
        -: 6347:          /////////////////  OFFSET
    #####: 6348:          for (l2=0;l2<ndata;l2++) {
    #####: 6349:            long ri2=htmp[l2].hrg-globalBeginRing*CUTRG;
    #####: 6350:            if (flg_rg[htmp[l2].ib][ri2/CUTRG]!=0) {
    #####: 6351:              long ir=rgord2[htmp[l2].ib][ri2]+newnr2[htmp[l2].ib];
    #####: 6352:              b2[ir]+=ww*tmp*ctmp[ir];
    #####: 6353:              hit2[ir]+=ww*ctmp[ir]*ctmp[ir];
        -: 6354:
    #####: 6355:          if (isnan(b2[ir])) {
    #####: 6356:                fprintf(stderr,"%d ISNAN\n",__LINE__);
    #####: 6357:                exit(0);
        -: 6358:          }
        -: 6359:
        -: 6360:            }
        -: 6361:          }
        -: 6362:        }
        -: 6363:      }
        -: 6364:#endif
        -: 6365:    }
        -: 6366:  }
        -: 6367:
        -: 6368:#ifdef OPTIMPI
        -: 6369:  {
    #####: 6370:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
    #####: 6371:    MPI_Reduce(b2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 6372:
    #####: 6373:    memcpy(b2,lb,sizeof(double)*(nmatres));
    #####: 6374:    free(lb);
        -: 6375:  }
        -: 6376:#else
        -: 6377:  if (rank==0) {
        -: 6378:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 6379:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 6380:      MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
        -: 6381:      for (l=0;l<nmatres;l++) b2[l]+=lb[l];
        -: 6382:    }
        -: 6383:    free(lb);
        -: 6384:  }
        -: 6385:  else MPI_Send(b2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1031, MPI_COMM_WORLD);
        -: 6386:#endif
        -: 6387:#ifdef OPTIMPI
        -: 6388:  {
    #####: 6389:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
    #####: 6390:    MPI_Reduce(hit2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 6391:
    #####: 6392:    memcpy(hit2,lb,sizeof(double)*(nmatres));
    #####: 6393:    free(lb);
        -: 6394:  }
        -: 6395:#else
        -: 6396:  if (rank==0) {
        -: 6397:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 6398:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 6399:      MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1033, MPI_COMM_WORLD,&statu);
        -: 6400:
        -: 6401:      for (l=0;l<nmatres;l++) hit2[l]+=lb[l];
        -: 6402:    }
        -: 6403:    free(lb);
        -: 6404:  }
        -: 6405:  else {
        -: 6406:    MPI_Send(hit2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1033, MPI_COMM_WORLD);
        -: 6407:  }
        -: 6408:#endif
        -: 6409:
        -: 6410:  // starting point x = solution
    #####: 6411:  memset(x3  ,0,nmatres*sizeof (double));
        -: 6412:
        -: 6413:  //==========================================================
        -: 6414:  // Compute Ax
        -: 6415:  //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, x, q);
        -: 6416:  // +
        -: 6417:  // Preconditionnement
        -: 6418:  //
        -: 6419:  //
        -: 6420:
    #####: 6421:  for (l=0;l<nmatres;l++) q2[l]=0;
    #####: 6422:  if (rank==0) {
        -: 6423:
    #####: 6424:    double soff=0;
    #####: 6425:    for (i=0;i<newnr2[nbolo];i++) soff+=hit2[0]*x3[i];
    #####: 6426:    for (i=0;i<newnr2[nbolo];i++) q2[i]=soff;
        -: 6427:  }
        -: 6428:
        -: 6429:#ifdef TIMING
        -: 6430:#define TIMING
        -: 6431:  long maxhit=0;
        -: 6432:  for (k=0;k<nnbpix;k++) if (flgpix[k]>0) {
        -: 6433:    long ndata = loc_nhpix[k];
        -: 6434:    if (ndata>maxhit) maxhit=ndata;
        -: 6435:  }
        -: 6436:  if (rank==0) fprintf(stderr,"rank %ld %ld\n",(long) rank,(long) maxhit);
        -: 6437:  double *dthit = (double *) malloc(maxhit*sizeof(double));
        -: 6438:  double *ndthit = (double *) malloc(maxhit*sizeof(double));
        -: 6439:  memset(dthit,0,maxhit*sizeof(double));
        -: 6440:  memset(ndthit,0,maxhit*sizeof(double));
        -: 6441:#endif
    #####: 6442:  for (k=0;k<nnbpix;k++) if (flgpix[k]>0) {
        -: 6443:
        -: 6444:    //long imat=the_stat_pix[k];
    #####: 6445:    long ndata = loc_nhpix[k];
    #####: 6446:    if (ndata>0) {
        -: 6447:#ifdef TIMING
        -: 6448:      gettimeofday(&tp1,NULL);
        -: 6449:#endif
    #####: 6450:      hpix *htmp = loc_hpix[k];
        -: 6451:
        -: 6452:#ifdef TRUECP
        -: 6453:#else
    #####: 6454:      double vali=0,valq=0,valu=0;
        -: 6455:      long l3;
    #####: 6456:      for (l3=0;l3<ndata;l3++) {
    #####: 6457:        long ri3=htmp[l3].hrg-globalBeginRing*CUTRG;
    #####: 6458:        if (flg_rg[htmp[l3].ib][ri3/CUTRG]!=0) {
    #####: 6459:          long ir3=rgord2[htmp[l3].ib][ri3]+newnr2[htmp[l3].ib];
    #####: 6460:          vali+=htmp[l3].vi*x3[ir3];
    #####: 6461:          valq+=htmp[l3].vq*x3[ir3];
    #####: 6462:          valu+=htmp[l3].vu*x3[ir3];
        -: 6463:        }
        -: 6464:      }
    #####: 6465:      double qri=0;
    #####: 6466:      double qrq=0;
    #####: 6467:      double qru=0;
        -: 6468:#endif
    #####: 6469:      for (l1=0;l1<ndata;l1++) {
    #####: 6470:        long ri1=htmp[l1].hrg-globalBeginRing*CUTRG;
    #####: 6471:        long iri1=rgord2[htmp[l1].ib][ri1]+newnr2[htmp[l1].ib];
    #####: 6472:        double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 6473:                                          -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 6474:        double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 6475:                                          +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 6476:        if (flg_rg[htmp[l1].ib][ri1/CUTRG]!=0) {
    #####: 6477:          double ww=htmp[l1].wp;
    #####: 6478:          double val2=x3[iri1]-(vali+CO1*valq+SI1*valu);
        -: 6479:
    #####: 6480:          qri-=ww*val2;
    #####: 6481:          qrq-=ww*val2*CO1;
    #####: 6482:          qru-=ww*val2*SI1;
        -: 6483:
    #####: 6484:          q2[iri1]+=ww*val2;
        -: 6485:        }
        -: 6486:      }
        -: 6487:#ifdef TRUECP
        -: 6488:#else
        -: 6489:
    #####: 6490:      for (l2=0;l2<ndata;l2++) {
    #####: 6491:        long ri2=htmp[l2].hrg-globalBeginRing*CUTRG;
    #####: 6492:        if (flg_rg[htmp[l2].ib][ri2/CUTRG]!=0) {
    #####: 6493:          long ir=rgord2[htmp[l2].ib][ri2]+newnr2[htmp[l2].ib];
    #####: 6494:          q2[ir]+=qri*htmp[l2].vi+qrq*htmp[l2].vq+qru*htmp[l2].vu;
        -: 6495:        }
        -: 6496:      }
        -: 6497:#endif
        -: 6498:
        -: 6499:#ifdef TIMING
        -: 6500:      gettimeofday(&tp2,NULL);
        -: 6501:      double dt=(double)(tp2.tv_sec-tp1.tv_sec)+(1E-6)*(tp2.tv_usec-tp1.tv_usec);
        -: 6502:      dthit[ndata]+=dt;
        -: 6503:      ndthit[ndata]+=1;
        -: 6504:#endif
        -: 6505:    }
        -: 6506:  }
        -: 6507:#ifdef OPTIMPI
        -: 6508:  {
    #####: 6509:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
    #####: 6510:    MPI_Reduce(q2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 6511:
    #####: 6512:    memcpy(q2,lb,sizeof(double)*(nmatres));
    #####: 6513:    free(lb);
        -: 6514:  }
        -: 6515:#else
        -: 6516:  if (rank==0) {
        -: 6517:    double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 6518:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 6519:      MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1032, MPI_COMM_WORLD,&statu);
        -: 6520:      for (l=0;l<nmatres;l++) q2[l]+=lb[l];
        -: 6521:    }
        -: 6522:    free(lb);
        -: 6523:  }
        -: 6524:  else {
        -: 6525:    MPI_Send(q2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1032, MPI_COMM_WORLD);
        -: 6526:  }
        -: 6527:#endif
        -: 6528:
    #####: 6529:  if (rank==0) {
    #####: 6530:    for (i=0; i < nmatres; i++)
        -: 6531:      {
    #####: 6532:        r2[i] = b2[i] - q2[i];
    #####: 6533:        d2[i] = r2[i] / hit2[i];
        -: 6534:      }
        -: 6535:  }
        -: 6536:
        -: 6537:
    #####: 6538:  double delta_new_tmp = 0.0;
    #####: 6539:  if (rank==0) {
    #####: 6540:    for (i = 0; i < nmatres; i++) {
    #####: 6541:      delta_new_tmp += b2[i] ;
    #####: 6542:      if (isnan(b2[i])) {
    #####: 6543:        fprintf(stderr,"NAN B2 PBS %ld\n",(long) i);
        -: 6544:      }
        -: 6545:
    #####: 6546:      if (isnan(q2[i])) {
    #####: 6547:        fprintf(stderr,"NAN Q2 PBS %ld\n",(long) i);
    #####: 6548:	exit(0);
        -: 6549:      }
        -: 6550:
    #####: 6551:      if (isnan(d2[i])) {
    #####: 6552:        fprintf(stderr,"NAN D2 PBS %ld %lg %lg %lg\n",(long) i,hit2[i],b2[i],q2[i]);
    #####: 6553:	exit(0);
        -: 6554:      }
        -: 6555:    }
        -: 6556:    //fprintf(stderr,"B2 %lg\n",delta_new_tmp);
        -: 6557:
    #####: 6558:    delta_new_tmp = 0.0;
    #####: 6559:    for (i = 0; i < nmatres; i++) {
    #####: 6560:      delta_new_tmp += q2[i] ;
    #####: 6561:      if (isnan(q2[i])) {
    #####: 6562:        fprintf(stderr,"NAN Q2 PBS %ld\n",(long) i);
        -: 6563:      }
        -: 6564:    }
        -: 6565:    //fprintf(stderr,"Q2 %lg\n",delta_new_tmp);
    #####: 6566:    delta_new_tmp = 0.0;
    #####: 6567:    for (i = 0; i < nmatres; i++) {
    #####: 6568:      delta_new_tmp += q2[i]-b2[i] ;
        -: 6569:      //fprintf(stderr,"B2 Q2 B2-Q2 [%ld]: %lg\t%lg\t%lg\n",(long) i,b2[i],q2[i],q2[i]-b2[i]);
        -: 6570:    }
        -: 6571:  }
        -: 6572:
    #####: 6573:  delta_new_tmp = 0.0;
    #####: 6574:  if (rank==0) for (i=0; i < nmatres; i++) {
    #####: 6575:    delta_new_tmp += r2[i] * d2[i];
        -: 6576:  }
        -: 6577:
    #####: 6578:  delta_new=0;
    #####: 6579:  for (i=0;i<mpi_size;i++) {
    #####: 6580:    double tmp=delta_new_tmp;
    #####: 6581:    MPI_Bcast(&tmp, sizeof(double), MPI_BYTE, i, MPI_COMM_WORLD);
    #####: 6582:    delta_new+=tmp;
        -: 6583:  }
    #####: 6584:  if (itbogo==0) delta0 = delta_new;
    #####: 6585:  if (rank==0) fprintf (stderr, "min_opt() iter = %d - delta0 = %lg - delta_new = %lg\n", iter, delta0, delta_new);
    #####: 6586:  int testwrit=0;
        -: 6587:
    #####: 6588:  MPI_Bcast(&delta0, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
    #####: 6589:  MPI_Bcast(&delta_new, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 6590:
    #####: 6591:  while ((iter < itermax)  && ((delta_new) > delta0*1E-24)) //Param->XI2STOP))
        -: 6592:    {
        -: 6593:      // q <= Ad
    #####: 6594:      if (rank==0) {
    #####: 6595:        memcpy(x2old,x3,nmatres*sizeof(double));
    #####: 6596:        testwrit=1;
        -: 6597:      }
        -: 6598:        //else testwrit=0;
        -: 6599:
        -: 6600:      //healspline_fill_s_with_PtP_s (hs_rec, Ndata, vec, d, q);
        -: 6601:      //for (i=0;i<mpi_size;i++) {
        -: 6602:      //MPI_Bcast(d+tab_begr[i]*2, sizeof(double)*(tab_edr[i]-tab_begr[i]+1)*2, MPI_BYTE, i, MPI_COMM_WORLD);
        -: 6603:      //}
    #####: 6604:      MPI_Bcast(d2, sizeof(double)*(nmatres), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 6605:
        -: 6606:      // ===========================================================================
        -: 6607:      // PROJECTION DE d dans q
        -: 6608:      //
        -: 6609:
    #####: 6610:      for (l=0;l<nmatres;l++) q2[l]=0;
    #####: 6611:      if (rank==0) {
    #####: 6612:        double soff=0;
    #####: 6613:        for (i=0;i<newnr2[nbolo];i++) soff+=hit2[0]*d2[i];
    #####: 6614:        for (i=0;i<newnr2[nbolo];i++) q2[i]=soff;
        -: 6615:      }
        -: 6616:
    #####: 6617:      for (k=0;k<nnbpix;k++) if (flgpix[k]>0) {
        -: 6618:
        -: 6619:        //long imat=the_stat_pix[k];
    #####: 6620:        long ndata = loc_nhpix[k];
    #####: 6621:        if (ndata>0) {
    #####: 6622:          hpix *htmp = loc_hpix[k];
        -: 6623:
        -: 6624:#ifdef TRUECP
        -: 6625:#else
    #####: 6626:          double vali=0,valq=0,valu=0;
        -: 6627:          long l3;
    #####: 6628:          for (l3=0;l3<ndata;l3++) {
    #####: 6629:            long ri3=htmp[l3].hrg-globalBeginRing*CUTRG;
    #####: 6630:            if (flg_rg[htmp[l3].ib][ri3/CUTRG]!=0) {
    #####: 6631:              long ir3=rgord2[htmp[l3].ib][ri3]+newnr2[htmp[l3].ib];
    #####: 6632:              vali+=htmp[l3].vi*d2[ir3];
    #####: 6633:              valq+=htmp[l3].vq*d2[ir3];
    #####: 6634:              valu+=htmp[l3].vu*d2[ir3];
        -: 6635:            }
        -: 6636:          }
        -: 6637:
    #####: 6638:          double qri=0;
    #####: 6639:          double qrq=0;
    #####: 6640:          double qru=0;
        -: 6641:#endif
    #####: 6642:          for (l1=0;l1<ndata;l1++) {
    #####: 6643:            long ri1=htmp[l1].hrg-globalBeginRing*CUTRG;
    #####: 6644:            long iri1=rgord2[htmp[l1].ib][ri1]+newnr2[htmp[l1].ib];
    #####: 6645:            double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 6646:                                              -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 6647:            double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 6648:                                              +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 6649:            if (flg_rg[htmp[l1].ib][ri1/CUTRG]!=0) {
    #####: 6650:              double ww=htmp[l1].wp;
    #####: 6651:              double val2=d2[iri1]-(vali+CO1*valq+SI1*valu);
    #####: 6652:              qri-=ww*val2;
    #####: 6653:              qrq-=ww*val2*CO1;
    #####: 6654:              qru-=ww*val2*SI1;
        -: 6655:
    #####: 6656:              q2[iri1]+=ww*val2;
        -: 6657:            }
        -: 6658:          }
        -: 6659:#ifdef TRUECP
        -: 6660:#else
    #####: 6661:          for (l2=0;l2<ndata;l2++) {
    #####: 6662:            long ri2=htmp[l2].hrg-globalBeginRing*CUTRG;
    #####: 6663:            if (flg_rg[htmp[l2].ib][ri2/CUTRG]!=0) {
    #####: 6664:              long ir=rgord2[htmp[l2].ib][ri2]+newnr2[htmp[l2].ib];
    #####: 6665:              q2[ir]+=qri*htmp[l2].vi+qrq*htmp[l2].vq+qru*htmp[l2].vu;
        -: 6666:            }
        -: 6667:          }
        -: 6668:        }
        -: 6669:#endif
        -: 6670:      }
        -: 6671:#ifdef OPTIMPI
        -: 6672:      {
    #####: 6673:	double *lb = (double *) malloc(sizeof(double)*(nmatres));
    #####: 6674:	MPI_Reduce(q2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 6675:
    #####: 6676:	memcpy(q2,lb,sizeof(double)*(nmatres));
    #####: 6677:	free(lb);
        -: 6678:      }
        -: 6679:#else
        -: 6680:      if (rank==0) {
        -: 6681:        double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 6682:        for (rrk=1;rrk<mpi_size;rrk++) {
        -: 6683:          MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1034, MPI_COMM_WORLD,&statu);
        -: 6684:          for (l=0;l<nmatres;l++) q2[l]+=lb[l];
        -: 6685:        }
        -: 6686:        free(lb);
        -: 6687:      }
        -: 6688:      else {
        -: 6689:        MPI_Send(q2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1034, MPI_COMM_WORLD);
        -: 6690:      }
        -: 6691:#endif
        -: 6692:
    #####: 6693:      double dtq = 0.0;
    #####: 6694:      if (rank==0) {
    #####: 6695:        for (i=0; i < nmatres; i++) dtq += d2[i] * q2[i];
    #####: 6696:        alpha = delta_new / dtq;
    #####: 6697:        for (i=0; i < nmatres ; i++) x3[i] += alpha * d2[i];
        -: 6698:#if 0
        -: 6699:        char tmpfile[256];
        -: 6700:        sprintf(tmpfile,"/data/delouis/TESTXI2/ITT_%d",(int) iter);
        -: 6701:        FILE* fp=fopen(tmpfile,"w");
        -: 6702:        fwrite(x3,nmatres*sizeof(double),1,fp);
        -: 6703:        fclose(fp);
        -: 6704:#endif
        -: 6705:      }
        -: 6706:
        -: 6707:
    #####: 6708:      gettimeofday(&tp2,NULL);
    #####: 6709:      if (rank==0&&iter%10==0) fprintf (stderr,"min_opt() iter = %d - delta0 = %lg - delta_new = %lg %ld %3lfs\n", iter, delta0, delta_new,
    #####: 6710:                    (long) testwrit,(double)(tp2.tv_sec-tp1.tv_sec)+(1E-6)*(tp2.tv_usec-tp1.tv_usec));
        -: 6711:
        -: 6712:      //if (rank==0) fprintf (stderr,".");
    #####: 6713:      gettimeofday(&tp1,NULL);
        -: 6714:
    #####: 6715:      if (iter % 100 == 0 && iter !=0)
    #####: 6716:        {
        -: 6717:          // Use the best case
    #####: 6718:          memcpy(x3,x2old,nmatres*sizeof(double));
        -: 6719:          //for (i=0;i<mpi_size;i++) {
        -: 6720:          //  MPI_Bcast(x+tab_begr[i]*2, sizeof(double)*(tab_edr[i]-tab_begr[i]+1)*2, MPI_BYTE, i, MPI_COMM_WORLD);
        -: 6721:          //}
    #####: 6722:          MPI_Bcast(x3, sizeof(double)*(nmatres), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 6723:
        -: 6724:
        -: 6725:      // ===========================================================================
        -: 6726:      // PROJECTION DE x dans q
        -: 6727:      //
        -: 6728:
    #####: 6729:          for (l=0;l<nmatres;l++) q2[l]=0;
    #####: 6730:          double soff=0;
    #####: 6731:          for (i=0;i<newnr2[nbolo];i++) soff+=hit2[0]*x3[i];
    #####: 6732:          for (i=0;i<newnr2[nbolo];i++) q2[i]=soff;
        -: 6733:
    #####: 6734:          for (k=0;k<nnbpix;k++) if (flgpix[k]>0) {
        -: 6735:
        -: 6736:            //long imat=the_stat_pix[k];
    #####: 6737:            long ndata = loc_nhpix[k];
    #####: 6738:            if (ndata>0) {
    #####: 6739:              hpix *htmp = loc_hpix[k];
        -: 6740:
        -: 6741:#ifdef TRUECP
        -: 6742:#else
    #####: 6743:              double vali=0,valq=0,valu=0;
        -: 6744:              long l3;
    #####: 6745:              for (l3=0;l3<ndata;l3++) {
    #####: 6746:                long ri3=htmp[l3].hrg-globalBeginRing*CUTRG;
    #####: 6747:                if (flg_rg[htmp[l3].ib][ri3/CUTRG]!=0) {
    #####: 6748:                  long ir3=rgord2[htmp[l3].ib][ri3]+newnr2[htmp[l3].ib];
    #####: 6749:                  vali+=htmp[l3].vi*x3[ir3];
    #####: 6750:                  valq+=htmp[l3].vq*x3[ir3];
    #####: 6751:                  valu+=htmp[l3].vu*x3[ir3];
        -: 6752:                }
        -: 6753:              }
    #####: 6754:              double qri=0;
    #####: 6755:              double qrq=0;
    #####: 6756:              double qru=0;
        -: 6757:#endif
    #####: 6758:              for (l1=0;l1<ndata;l1++) {
    #####: 6759:                long ri1=htmp[l1].hrg-globalBeginRing*CUTRG;
    #####: 6760:                long iri1=rgord2[htmp[l1].ib][ri1]+newnr2[htmp[l1].ib];
    #####: 6761:                double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####: 6762:                                                  -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####: 6763:                double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####: 6764:                                                  +dpsisi[htmp[l1].ib]*htmp[l1].co);
    #####: 6765:                if (flg_rg[htmp[l1].ib][ri1/CUTRG]!=0) {
    #####: 6766:                  double ww=htmp[l1].wp;
    #####: 6767:                  double val2=x3[iri1]-(vali+CO1*valq+SI1*valu);
    #####: 6768:                  qri-=ww*val2;
    #####: 6769:                  qrq-=ww*val2*CO1;
    #####: 6770:                  qru-=ww*val2*SI1;
        -: 6771:
    #####: 6772:                  q2[iri1]+=ww*val2;
        -: 6773:                }
        -: 6774:              }
        -: 6775:#ifdef TRUECP
        -: 6776:#else
    #####: 6777:              for (l2=0;l2<ndata;l2++) {
    #####: 6778:                long ri2=htmp[l2].hrg-globalBeginRing*CUTRG;
    #####: 6779:                if (flg_rg[htmp[l2].ib][ri2/CUTRG]!=0) {
    #####: 6780:                  long ir=rgord2[htmp[l2].ib][ri2]+newnr2[htmp[l2].ib];
    #####: 6781:                  q2[ir]+=qri*htmp[l2].vi+qrq*htmp[l2].vq+qru*htmp[l2].vu;
        -: 6782:                }
        -: 6783:              }
        -: 6784:#endif
        -: 6785:
        -: 6786:            }
        -: 6787:          }
        -: 6788:#ifdef OPTIMPI
        -: 6789:	  {
    #####: 6790:	    double *lb = (double *) malloc(sizeof(double)*(nmatres));
    #####: 6791:	    MPI_Reduce(q2,lb,nmatres,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -: 6792:
    #####: 6793:	    memcpy(q2,lb,sizeof(double)*(nmatres));
    #####: 6794:	    free(lb);
        -: 6795:	  }
        -: 6796:#else
        -: 6797:          if (rank==0) {
        -: 6798:            double *lb = (double *) malloc(sizeof(double)*(nmatres));
        -: 6799:            for (rrk=1;rrk<mpi_size;rrk++) {
        -: 6800:              MPI_Recv(lb,sizeof(double)*(nmatres), MPI_BYTE, rrk,1034, MPI_COMM_WORLD,&statu);
        -: 6801:              for (l=0;l<nmatres;l++) q2[l]+=lb[l];
        -: 6802:            }
        -: 6803:
        -: 6804:            free(lb);
        -: 6805:          }
        -: 6806:          else {
        -: 6807:            MPI_Send(q2, sizeof(double)*(nmatres), MPI_BYTE, 0, 1034, MPI_COMM_WORLD);
        -: 6808:          }
        -: 6809:#endif
        -: 6810:
    #####: 6811:          if (rank==0) for (i=0; i < nmatres; i++) {
    #####: 6812:            r2[i] = b2[i] - q2[i];
        -: 6813:          }
        -: 6814:
        -: 6815:        }
        -: 6816:      else
        -: 6817:        {
    #####: 6818:          if (rank==0) for (i=0; i < nmatres; i++) r2[i] -= alpha * q2[i];
        -: 6819:        }
        -: 6820:
    #####: 6821:      if (rank==0) for (i=0; i < nmatres; i++) s2[i] = r2[i] / hit2[i];
        -: 6822:
    #####: 6823:      delta_old = delta_new;
    #####: 6824:      if (rank==0) {
    #####: 6825:        delta_new=0;
    #####: 6826:        for (i=0; i < nmatres ; i++) delta_new += r2[i] * s2[i];
    #####: 6827:        beta = delta_new / delta_old;
    #####: 6828:        for (i=0; i < nmatres ; i++) d2[i] = s2[i] + beta * d2[i];
        -: 6829:      }
    #####: 6830:      iter ++;
    #####: 6831:      MPI_Bcast(&delta_new, sizeof(double), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 6832:
        -: 6833:    }
        -: 6834:
    #####: 6835:  if (rank==0) fprintf (stderr,"\nmin_opt() iter = %d - delta0 = %lg - delta_new = %lg\n",
        -: 6836:                        iter, delta0, delta_new);
    #####: 6837:  if (rank==0) fprintf (stderr,"CG in iter = %d (max=%d)\n", iter, itermax);
        -: 6838:
    #####: 6839:  if (rank==0) memcpy(x3  ,x2old,nmatres*sizeof (double));
    #####: 6840:  MPI_Bcast(x3, sizeof(double)*(nmatres), MPI_BYTE, 0, MPI_COMM_WORLD);
    #####: 6841:  itbogo++;
    #####: 6842:}
        -: 6843:
        -: 6844:double avv_poleff=-1;
        -: 6845:PyObject *cnn_coef=NULL;
        -: 6846:PyObject *py_signal;
        -: 6847:PyObject *py_weights;
        -: 6848:PyObject *py_TCO1;
        -: 6849:PyObject *py_TSI1;
        -: 6850:PyObject *py_hidx;
        -: 6851:PyObject *py_idx;
        -: 6852:PyObject *mynetwork;
        -: 6853:PyObject *py_realpix;
        -: 6854:PyObject *myrun;
        -: 6855:PyObject *py_coef;
        -: 6856:PyObject *py_smap;
        -: 6857:
        -: 6858:int *recvcount;
        -: 6859:int *recvcounts;
        -: 6860:long nnbpixmax;
        -: 6861:long all_ndatamax;
        -: 6862:long offpix=0;
        -: 6863:
      720: 6864:void localreduce(double *in,double *tmp,int nval)
        -: 6865:{
      720: 6866:  memset(tmp,0,sizeof(double)*nval);
      720: 6867:  MPI_Allreduce(in,tmp,nval,MPI_DOUBLE, MPI_SUM,MPI_COMM_WORLD);
      720: 6868:  memcpy(in,tmp,nval*sizeof(double));
      720: 6869:}
        -: 6870:
       40: 6871:void fit_cnn(double *x3,double *gain,int out_itt)
        -: 6872:{ 
        -: 6873:  int rank,i,k,j,l,rrk,itt;
        -: 6874:  int size;
        -: 6875:  MPI_Status statu;
        -: 6876:  int mpi_size;
        -: 6877:  int rank_size;
       40: 6878:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
       40: 6879:  rank=rank_size;
       40: 6880:  MPI_Comm_size(MPI_COMM_WORLD,&size);
       40: 6881:  mpi_size=size;
        -: 6882:  int ib;
       40: 6883:  int **rgcnn=(int **) malloc(sizeof(int *)*nbolo);
        -: 6884:
      200: 6885:  for (i=0;i<nbolo;i++) {
      160: 6886:    rgcnn[i]=(int *) malloc(sizeof(int)*(globalEndRing+1));
      160: 6887:    FILE *l_fp=fopen(Param->rgcnn[i],"r");
      160: 6888:	if(l_fp != NULL ){
      160: 6889:	    fread(rgcnn[i],sizeof(int)*(globalEndRing+1),1,l_fp);
        -: 6890:    }else{
    #####: 6891:		fprintf(stderr,"ERROR NULL File => %s\n",Param->rgcnn[i]);
        -: 6892:	}
      160: 6893:	fclose(l_fp);
        -: 6894:  }
        -: 6895:
       40: 6896:  double *A0 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6897:  double *A1 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6898:  double *A2 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6899:  double *B0 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6900:  double *B1 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6901:  double *B2 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6902:  double *C0 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6903:  double *C1 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6904:  double *C2 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6905:  double *D0 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6906:  double *D1 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6907:  double *D2 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6908:  double *V00 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6909:  double *V01 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6910:  double *V02 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6911:  double *V10 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6912:  double *V11 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6913:  double *V12 = (double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
        -: 6914:
       40: 6915:  memset(A0,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6916:  memset(A1,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6917:  memset(A2,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6918:  memset(B0,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6919:  memset(B1,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6920:  memset(B2,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6921:  memset(C0,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6922:  memset(C1,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6923:  memset(C2,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6924:  memset(D0,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6925:  memset(D1,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6926:  memset(D2,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6927:  memset(V00,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6928:  memset(V01,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6929:  memset(V02,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6930:  memset(V10,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6931:  memset(V11,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 6932:  memset(V12,0,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
        -: 6933:
       40: 6934:  int *reduce_realpix = (int *) malloc(sizeof(int)*nnbpix);
       40: 6935:  int cnn_down = (2048/CNN_NSIDE)*(2048/CNN_NSIDE);
503316520: 6936:  for (i=0;i<nnbpix;i++){
        -: 6937:    long ipix;
503316480: 6938:    ring2nest(2048,realpix[i],&ipix);
503316480: 6939:    reduce_realpix[i]=ipix/cnn_down;
        -: 6940:  }
        -: 6941:  
       40: 6942:  int CNN_XSIZE=Param->CNN_XSIZE;
       40: 6943:  int CNN_YSIZE=Param->CNN_YSIZE;
       40: 6944:  float coefresidu=Param->CNN_RESIDU;
        -: 6945:
       40: 6946:  float *incorr = (float *) malloc(sizeof(float)*nbolo*CNN_XSIZE*CNN_YSIZE);
       40: 6947:  float *wincorr = (float *) malloc(sizeof(float)*nbolo*CNN_XSIZE*CNN_YSIZE);
        -: 6948:
       40: 6949:  memset(incorr,0,sizeof(float)*nbolo*CNN_XSIZE*CNN_YSIZE);
       40: 6950:  memset(wincorr,0,sizeof(float)*nbolo*CNN_XSIZE*CNN_YSIZE);
        -: 6951:
       40: 6952:  long all_ndata=0;
        -: 6953:  int l1,m;
        -: 6954:
503316520: 6955:  for (k=0;k<nnbpix;k++) {
        -: 6956:   // if (flgpix[k]>0) {
503316480: 6957:      long ndata = loc_nhpix[k];
503316480: 6958:      hpix *htmp = loc_hpix[k];
505280330: 6959:      for (l1=0;l1<ndata;l1++) {
  1963850: 6960:	long ri1=htmp[l1].rg-globalBeginRing;
  1963850: 6961:	if (flg_rg[htmp[l1].ib][ri1]!=0) {
  1963850: 6962:	  all_ndata+=1;
        -: 6963:	}
        -: 6964:      }
        -: 6965:  //  }
        -: 6966:  }
        -: 6967:
        -: 6968:  PyObject *arglist;
        -: 6969:
        -: 6970:  PyObject *mynetworkFSL;
        -: 6971:  
       40: 6972:  if (out_itt==0) {
        4: 6973:    if (python_rank==0) {
        4: 6974:      arglist = Py_BuildValue("(l)", (long) 4*12*32*32);
        -: 6975:
        4: 6976:      py_smap  = EXECPYTHON(PyObject_CallObject(MyPythonBackend.allocf32, arglist));
        -: 6977:      
        4: 6978:      arglist = Py_BuildValue("(s[s]llsss)", Param->CNN_WEIGHTS,pixnames[0],(long)rank,(long) Param->CNN_LEARN_PARAM,Param->CNN_TMPID,Param->MAP_CNN,Param->INST_CNN);
        4: 6979:      if (nbolo==4)
       12: 6980:	arglist = Py_BuildValue("(s[s,s,s,s]llsss)", Param->CNN_WEIGHTS,pixnames[0],pixnames[1],
       12: 6981:				pixnames[2],pixnames[3],(long)rank,(long) Param->CNN_LEARN_PARAM,Param->CNN_TMPID,Param->MAP_CNN,Param->INST_CNN);
        4: 6982:      if (nbolo==8)
    #####: 6983:	arglist = Py_BuildValue("(s[s,s,s,s,s,s,s,s]llsss)", Param->CNN_WEIGHTS,pixnames[0],pixnames[1],
    #####: 6984:				pixnames[2],pixnames[3],pixnames[4],pixnames[5],pixnames[6],pixnames[7],
    #####: 6985:				rank,(long) Param->CNN_LEARN_PARAM,Param->CNN_TMPID,Param->MAP_CNN,Param->INST_CNN);
        4: 6986:      if (nbolo==11)
    #####: 6987:	arglist = Py_BuildValue("(s[s,s,s,s,s,s,s,s,s,s,s]llsss)", Param->CNN_WEIGHTS,pixnames[0],pixnames[1],
    #####: 6988:				pixnames[2],pixnames[3],pixnames[4],pixnames[5],pixnames[6],pixnames[7],
    #####: 6989:				pixnames[8],pixnames[9],pixnames[10],
    #####: 6990:				rank,(long) Param->CNN_LEARN_PARAM,Param->CNN_TMPID,Param->MAP_CNN,Param->INST_CNN);
        4: 6991:      if (nbolo==12)
    #####: 6992:	arglist = Py_BuildValue("(s[s,s,s,s,s,s,s,s,s,s,s,s]llsss)", Param->CNN_WEIGHTS,pixnames[0],pixnames[1],
    #####: 6993:				pixnames[2],pixnames[3],pixnames[4],pixnames[5],pixnames[6],pixnames[7],
    #####: 6994:				pixnames[8],pixnames[9],pixnames[10],pixnames[11],
    #####: 6995:				rank,(long) Param->CNN_LEARN_PARAM,Param->CNN_TMPID,Param->MAP_CNN,Param->INST_CNN);
        4: 6996:      mynetwork=EXECPYTHON(PyObject_CallObject(MyPythonBackend.initFrom_Files, arglist));
        -: 6997:      //mynetwork=EXECPYTHON(PyObject_CallObject(MyPythonBackend.initFromFile, arglist));
        -: 6998:      //Py_DECREF(arglist);
        -: 6999:    }
        -: 7000:
        -: 7001:    //fprintf(stderr,"nnbpix %d %d\n",(int) rank,(int) nnbpix);
        -: 7002:    //fprintf(stderr,"all_ndata %d %d\n",(int) rank,(int) all_ndata);
        -: 7003:
        -: 7004:    
        4: 7005:    MPI_Reduce(&nnbpix,&nnbpixmax,1,MPI_LONG, MPI_SUM,0,python_comm);
        4: 7006:    MPI_Reduce(&all_ndata,&all_ndatamax,1,MPI_LONG, MPI_SUM,0,python_comm);
        -: 7007:
        4: 7008:    if (python_rank==0) {
        4: 7009:      fprintf(stderr,"MAX %d %d NNBPIX %ld\n",python_rank,rank,(long) nnbpixmax);
        4: 7010:      fprintf(stderr,"MAX %d %d ALL_NDATA %ld\n",python_rank,rank,(long) all_ndatamax);
        -: 7011:    }
        -: 7012:      
        4: 7013:    recvcount = (int *) malloc(sizeof(int)*mpi_python_size);
        4: 7014:    recvcounts = (int *) malloc(sizeof(int)*mpi_python_size);
        -: 7015:    
        4: 7016:    if (python_rank==0) {
        4: 7017:      arglist = Py_BuildValue("(l)", (long) nnbpixmax);
        4: 7018:      py_realpix = EXECPYTHON(PyObject_CallObject(MyPythonBackend.alloci32, arglist));
        -: 7019:    }
        -: 7020:      
        -: 7021:
        4: 7022:    MPI_Allgather(&nnbpix,1,MPI_INT,recvcount,1,MPI_INT,python_comm);
        -: 7023:    
        -: 7024:     
        4: 7025:    recvcounts[0]=0;
        4: 7026:    for (i=1;i<mpi_python_size;i++) recvcounts[i]=recvcounts[i-1]+recvcount[i-1];
        -: 7027:
        4: 7028:    offpix=recvcounts[python_rank];
        -: 7029:    
        -: 7030:    int *ires;
        4: 7031:    if (python_rank==0) {
        4: 7032:      ires=PyArray_DATA((PyArrayObject *)py_realpix);
        -: 7033:    }
    #####: 7034:    else ires=NULL;
        -: 7035:    
        4: 7036:    MPI_Gatherv(realpix,nnbpix,MPI_INT,ires,
        -: 7037:    		recvcount,recvcounts,MPI_INT,0,python_comm);
        -: 7038:
        -: 7039:    //convert realpix in nested
        4: 7040:    if (python_rank==0) {
 50331652: 7041:      for (i=0;i<nnbpixmax;i++){
        -: 7042:	long ipix;
 50331648: 7043:	ring2nest(2048,ires[i],&ipix);
 50331648: 7044:	ires[i]=ipix;
        -: 7045:      }
        -: 7046:    }
        -: 7047:    
        4: 7048:    MPI_Allgather(&all_ndata,1,MPI_INT,recvcount,1,MPI_INT,python_comm);
        -: 7049:
        4: 7050:    recvcounts[0]=0;
        4: 7051:    for (i=1;i<mpi_python_size;i++) {
    #####: 7052:      recvcounts[i]=recvcounts[i-1]+recvcount[i-1];
        -: 7053:      //if (rank==0) fprintf(stderr,"%d %d %d\n",i,recvcount[i],recvcounts[i]);
        -: 7054:    }
        -: 7055:
        -: 7056: 
        4: 7057:    if (python_rank==0) {
        4: 7058:      arglist = Py_BuildValue("(l)", (long) all_ndatamax);
        -: 7059:
        4: 7060:      py_signal  = EXECPYTHON(PyObject_CallObject(MyPythonBackend.allocf32, arglist));
        4: 7061:      py_weights = EXECPYTHON(PyObject_CallObject(MyPythonBackend.allocf32, arglist));
        4: 7062:      py_TCO1    = EXECPYTHON(PyObject_CallObject(MyPythonBackend.allocf32, arglist));
        4: 7063:      py_TSI1    = EXECPYTHON(PyObject_CallObject(MyPythonBackend.allocf32, arglist));
        4: 7064:      py_hidx    = EXECPYTHON(PyObject_CallObject(MyPythonBackend.alloci32, arglist));
        4: 7065:      py_idx     = EXECPYTHON(PyObject_CallObject(MyPythonBackend.alloci32, arglist));
        -: 7066:    }    
        -: 7067:  }
        -: 7068:
        -: 7069:  float *signal   ;
        -: 7070:  float *weights  ;
        -: 7071:  float *TCO1     ;
        -: 7072:  float *TSI1     ;
        -: 7073:  int   *hidx     ;
        -: 7074:  int   *idx      ;
       40: 7075:  signal  = (float * ) malloc(sizeof(float)*all_ndata);
       40: 7076:  weights = (float * ) malloc(sizeof(float)*all_ndata);
       40: 7077:  TCO1    = (float * ) malloc(sizeof(float)*all_ndata);
       40: 7078:  TSI1    = (float * ) malloc(sizeof(float)*all_ndata);
       40: 7079:  hidx    = (int * )   malloc(sizeof(int)*all_ndata);
       40: 7080:  idx     = (int * )   malloc(sizeof(int)*all_ndata);
        -: 7081:  
       40: 7082:  memset(signal,0,sizeof(float)*all_ndata);
       40: 7083:  memset(weights,0,sizeof(float)*all_ndata);
       40: 7084:  memset(TCO1,0,sizeof(float)*all_ndata);
       40: 7085:  memset(TSI1,0,sizeof(float)*all_ndata);
       40: 7086:  memset(hidx,0,sizeof(int)*all_ndata);
       40: 7087:  memset(idx,0,sizeof(int)*all_ndata);
        -: 7088:
       40: 7089:  all_ndata=0;
        -: 7090:
        -: 7091:  double sig2[4];
       40: 7092:  sig2[0]=0.0;
       40: 7093:  sig2[1]=0.0;
       40: 7094:  sig2[2]=0.0;
       40: 7095:  sig2[3]=0.0;
        -: 7096:
503316520: 7097:  for (k=0;k<nnbpix;k++) {
        -: 7098:   // if (flgpix[k]>0) {
        -: 7099:      double inmat[9];
        -: 7100:      double outmat[9];
503316480: 7101:      long ndata = loc_nhpix[k];
503316480: 7102:      hpix *htmp = loc_hpix[k];
        -: 7103:      
503316480: 7104:      double SII=0;
503316480: 7105:      double SIQ=0;
503316480: 7106:      double SIU=0;
503316480: 7107:      double SQQ=0;
503316480: 7108:      double SUU=0;
503316480: 7109:      double SQU=0;
        -: 7110:      
503316480: 7111:      double SI=0;
503316480: 7112:      double SQ=0;
503316480: 7113:      double SU=0;
        -: 7114:      
503316480: 7115:      double mapi=-1E30;
503316480: 7116:      double mapq=-1E30;
503316480: 7117:      double mapu=-1E30;
        -: 7118:      
505280330: 7119:      for (l1=0;l1<ndata;l1++) {
  1963850: 7120:	long ri1=htmp[l1].rg-globalBeginRing;
  1963850: 7121:	long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
  1963850: 7122:	if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 7123:	  
  3927700: 7124:	  double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
  1963850: 7125:					    -dpsisi[htmp[l1].ib]*htmp[l1].si);
  3927700: 7126:	  double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
  1963850: 7127:					    +dpsisi[htmp[l1].ib]*htmp[l1].co);
        -: 7128:	  
  1963850: 7129:	  double gg2=gain[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 7130:	  
  1963850: 7131:	  double sig_corr = htmp[l1].sig*gg2-htmp[l1].fsl;
        -: 7132:	  
  1963850: 7133:	  if (REMHDIP==0) sig_corr-=htmp[l1].dip;
  1963850: 7134:	  else sig_corr-=htmp[l1].freefree;
        -: 7135:	  
  1963850: 7136:	  sig_corr-=htmp[l1].corr_nl+htmp[l1].corr_cnn;
        -: 7137:	  
  1963850: 7138:	  sig_corr-=x3[iri1];
        -: 7139:	  
  1963850: 7140:	  sig_corr-=x3[newnr[nbolo]+htmp[l1].gi+htmp[l1].ib*GAINSTEP]*htmp[l1].model;
        -: 7141:	  
  1963850: 7142:	  if (nmatco!=0) {
  1963850: 7143:	    sig_corr -=htmp[l1].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib];
        -: 7144:	  }
  1963850: 7145:	  if (nmatdust!=0) {
  1963850: 7146:	    sig_corr -=htmp[l1].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib];
        -: 7147:	  }
  1963850: 7148:	  if (nfreefree!=0) {
    #####: 7149:	    sig_corr -=htmp[l1].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib];
        -: 7150:	  }
 17674650: 7151:	  for (m=0;m<npixbeam;m++)  {
 15710800: 7152:	    sig_corr -= htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -: 7153:	  }
        -: 7154:	  
  1963850: 7155:	  SI +=htmp[l1].w*sig_corr;
  1963850: 7156:	  SQ +=htmp[l1].w*CO1*sig_corr;
  1963850: 7157:	  SU +=htmp[l1].w*SI1*sig_corr;
        -: 7158:	  
  1963850: 7159:	  SII +=htmp[l1].w;
  1963850: 7160:	  SIQ +=htmp[l1].w*CO1;
  1963850: 7161:	  SIU +=htmp[l1].w*SI1;
  1963850: 7162:	  SQQ +=htmp[l1].w*CO1*CO1;
  1963850: 7163:	  SQU +=htmp[l1].w*CO1*SI1;
  1963850: 7164:	  SUU +=htmp[l1].w*SI1*SI1;
        -: 7165:
        -: 7166:	}
        -: 7167:      }
503316480: 7168:      if (Param->OUT_NOPOL[0]%2==0) {
    #####: 7169:	double cond=cond_3_3_thres(SII,SIQ,SIU,
        -: 7170:				   SIQ,SQQ,SQU,
        -: 7171:				   SIU,SQU,SUU);
        -: 7172:      
    #####: 7173:	if (cond<Param->seuilcond) {
    #####: 7174:	  inmat[0]=SII;inmat[1]=SIQ;inmat[2]=SIU;
    #####: 7175:	  inmat[3]=SIQ;inmat[4]=SQQ;inmat[5]=SQU;
    #####: 7176:	  inmat[6]=SIU;inmat[7]=SQU;inmat[8]=SUU;
    #####: 7177:	  invert_3_3(inmat,outmat);
    #####: 7178:	  solvemap(&SI,&SQ,&SU,SII,SIQ,SIU,SQQ,SQU,SUU);
    #####: 7179:	  mapi=SI;
    #####: 7180:	  mapq=SQ;
    #####: 7181:	  mapu=SU;
        -: 7182:	}
        -: 7183:      }
        -: 7184:      else {
503316480: 7185:	if (SII>0) {
   860820: 7186:	  outmat[0]=1.0/SII;outmat[1]=0.0;outmat[2]=0.0;
   860820: 7187:	  outmat[3]=0.0;outmat[4]=0.0;outmat[5]=0.0;
   860820: 7188:	  outmat[6]=0.0;outmat[7]=0.0;outmat[8]=0.0;
   860820: 7189:	  mapi=SI/SII;
   860820: 7190:	  mapq=0.0;
   860820: 7191:	  mapu=0.0;
        -: 7192:	}
        -: 7193:      }
        -: 7194:      //if (mapi>-1E20) {
505280330: 7195:	for (l1=0;l1<ndata;l1++) {
  1963850: 7196:	  long ri1=htmp[l1].rg-globalBeginRing;
  1963850: 7197:	  long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
  1963850: 7198:	  if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 7199:	    
  3927700: 7200:	    double CO1=eta[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
  1963850: 7201:					      -dpsisi[htmp[l1].ib]*htmp[l1].si);
  3927700: 7202:	    double SI1=eta[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
  1963850: 7203:					      +dpsisi[htmp[l1].ib]*htmp[l1].co);
        -: 7204:	    
  1963850: 7205:	    double gg2=gain[htmp[l1].gi+htmp[l1].ib*GAINSTEP];
        -: 7206:	    
  1963850: 7207:	    double sig_corr = htmp[l1].sig*gg2-htmp[l1].fsl;;
        -: 7208:	    
  1963850: 7209:	    sig_corr-=x3[iri1];
        -: 7210:	    
  1963850: 7211:	    double temp=0;
  1963850: 7212:	    if (REMHDIP==0) sig_corr-=htmp[l1].dip;
  1963850: 7213:	    else sig_corr-=htmp[l1].freefree;
        -: 7214:	    
  1963850: 7215:	    sig_corr-=htmp[l1].corr_nl; // NO CORR_CNN TO BE FITTED
        -: 7216:	    
  1963850: 7217:	    sig_corr-=x3[newnr[nbolo]+htmp[l1].gi+htmp[l1].ib*GAINSTEP]*htmp[l1].model;
        -: 7218:	    
  1963850: 7219:	    if (nmatco!=0) {
  1963850: 7220:	      sig_corr -=htmp[l1].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib];
        -: 7221:	    }
  1963850: 7222:	    if (nmatdust!=0) {
  1963850: 7223:	      sig_corr -=htmp[l1].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib];
        -: 7224:	    }
  1963850: 7225:	    if (nfreefree!=0) {
    #####: 7226:	      sig_corr -=htmp[l1].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib];
        -: 7227:	    }
  1963850: 7228:	    temp=0;
 17674650: 7229:	    for (m=0;m<npixbeam;m++)  {
 15710800: 7230:	      if (DOCNN[m]==0) { //||(DOCNN[m]!=1&&NORMFITPOL==0)) {
  9819250: 7231:		sig_corr -= htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -: 7232:	      }
        -: 7233:	      else {
  5891550: 7234:		if (DOCNN[m]!=2) {
  5891550: 7235:		  temp+=htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -: 7236:		}
        -: 7237:	      }
        -: 7238:	    }
        -: 7239:	    
  1963850: 7240:	    int iring=rgcnn[htmp[l1].ib][htmp[l1].rg];
  1963850: 7241:	    int ipha=(int)(CNN_XSIZE*(htmp[l1].phase)/(2*M_PI));
  1963850: 7242:	    if (ipha==CNN_XSIZE) ipha=CNN_XSIZE-1;
  1963850: 7243:	    if (ipha<0||ipha>CNN_XSIZE-1) {
    #####: 7244:	      fprintf(stderr,"CNN_XSIZE PBS %d\n",ipha);
    #####: 7245:	      exit(0);
        -: 7246:	    }
        -: 7247:	    
        -: 7248:	    // if nopol mapq and mapu have been set to 0 
  1963850: 7249:	    signal[all_ndata]=sig_corr; //-coefresidu*(mapi+CO1*mapq+SI1*mapu);
        -: 7250:
  1963850: 7251:            if (mapi>-1E20&&flgpix[k]) {
   697940: 7252:	      sig2[0]+=htmp[l1].w*(sig_corr-mapi-CO1*mapq-SI1*mapu)*(sig_corr-mapi-CO1*mapq-SI1*mapu);
   697940: 7253:	      sig2[1]+=htmp[l1].w;
   697940: 7254:	      sig2[3]+=htmp[l1].w*(sig_corr-coefresidu*(mapi+CO1*mapq+SI1*mapu));
        -: 7255:	   
   697940: 7256:	      weights[all_ndata]=htmp[l1].w;
        -: 7257:
        -: 7258:	      // compute polarised map for cross-ST input
   697940: 7259:	      double a=sig_corr-temp-htmp[l1].corr_cnn-SI/SII;
   697940: 7260:	      double b=CO1-SIQ/SII;
   697940: 7261:	      double c=SI1-SIU/SII;
        -: 7262:	    
   697940: 7263:	      V00[reduce_realpix[k]] += htmp[l1].w*a*b;
   697940: 7264:	      V10[reduce_realpix[k]] += htmp[l1].w*a*c;
   697940: 7265:	      A0[reduce_realpix[k]]  += htmp[l1].w*b*b;
   697940: 7266:	      B0[reduce_realpix[k]]  += htmp[l1].w*b*c;
   697940: 7267:	      C0[reduce_realpix[k]]  += htmp[l1].w*c*b;
   697940: 7268:	      D0[reduce_realpix[k]]  += htmp[l1].w*c*c;
        -: 7269:
        -: 7270:	      //if (htmp[l1].surv%10==1||htmp[l1].surv%10==3) {
   697940: 7271:	      if (htmp[l1].surv<10) {
    #####: 7272:		V01[reduce_realpix[k]] += htmp[l1].w*a*b;
    #####: 7273:		V11[reduce_realpix[k]] += htmp[l1].w*a*c;
    #####: 7274:		A1[reduce_realpix[k]]  += htmp[l1].w*b*b;
    #####: 7275:		B1[reduce_realpix[k]]  += htmp[l1].w*b*c;
    #####: 7276:		C1[reduce_realpix[k]]  += htmp[l1].w*c*b;
    #####: 7277:		D1[reduce_realpix[k]]  += htmp[l1].w*c*c;
        -: 7278:	      }
        -: 7279:
        -: 7280:	      //if (htmp[l1].surv%10==2||htmp[l1].surv%10==4) {
   697940: 7281:	      if (htmp[l1].surv>=10) {
   697940: 7282:		V02[reduce_realpix[k]] += htmp[l1].w*a*b;
   697940: 7283:		V12[reduce_realpix[k]] += htmp[l1].w*a*c;
   697940: 7284:		A2[reduce_realpix[k]]  += htmp[l1].w*b*b;
   697940: 7285:		B2[reduce_realpix[k]]  += htmp[l1].w*b*c;
   697940: 7286:		C2[reduce_realpix[k]]  += htmp[l1].w*c*b;
   697940: 7287:		D2[reduce_realpix[k]]  += htmp[l1].w*c*c;
        -: 7288:	      }
        -: 7289:	      
        -: 7290:	      
        -: 7291:	    }
        -: 7292:	    
  1963850: 7293:	    TCO1[all_ndata]=CO1;
  1963850: 7294:	    TSI1[all_ndata]=SI1;
  1963850: 7295:	    hidx[all_ndata]=k+offpix;
  1963850: 7296:	    int l_idx=htmp[l1].ib*CNN_YSIZE*CNN_XSIZE+iring*CNN_XSIZE+ipha;
        -: 7297:
        -: 7298:      //fprintf(stderr,"l_idx %d nbolo %d CNN_YSIZE %d CNN_XSIZE %d \n",(int) l_idx,(int)nbolo,(int) CNN_YSIZE,(int) CNN_XSIZE);
        -: 7299:
  1963850: 7300:	    if (l_idx<0||l_idx>=nbolo*CNN_YSIZE*CNN_XSIZE) {      
    #####: 7301:	      fprintf(stderr,"IDX ERROR %d %d %d\n",(int) htmp[l1].ib,(int) iring,(int) ipha);
    #####: 7302:	      exit(0);
        -: 7303:	    }
  1963850: 7304:	    idx[all_ndata]=l_idx;
  1963850: 7305:	    incorr[l_idx]+=htmp[l1].w*(sig_corr-(mapi+CO1*mapq+SI1*mapu));
  1963850: 7306:	    wincorr[l_idx]+=htmp[l1].w;
  1963850: 7307:	    all_ndata=all_ndata+1;
        -: 7308:	 // }
        -: 7309:	}
        -: 7310:      }
        -: 7311:   // }
        -: 7312:  }
        -: 7313:
       40: 7314:  double *ltmp=(double *) malloc(sizeof(double)*12*CNN_NSIDE*CNN_NSIDE);
       40: 7315:  localreduce(A0,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7316:  localreduce(A1,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7317:  localreduce(A2,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7318:  localreduce(B0,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7319:  localreduce(B1,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7320:  localreduce(B2,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7321:  localreduce(C0,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7322:  localreduce(C1,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7323:  localreduce(C2,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7324:  localreduce(D0,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7325:  localreduce(D1,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7326:  localreduce(D2,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7327:  localreduce(V00,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7328:  localreduce(V01,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7329:  localreduce(V02,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7330:  localreduce(V10,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7331:  localreduce(V11,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7332:  localreduce(V12,ltmp,12*CNN_NSIDE*CNN_NSIDE);
       40: 7333:  free(ltmp);
        -: 7334:
   491560: 7335:  for (i=0;i<12*CNN_NSIDE*CNN_NSIDE;i++) {
   491520: 7336:    double det0=A0[i]*D0[i]-B0[i]*C0[i];
   491520: 7337:    double det1=A1[i]*D1[i]-B1[i]*C1[i];
   491520: 7338:    double det2=A2[i]*D2[i]-B2[i]*C2[i];
        -: 7339:
   491520: 7340:    if (det0>0) {
    27160: 7341:      double a=( D0[i]*V00[i] - B0[i]*V10[i])/det0;
    27160: 7342:      double b=(-C0[i]*V00[i] + A0[i]*V10[i])/det0;
    27160: 7343:      V00[i]=a;
    27160: 7344:      V10[i]=b;
        -: 7345:    }
        -: 7346:    else {
   464360: 7347:      V00[i]=UNSEENPIX;
   464360: 7348:      V10[i]=UNSEENPIX;
        -: 7349:    }
        -: 7350:    
   491520: 7351:    if (det1>0) {
    #####: 7352:      double a=( D1[i]*V01[i] - B1[i]*V11[i])/det1;
    #####: 7353:      double b=(-C1[i]*V01[i] + A1[i]*V11[i])/det1;
    #####: 7354:      V01[i]=a;
    #####: 7355:      V11[i]=b;
        -: 7356:    }
        -: 7357:    else {
   491520: 7358:      V01[i]=UNSEENPIX;
   491520: 7359:      V11[i]=UNSEENPIX;
        -: 7360:    }
        -: 7361:
   491520: 7362:    if (det2>0) {
    27160: 7363:      double a=( D2[i]*V02[i] - B2[i]*V12[i])/det2;
    27160: 7364:      double b=(-C2[i]*V02[i] + A2[i]*V12[i])/det2;
    27160: 7365:      V02[i]=a;
    27160: 7366:      V12[i]=b;
        -: 7367:    }
        -: 7368:    else {
   464360: 7369:      V02[i]=UNSEENPIX;
   464360: 7370:      V12[i]=UNSEENPIX;
        -: 7371:    }
        -: 7372:  }
        -: 7373:#if 1
       40: 7374:  if (python_rank==0) {
       40: 7375:      float *tp_val = PyArray_DATA((PyArrayObject *) py_smap);
        -: 7376:      
       40: 7377:      for (i=0;i<12*32*32;i++) tp_val[i*2]              = V01[i];
       40: 7378:      for (i=0;i<12*32*32;i++) tp_val[i*2+1]            = V11[i];
       40: 7379:      for (i=0;i<12*32*32;i++) tp_val[i*2+12*32*32*2]   = V02[i];
       40: 7380:      for (i=0;i<12*32*32;i++) tp_val[i*2+1+12*32*32*2] = V12[i];
       40: 7381:      if (rank==0) {
        -: 7382:	char l_path[1024];
       10: 7383:	sprintf(l_path,"MAPSDUST2_%d.dat",out_itt);
       10: 7384:	FILE *fp=fopen(l_path,"w");
       10: 7385:	fwrite(tp_val,sizeof(float)*4*12*CNN_NSIDE*CNN_NSIDE,1,fp);
       10: 7386:	fclose(fp);
        -: 7387:      }
        -: 7388:  }
        -: 7389:  
        -: 7390:#else
        -: 7391:  if (rank==0) {
        -: 7392:    FILE*fp;
        -: 7393:
        -: 7394:    fp=fopen("MAPQ0.dat","w");
        -: 7395:    fwrite(V00,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE,1,fp);
        -: 7396:    fclose(fp);
        -: 7397:    fp=fopen("MAPU0.dat","w");
        -: 7398:    fwrite(V10,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE,1,fp);
        -: 7399:    fclose(fp);
        -: 7400:    fp=fopen("MAPQ1.dat","w");
        -: 7401:    fwrite(V01,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE,1,fp);
        -: 7402:    fclose(fp);
        -: 7403:    fp=fopen("MAPU1.dat","w");
        -: 7404:    fwrite(V11,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE,1,fp);
        -: 7405:    fclose(fp);
        -: 7406:    fp=fopen("MAPQ2.dat","w");
        -: 7407:    fwrite(V02,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE,1,fp);
        -: 7408:    fclose(fp);
        -: 7409:    fp=fopen("MAPU2.dat","w");
        -: 7410:    fwrite(V12,sizeof(double)*12*CNN_NSIDE*CNN_NSIDE,1,fp);
        -: 7411:    fclose(fp);
        -: 7412:    exit(0);
        -: 7413:  }
        -: 7414:#endif
        -: 7415:
        -: 7416:  
        -: 7417:  //Keep for debug
       40: 7418:  float *l_incorr = (float *) malloc(sizeof(float)*nbolo*CNN_XSIZE*CNN_YSIZE);
       40: 7419:  float *l_wincorr = (float *) malloc(sizeof(float)*nbolo*CNN_XSIZE*CNN_YSIZE);
        -: 7420:
       40: 7421:  memset(l_incorr ,0, sizeof(float)*nbolo*CNN_XSIZE*CNN_YSIZE);
       40: 7422:  memset(l_wincorr ,0, sizeof(float)*nbolo*CNN_XSIZE*CNN_YSIZE);
        -: 7423:
       40: 7424:  MPI_Reduce(incorr,l_incorr,nbolo*CNN_XSIZE*CNN_YSIZE,MPI_FLOAT, MPI_SUM,0,MPI_COMM_WORLD);
       40: 7425:  MPI_Reduce(wincorr,l_wincorr,nbolo*CNN_XSIZE*CNN_YSIZE,MPI_FLOAT, MPI_SUM,0,MPI_COMM_WORLD);
        -: 7426:
        -: 7427:  double ssig2[4];
       40: 7428:  sig2[2]=all_ndata;
       40: 7429:  sig2[1]=0.0;
       40: 7430:  sig2[3]=0.0;
 10485800: 7431:  for (i=0;i<nbolo*CNN_XSIZE*CNN_YSIZE;i++) {
 10485760: 7432:    if (l_wincorr[i]>0) {
    20480: 7433:      sig2[1]+=l_wincorr[i];
    20480: 7434:      sig2[3]+=l_incorr[i];
    20480: 7435:      l_incorr[i]/=l_wincorr[i];
        -: 7436:    }
        -: 7437:    else  {
 10465280: 7438:      l_incorr[i]=0.0;
        -: 7439:    }
        -: 7440:  }
        -: 7441:
       40: 7442:  MPI_Bcast(l_incorr,nbolo*CNN_XSIZE*CNN_YSIZE,MPI_FLOAT,0,MPI_COMM_WORLD);
        -: 7443:	    
       40: 7444:  MPI_Allreduce(sig2,ssig2,4,MPI_DOUBLE, MPI_SUM,MPI_COMM_WORLD);
        -: 7445:
       40: 7446:  double offregul=ssig2[3]/ssig2[1];
        -: 7447:
        -: 7448:#if 0
        -: 7449:  if (rank==0) {
        -: 7450:    fprintf(stderr,"SAVE CNN CORRECTION in %s_CNN_IN_CORR\n",Param->Out_Offset[0]);
        -: 7451:  
        -: 7452:    PIOSTRING saveval;
        -: 7453:    sprintf(saveval,"%s_CNN_IN_CORR",Param->Out_Offset[0]);
        -: 7454:    FILE *fp=fopen(saveval,"w");
        -: 7455:    if(fp != NULL){
        -: 7456:      fwrite(l_incorr,1,sizeof(float)*nbolo*CNN_XSIZE*CNN_YSIZE,fp);
        -: 7457:    }else{
        -: 7458:      fprintf(stderr,"ERROR NULL file => %s \n",Param->Out_Offset[0]);
        -: 7459:    }
        -: 7460:    fclose(fp);
        -: 7461:    sprintf(saveval,"%s_CNN_IN_NCORR",Param->Out_Offset[0]);
        -: 7462:    fp=fopen(saveval,"w");
        -: 7463:    fwrite(l_wincorr,1,sizeof(float)*nbolo*CNN_XSIZE*CNN_YSIZE,fp);
        -: 7464:    fclose(fp);
        -: 7465:  }
        -: 7466:#endif
        -: 7467:#if 0
        -: 7468:  if (rank==0) {
        -: 7469:    fprintf(stderr,"SAVE FOR CNN %ld DATA INSIDE %s_CNNINFO_*\n",(long) all_ndata,Param->Out_Offset[0]);
        -: 7470:  }
        -: 7471:
        -: 7472:  PIOSTRING saveval;
        -: 7473:  sprintf(saveval,"%s_CNNINFO_RPIX_%d",Param->Out_Offset[0],rank);
        -: 7474:  FILE *fp=fopen(saveval,"w");
        -: 7475:  fwrite(realpix,1,sizeof(int)*nnbpix,fp);
        -: 7476:  fclose(fp);
        -: 7477:
        -: 7478:  sprintf(saveval,"%s_CNNINFO_SIG_%d",Param->Out_Offset[0],rank);
        -: 7479:  fp=fopen(saveval,"w");
        -: 7480:  fwrite(signal,1,sizeof(float)*all_ndata,fp);
        -: 7481:  fclose(fp);
        -: 7482:
        -: 7483:  sprintf(saveval,"%s_CNNINFO_W_%d",Param->Out_Offset[0],rank);
        -: 7484:  fp=fopen(saveval,"w");
        -: 7485:  fwrite(weights,1,sizeof(float)*all_ndata,fp);
        -: 7486:  fclose(fp);
        -: 7487:  
        -: 7488:  sprintf(saveval,"%s_CNNINFO_CO_%d",Param->Out_Offset[0],rank);
        -: 7489:  fp=fopen(saveval,"w");
        -: 7490:  fwrite(TCO1,1,sizeof(float)*all_ndata,fp);
        -: 7491:  fclose(fp);
        -: 7492:  
        -: 7493:  sprintf(saveval,"%s_CNNINFO_SI_%d",Param->Out_Offset[0],rank);
        -: 7494:  fp=fopen(saveval,"w");
        -: 7495:  fwrite(TSI1,1,sizeof(float)*all_ndata,fp);
        -: 7496:  fclose(fp);
        -: 7497:  
        -: 7498:  sprintf(saveval,"%s_CNNINFO_HIDX_%d",Param->Out_Offset[0],rank);
        -: 7499:  fp=fopen(saveval,"w");
        -: 7500:  fwrite(hidx,1,sizeof(int)*all_ndata,fp);
        -: 7501:  fclose(fp);
        -: 7502:  
        -: 7503:  sprintf(saveval,"%s_CNNINFO_IDX_%d",Param->Out_Offset[0],rank);
        -: 7504:  fp=fopen(saveval,"w");
        -: 7505:  fwrite(idx,1,sizeof(int)*all_ndata,fp);
        -: 7506:  fclose(fp);
        -: 7507:
        -: 7508:  MPI_Barrier(MPI_COMM_WORLD);
        -: 7509:  exit(0);
        -: 7510:#endif
        -: 7511:  
  1963890: 7512:  for (k=0;k<all_ndata;k++) {
  1963850: 7513:    if (weights[k]!=0) {
   697940: 7514:      signal[k]-=offregul;
        -: 7515:    }
  1265910: 7516:    else signal[k]=0.0;
        -: 7517:  }
        -: 7518:  
       40: 7519:  free(incorr);
       40: 7520:  free(l_wincorr);
       40: 7521:  free(wincorr);
        -: 7522:
       40: 7523:  double rap=sqrt(ssig2[0]/ssig2[1])*sqrt((nbolo*CNN_YSIZE*CNN_XSIZE)/ssig2[2]);
        -: 7524:
       40: 7525:  if (rank==0) {
       10: 7526:    fprintf(stderr,"SIGMA : %lf %lf\n",(double) rap,(double) sqrt((nbolo*CNN_YSIZE*CNN_XSIZE)/ssig2[2]));
        -: 7527:  }
        -: 7528:
       40: 7529:  rap=1.0;
        -: 7530:  
       40: 7531:  int ncorr=0,testcorr=0;
       40: 7532:  if (avv_poleff==-1) {
        4: 7533:    testcorr=-1;
        4: 7534:    avv_poleff=0;
        -: 7535:  }
      360: 7536:  for (m=0;m<npixbeam;m++)  {
      320: 7537:    if (DOCNN[m]!=0) ncorr++;
        -: 7538:  }
        -: 7539:
       40: 7540:  if (out_itt==0) {
        4: 7541:    if (python_rank==0) {
        4: 7542:      arglist = Py_BuildValue("(l)", (long) (ncorr*nbolo));
        4: 7543:      if (NOMOREFITTED==0) {
        4: 7544:	cnn_coef  = EXECPYTHON(PyObject_CallObject(MyPythonBackend.allocf32, arglist));
        4: 7545:	float *l_coef=PyArray_DATA((PyArrayObject *) cnn_coef);
       36: 7546:	for (m=0;m<npixbeam;m++)  {
       32: 7547:	  if (DOCNN[m]!=0) {
       60: 7548:	    for (j=0;j<nbolo;j++) {
       48: 7549:	      l_coef[j+(DOCNN[m]-1)*nbolo]=x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+j];
        -: 7550:	    }
        -: 7551:	  }
        -: 7552:	}
        -: 7553:      }
        -: 7554:      
        4: 7555:      py_coef = cnn_coef;
        4: 7556:      float *tp_coef = PyArray_DATA((PyArrayObject *) py_coef);
        -: 7557:
       36: 7558:      for (m=0;m<npixbeam;m++)  {
       32: 7559:	if (DOCNN[m]!=0) {
       12: 7560:	  if (rank==0) {
        3: 7561:	    fprintf(stderr,"iPOLEFF %3d ",DOCNN[m]);
        -: 7562:	  }
       60: 7563:	  for (j=0;j<nbolo;j++) {
       48: 7564:	    if (rank==0) {
       12: 7565:	      fprintf(stderr,"%.3f ",tp_coef[j+(DOCNN[m]-1)*nbolo]);
        -: 7566:	    }
        -: 7567:	  }
       12: 7568:	  if (rank==0) {
        3: 7569:	    fprintf(stderr,"\n");
        -: 7570:	  }
        -: 7571:	}
        -: 7572:      }
        -: 7573:    }
        -: 7574:    
        4: 7575:    float *ires=NULL;
        -: 7576:
        4: 7577:    if (python_rank==0) ires=PyArray_DATA((PyArrayObject *) py_signal);
        4: 7578:    MPI_Gatherv(signal,all_ndata,MPI_FLOAT,ires,
        -: 7579:    		recvcount,recvcounts,MPI_FLOAT,0,python_comm);
        4: 7580:    if (python_rank==0)  ires=PyArray_DATA((PyArrayObject *) py_weights);
        4: 7581:    MPI_Gatherv(weights,all_ndata,MPI_FLOAT,ires,
        -: 7582:    		recvcount,recvcounts,MPI_FLOAT,0,python_comm);
        4: 7583:    if (python_rank==0)  ires=PyArray_DATA((PyArrayObject *) py_TCO1);
        4: 7584:    MPI_Gatherv(TCO1,all_ndata,MPI_FLOAT,ires,
        -: 7585:    		recvcount,recvcounts,MPI_FLOAT,0,python_comm);
        4: 7586:    if (python_rank==0)  ires=PyArray_DATA((PyArrayObject *) py_TSI1);
        4: 7587:    MPI_Gatherv(TSI1,all_ndata,MPI_FLOAT,ires,
        -: 7588:    		recvcount,recvcounts,MPI_FLOAT,0,python_comm);
        4: 7589:    if (python_rank==0)  ires=PyArray_DATA((PyArrayObject *) py_hidx);
        4: 7590:    MPI_Gatherv(hidx,all_ndata,MPI_INT,ires,
        -: 7591:    		recvcount,recvcounts,MPI_INT,0,python_comm);
        4: 7592:    if (python_rank==0)  ires=PyArray_DATA((PyArrayObject *) py_idx);
        4: 7593:    MPI_Gatherv(idx,all_ndata,MPI_INT,ires,
        -: 7594:    		recvcount,recvcounts,MPI_INT,0,python_comm);
        -: 7595:
        4: 7596:    if (python_rank==0) { 
        4: 7597:      arglist = PyTuple_New(10);
        4: 7598:      PyTuple_SetItem(arglist,0,mynetwork);
        4: 7599:      PyTuple_SetItem(arglist,1,py_signal);
        4: 7600:      PyTuple_SetItem(arglist,2,py_weights);
        4: 7601:      PyTuple_SetItem(arglist,3,py_TCO1);
        4: 7602:      PyTuple_SetItem(arglist,4,py_TSI1);
        4: 7603:      PyTuple_SetItem(arglist,5,py_hidx);
        4: 7604:      PyTuple_SetItem(arglist,6,py_idx);
        4: 7605:      PyTuple_SetItem(arglist,7,py_realpix);
        4: 7606:      PyTuple_SetItem(arglist,8,py_coef);
        4: 7607:      PyTuple_SetItem(arglist,9,py_smap);
        4: 7608:      myrun = EXECPYTHON(PyObject_CallObject(MyPythonBackend.init_net, arglist));
        -: 7609:    }
        -: 7610:  }
        -: 7611:  else {
       36: 7612:    float *ires=NULL;
       36: 7613:    if (python_rank==0) ires=PyArray_DATA((PyArrayObject *) py_signal);
       36: 7614:    MPI_Gatherv(signal,all_ndata,MPI_FLOAT,ires,
        -: 7615:    		recvcount,recvcounts,MPI_FLOAT,0,python_comm);
       36: 7616:    if (python_rank==0) {
       36: 7617:      arglist = PyTuple_New(6);
       36: 7618:      PyTuple_SetItem(arglist,0,myrun);
       36: 7619:      PyTuple_SetItem(arglist,1,py_signal);
       36: 7620:      PyTuple_SetItem(arglist,2,py_weights);
       36: 7621:      PyTuple_SetItem(arglist,3,py_hidx);
       36: 7622:      PyTuple_SetItem(arglist,4,py_realpix);
       36: 7623:      PyTuple_SetItem(arglist,5,py_smap);
       36: 7624:      myrun = EXECPYTHON(PyObject_CallObject(MyPythonBackend.init_net_data, arglist));
        -: 7625:    }
        -: 7626:  }
        -: 7627:
       40: 7628:  free(signal  );
       40: 7629:  free(weights );
       40: 7630:  free(TCO1    );
       40: 7631:  free(TSI1    );
       40: 7632:  free(hidx    );
       40: 7633:  free(idx     );
        -: 7634:
       40: 7635:  if (python_rank==0) {
        -: 7636:    struct timeval tp1,tp2;
       40: 7637:    gettimeofday(&tp1,NULL);
       40: 7638:    double deltaloss=1.0;
       40: 7639:    itt=0;
       80: 7640:    while (itt<Param->CNN_ITT) {
        -: 7641:      int k;
        -: 7642:      Py_ssize_t nval;
        -: 7643:      PyArrayObject *value;
        -: 7644:      
    #####: 7645:      arglist = PyTuple_New(1);
    #####: 7646:      PyTuple_SetItem(arglist,0,myrun);
    #####: 7647:      PyObject *mygradient = EXECPYTHON(PyObject_CallObject(MyPythonBackend.grad, arglist));
    #####: 7648:      PyTypeObject *keys = (PyTypeObject *) PyDict_Keys(mygradient);
    #####: 7649:      nval = PyList_GET_SIZE(keys);
    #####: 7650:      for (k=0;k<nval;k++) {
        -: 7651:	char keystr[128];
    #####: 7652:	sprintf(keystr,"%03d",k);
    #####: 7653:	value = (PyArrayObject *)EXECPYTHON(PyDict_GetItemString(mygradient,keystr));
    #####: 7654:	long nnn=1;
        -: 7655:	int l;
    #####: 7656:	for (l=0;l<PyArray_NDIM(value);l++) nnn*=PyArray_DIM(value,l);
    #####: 7657:	float *res = (float *) malloc(sizeof(float)*nnn);
    #####: 7658:	MPI_Allreduce(PyArray_DATA(value),res,nnn,MPI_FLOAT,MPI_SUM,tensorflow_comm);
    #####: 7659:	memcpy(PyArray_DATA(value),res,sizeof(float)*nnn);
        -: 7660:      }
        -: 7661:      
    #####: 7662:      PyObject *l_arglist = PyTuple_New(2);
    #####: 7663:      PyTuple_SetItem(l_arglist,0,myrun);
    #####: 7664:      PyTuple_SetItem(l_arglist,1,mygradient);
    #####: 7665:      EXECPYTHON(PyObject_CallObject(MyPythonBackend.agrad, l_arglist));
        -: 7666:      
    #####: 7667:      if (itt%10==0) {
    #####: 7668:	PyObject *res=EXECPYTHON(PyObject_CallObject(MyPythonBackend.gloss, arglist)); 
    #####: 7669:	if (res==NULL) {
    #####: 7670:	  PyErr_Print();
        -: 7671:	}
    #####: 7672:	float *loss=PyArray_DATA((PyArrayObject *)res);
        -: 7673:	float l_loss[2];
        -: 7674:	
    #####: 7675:	MPI_Allreduce(loss,l_loss,2,MPI_FLOAT,MPI_SUM,tensorflow_comm);
    #####: 7676:	gettimeofday(&tp2,NULL);
    #####: 7677:	double dt=(double)(tp2.tv_sec-tp1.tv_sec)+(1E-6)*(tp2.tv_usec-tp1.tv_usec);
    #####: 7678:	if (itt==0) deltaloss=sqrt(l_loss[0]/l_loss[1]);
    #####: 7679:	else deltaloss=fabs(deltaloss-sqrt(l_loss[0]/l_loss[1]));
    #####: 7680:	if (rank==0) {
    #####: 7681:	  fprintf(stderr,"Itt %d loss=%10.4g Dloss=%10.4g Lr=%.4f Lpwst=%.4g Dt=%.4f\n",(int) itt,sqrt(l_loss[0]/l_loss[1]),deltaloss,loss[2],loss[3],dt);
        -: 7682:	}
    #####: 7683:	deltaloss=sqrt(l_loss[0]/l_loss[1]);
    #####: 7684:	gettimeofday(&tp1,NULL);
        -: 7685:	//Py_DECREF(res);
        -: 7686:      }
    #####: 7687:      itt++;
        -: 7688:    }
        -: 7689:  }
        -: 7690:  // la prediction doit avoir la taille de l'echantillon : all_ndata - change value -- have to be the size of timeline
        -: 7691:  // tous les processeurs applique prdiction
        -: 7692:  //nbolo*CNN_SIZE*CNN_YSIZE
        -: 7693:
        -: 7694:  //Py_DECREF(arglist);
        -: 7695:  PyObject *py_num;
       40: 7696:  if (python_rank==0) {
       40: 7697:    arglist = Py_BuildValue("(l)", (long) 2);
       40: 7698:    py_num  = EXECPYTHON(PyObject_CallObject(MyPythonBackend.alloci32, arglist));
        -: 7699:    //Py_DECREF(arglist);
        -: 7700:  }
       40: 7701:  float *icorrection=NULL;
       40: 7702:  float *correction=NULL;
        -: 7703:  float *iprediction[2];
        -: 7704:  float *prediction[2];
        -: 7705:  
       40: 7706:  if (python_rank==0) {
       40: 7707:    int *iter_docnn = (int *) (PyArray_DATA((PyArrayObject *)py_num));
       40: 7708:    *iter_docnn = 0;
        -: 7709:      
       40: 7710:    arglist = PyTuple_New(2);
       40: 7711:    PyTuple_SetItem(arglist,0,myrun);
       40: 7712:    PyTuple_SetItem(arglist,1,py_num);
        -: 7713:    
       40: 7714:    PyObject *thepred=EXECPYTHON(PyObject_CallObject(MyPythonBackend.corr, arglist));
       40: 7715:    icorrection = (float *) malloc(sizeof(float)*all_ndatamax);
       40: 7716:    memcpy(icorrection,PyArray_DATA((PyArrayObject *)thepred),sizeof(float)*all_ndatamax);
       40: 7717:    arglist = PyTuple_New(1);
       40: 7718:    PyTuple_SetItem(arglist,0,thepred);
       40: 7719:    PyObject *nulpred=EXECPYTHON(PyObject_CallObject(MyPythonBackend.Clean, arglist));
        -: 7720:    
       40: 7721:    *iter_docnn = 1;
       40: 7722:    arglist = PyTuple_New(2);
       40: 7723:    PyTuple_SetItem(arglist,0,myrun);
       40: 7724:    PyTuple_SetItem(arglist,1,py_num);
       40: 7725:    thepred=EXECPYTHON(PyObject_CallObject(MyPythonBackend.corr, arglist));
       40: 7726:    iprediction[0] = (float *) malloc(sizeof(float)*all_ndatamax);
       40: 7727:    memcpy(iprediction[0],PyArray_DATA((PyArrayObject *)thepred),sizeof(float)*all_ndatamax);
       40: 7728:    arglist = PyTuple_New(1);
       40: 7729:    PyTuple_SetItem(arglist,0,thepred);
       40: 7730:    nulpred=EXECPYTHON(PyObject_CallObject(MyPythonBackend.Clean, arglist));
        -: 7731:    
       40: 7732:    *iter_docnn = 2;
       40: 7733:    arglist = PyTuple_New(2);
       40: 7734:    PyTuple_SetItem(arglist,0,myrun);
       40: 7735:    PyTuple_SetItem(arglist,1,py_num);
       40: 7736:    thepred=EXECPYTHON(PyObject_CallObject(MyPythonBackend.corr, arglist));
       40: 7737:    iprediction[1] = (float *) malloc(sizeof(float)*all_ndatamax);
       40: 7738:    memcpy(iprediction[1],PyArray_DATA((PyArrayObject *)thepred),sizeof(float)*all_ndatamax);
       40: 7739:    arglist = PyTuple_New(1);
       40: 7740:    PyTuple_SetItem(arglist,0,thepred);
       40: 7741:    nulpred=EXECPYTHON(PyObject_CallObject(MyPythonBackend.Clean, arglist));
        -: 7742:  }
        -: 7743:  
       40: 7744:  correction = (float *) malloc(sizeof(float)*all_ndata);
        -: 7745:    
        -: 7746:  // and now distribute data
       40: 7747:  MPI_Scatterv(icorrection, recvcount,recvcounts,MPI_FLOAT,
        -: 7748:	       correction, all_ndata,MPI_FLOAT,0,python_comm);
        -: 7749:
       40: 7750:  if (python_rank==0) {
       40: 7751:    free(icorrection);
        -: 7752:  }
        -: 7753:
      120: 7754:  for (i=0;i<2;i++) {
       80: 7755:    prediction[i] = (float *) malloc(sizeof(float)*all_ndata);
        -: 7756:    
        -: 7757:    // and now distribute data
      160: 7758:    MPI_Scatterv(iprediction[i], recvcount,recvcounts,MPI_FLOAT,
       80: 7759:		 prediction[i], all_ndata,MPI_FLOAT,0,python_comm);
        -: 7760:
       80: 7761:    if (python_rank==0) {
       80: 7762:      free(iprediction[i]);
        -: 7763:    }
        -: 7764:  }
        -: 7765:  //Py_DECREF(py_num);
        -: 7766:
        -: 7767:  
        -: 7768:  // and now replace the template by the CNN version
        -: 7769:
       40: 7770:  long iii=0;
503316520: 7771:  for (k=0;k<nnbpix;k++) {
503316480: 7772:    long ndata = loc_nhpix[k];
503316480: 7773:    hpix *htmp = loc_hpix[k];
505280330: 7774:    for (l1=0;l1<ndata;l1++) {
        -: 7775:      
  1963850: 7776:      long ri1=htmp[l1].rg-globalBeginRing;
        -: 7777:      
  1963850: 7778:      if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -: 7779:	
  1963850: 7780:	int iring = rgcnn[htmp[l1].ib][htmp[l1].rg];
        -: 7781:	
  1963850: 7782:	int ipha=(int)(CNN_XSIZE*(htmp[l1].phase)/(2*M_PI));
        -: 7783:	
  1963850: 7784:	if (ipha==CNN_XSIZE) ipha=CNN_XSIZE-1;
        -: 7785:
        -: 7786:	//for (m=0;m<npixbeam;m++)  {
        -: 7787:	//   if (DOCNN[m]!=0) {
        -: 7788:	//     htmp[l1].listofpix[m]=correction[DOCNN[m]-1][iii]; //sqrt(-2*log( drand48()))*cos(2*M_PI*drand48());
        -: 7789:	//   }
 17674650: 7790:	for (m=0;m<npixbeam;m++)  {
 15710800: 7791:	    if (DOCNN[m]==1) {
  5891550: 7792:	      htmp[l1].listofpix[m]=sqrt(-2*log( drand48()))*cos(2*M_PI*drand48()); // should be set to something otherwise it generates Nan during the minimization
        -: 7793:	    }
 15710800: 7794:	    if (DOCNN[m]==2) {
    #####: 7795:	      htmp[l1].listofpix[m]=prediction[0][iii]; // should be set to something otherwise it generates Nan during the minimization
        -: 7796:	    }
 15710800: 7797:	    if (DOCNN[m]==3) {
    #####: 7798:	      htmp[l1].listofpix[m]=prediction[1][iii]; // should be set to something otherwise it generates Nan during the minimization
        -: 7799:	    }
        -: 7800:	}
        -: 7801:	//	htmp[l1].corr_cnn=l_incorr[htmp[l1].ib*CNN_YSIZE*CNN_XSIZE+iring*CNN_XSIZE+ipha];
        -: 7802:	  //htmp[l1].corr_cnn=l_incorr[htmp[l1].ib*CNN_YSIZE*CNN_XSIZE+iring*CNN_XSIZE+ipha];
        -: 7803:	//}
  1963850: 7804:	htmp[l1].corr_cnn=correction[iii]; //htmp[l1].ib*CNN_YSIZE*CNN_XSIZE+iring*CNN_XSIZE+ipha];
  1963850: 7805:	iii++;
        -: 7806:      }
        -: 7807:    }
        -: 7808:  }
        -: 7809:#if 1
        -: 7810:  
       40: 7811:  free(correction);
      120: 7812:  for (i=0;i<2;i++) {
       80: 7813:    free(prediction[i]);
        -: 7814:  }
        -: 7815:  
        -: 7816:#endif
      200: 7817:  for (i=0;i<nbolo;i++) {
      160: 7818:    free(rgcnn[i]);
        -: 7819:  }
       40: 7820:  free(rgcnn);
        -: 7821:  
       40: 7822:  free(l_incorr);
        -: 7823:
       40: 7824:  if (NOMOREFITTED==0) {
        -: 7825:    int mm;
        4: 7826:    NOMOREFITTED=1;
       36: 7827:    for (mm=0;mm<npixbeam;mm++)  {
       32: 7828:      if (DOCNN[mm]==1) { //NOMOREFITTED) {
       60: 7829:	for (i=0;i<nbolo;i++) {
       48: 7830:	  x3[newnr[nbolo]+nbolo*(GAINSTEP)+mm*nbolo+i]=0;
        -: 7831:	}
        -: 7832:      }
        -: 7833:    }
        -: 7834:  }
        -: 7835: 
        -: 7836:  
       40: 7837:  free(A0);
       40: 7838:  free(A1);
       40: 7839:  free(A2);
       40: 7840:  free(B0);
       40: 7841:  free(B1);
       40: 7842:  free(B2);
       40: 7843:  free(C0);
       40: 7844:  free(C1);
       40: 7845:  free(C2);
       40: 7846:  free(D0);
       40: 7847:  free(D1);
       40: 7848:  free(D2);
       40: 7849:  free(V00);
       40: 7850:  free(V01);
       40: 7851:  free(V02);
       40: 7852:  free(V10);
       40: 7853:  free(V11);
       40: 7854:  free(V12);
        -: 7855:
        -: 7856:
       40: 7857:}
        -: 7858:
    #####: 7859:int PIOMergeMAP(const char *path)
        -: 7860:{
        -: 7861:  //int rank;
        -: 7862:  int mpi_size;
        -: 7863:
        -: 7864:  int rank_size;
    #####: 7865:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
        -: 7866:  //rank=rank_size;
    #####: 7867:  MPI_Comm_size(MPI_COMM_WORLD,&rank_size);
    #####: 7868:  mpi_size=rank_size;
        -: 7869:
    #####: 7870:  int err=0;
    #####: 7871:  double *map = (double *) malloc(sizeof(double)*12*2048*2048);
        -: 7872:
        -: 7873:  char thepath[1024];
        -: 7874:
    #####: 7875:  fprintf(stderr,"Write %s\n",path);
    #####: 7876:  sprintf(thepath,"%s_dir_%d",path,mpi_size);
        -: 7877:
        -: 7878:
        -: 7879:  int rrk;
    #####: 7880:  long nnn=0;
        -: 7881:
        -: 7882:
    #####: 7883:  for (rrk=0;rrk<mpi_size;rrk++) {
        -: 7884:    struct stat buf;
    #####: 7885:    sprintf(thepath,"%s_dir_%d/proc_%d",path,mpi_size,rrk);
        -: 7886:
    #####: 7887:    stat(thepath,&buf);
    #####: 7888:    long sizefile = buf.st_size;
    #####: 7889:    unsigned char *value = (unsigned char *) malloc(sizefile);
        -: 7890:
    #####: 7891:    int fp=open(thepath,O_WRONLY|O_CREAT,0664);
    #####: 7892:    err=read(fp,value,sizefile);
    #####: 7893:    close(fp);
        -: 7894:
    #####: 7895:    memcpy(map+nnn,value,sizefile);
    #####: 7896:    fprintf(stderr,"nnn %lg\n",map[nnn]);
    #####: 7897:    nnn+=sizefile/sizeof(double);
        -: 7898:  }
        -: 7899:
    #####: 7900:  int fp=open(path,O_WRONLY|O_CREAT,0664);
    #####: 7901:  err=write(fp,map,12*2048*2048*sizeof(double));
    #####: 7902:  close(fp);
    #####: 7903:  free(map);
        -: 7904:
    #####: 7905:  return(err);
        -: 7906:}
        -: 7907:
        -: 7908:int getbeginfo=0;
        -: 7909:int *allbeg;
        -: 7910:int *allend;
        -: 7911:int *all_realpix;
        -: 7912:float *all_map;
        -: 7913:int maxsize=0;
        -: 7914:
       72: 7915:int PIOWriteMAP(const char *path, double *value_in_double,int beg,int end)
        -: 7916:{
        -: 7917:  int rank,mpi_size;
       72: 7918:  int map_size = 12*2048*2048;
        -: 7919:
        -: 7920:  int rank_size;
       72: 7921:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
       72: 7922:  rank=rank_size;
       72: 7923:  MPI_Comm_size(MPI_COMM_WORLD,&rank_size);
       72: 7924:  mpi_size=rank_size;
        -: 7925:  int k;
        -: 7926:
       72: 7927:  ssize_t err=0;
        -: 7928:  // Convert array from double to float for smaller file to be written
       72: 7929:  float *value = (float *)malloc(sizeof(float)*(end-beg+1));
905969736: 7930:  for (int i = 0; i < (end-beg+1); ++i) {
905969664: 7931:    value[i] = (float)value_in_double[i];
        -: 7932:  }
        -: 7933:  float *map;
       72: 7934:  if (rank==0)  {
       18: 7935:    map=(float *)malloc(sizeof(float)*map_size);
        -: 7936:  }
        -: 7937:
        -: 7938:#ifdef OPTIPIX
       72: 7939:  if (getbeginfo==0) {
        4: 7940:    getbeginfo=1;
        -: 7941:    int i,rrk;
        4: 7942:    if (rank==0) {
        1: 7943:      allbeg = (int *) malloc(sizeof(int)*mpi_size);
        1: 7944:      allend = (int *) malloc(sizeof(int)*mpi_size);
        -: 7945:    }
        4: 7946:    MPI_Gather(&beg,sizeof(int),MPI_BYTE,allbeg,sizeof(int),MPI_BYTE,0,MPI_COMM_WORLD);
        4: 7947:    MPI_Gather(&end,sizeof(int),MPI_BYTE,allend,sizeof(int),MPI_BYTE,0,MPI_COMM_WORLD);
        -: 7948:
        4: 7949:    if (rank==0) {
        5: 7950:      for (rrk=0;rrk<mpi_size;rrk++) {
        4: 7951:	if (maxsize<allend[rrk]-allbeg[rrk]+1) maxsize=allend[rrk]-allbeg[rrk]+1;
        -: 7952:      }
        1: 7953:      all_realpix = (int *) malloc(sizeof(int)*mpi_size*maxsize);
        1: 7954:      all_map = (float *) malloc(sizeof(float)*mpi_size*maxsize);
        -: 7955:    }
        -: 7956:
        4: 7957:    MPI_Bcast(&maxsize,sizeof(int), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 7958:
        4: 7959:    int *l_idx =(int *)malloc(sizeof(int)*maxsize);
        4: 7960:    for (i=beg;i<=end;i++) l_idx[i-beg]=realpix[i-beg];
        -: 7961:
        4: 7962:    MPI_Gather(l_idx,sizeof(int)*maxsize,MPI_BYTE,all_realpix,sizeof(int)*maxsize,MPI_BYTE,0,MPI_COMM_WORLD);
        -: 7963:
        4: 7964:    free(l_idx);
        -: 7965:  }
       72: 7966:  float *l_map =(float *)malloc(sizeof(float)*maxsize);
       72: 7967:  for (k=beg;k<=end;k++) l_map[k-beg]=value[k-beg];
       72: 7968:  MPI_Gather(l_map,sizeof(float)*maxsize,MPI_BYTE,all_map,sizeof(float)*maxsize,MPI_BYTE,0,MPI_COMM_WORLD);
       72: 7969:  free(l_map);
        -: 7970:
        -: 7971:
       72: 7972:  if (rank==0) {
        -: 7973:    int i,rrk;
       90: 7974:    for (rrk=0;rrk<mpi_size;rrk++) {
        -: 7975:      int l_beg,l_end;
       72: 7976:      l_beg=allbeg[rrk];
       72: 7977:      l_end=allend[rrk];
       72: 7978:      for (i=l_beg;i<=l_end;i++) map[all_realpix[i-l_beg+rrk*maxsize]]=all_map[i-l_beg+rrk*maxsize];
        -: 7979:    }
        -: 7980:  }
        -: 7981:
        -: 7982:#else
        -: 7983:  if (rank==0) {
        -: 7984:    MPI_Status statu;
        -: 7985:    int i,rrk;
        -: 7986:
        -: 7987:    for (i=beg;i<=end;i++) map[i]=value[i-beg];
        -: 7988:    for (rrk=1;rrk<mpi_size;rrk++) {
        -: 7989:      int l_beg,l_end;
        -: 7990:      MPI_Recv(&l_beg,sizeof(int), MPI_BYTE, rrk,2031, MPI_COMM_WORLD,&statu);
        -: 7991:      MPI_Recv(&l_end,sizeof(int), MPI_BYTE, rrk,2032, MPI_COMM_WORLD,&statu);
        -: 7992:      MPI_Recv(map+l_beg,(l_end-l_beg+1)*sizeof(float), MPI_BYTE, rrk,2033, MPI_COMM_WORLD,&statu);
        -: 7993:    }
        -: 7994:  }
        -: 7995:  else {
        -: 7996:    MPI_Send(&beg, sizeof(int), MPI_BYTE, 0, 2031, MPI_COMM_WORLD);
        -: 7997:    MPI_Send(&end, sizeof(int), MPI_BYTE, 0, 2032, MPI_COMM_WORLD);
        -: 7998:    MPI_Send(value, (end-beg+1)*sizeof(float), MPI_BYTE, 0, 2033, MPI_COMM_WORLD);
        -: 7999:  }
        -: 8000:#endif
       72: 8001:  if (rank==0) {
        -: 8002:    PIOSTRING fitspath;
       18: 8003:    sprintf( fitspath, "%s.fits", path);
       18: 8004:    if (remove( fitspath) == 0) {
       18: 8005:      fprintf( stderr, "removed existing MAP: %s\n", fitspath);
        -: 8006:    }
       18: 8007:    fprintf( stderr, "WRITE MAP: %s\n", fitspath);
       18: 8008:    write_healpix_map( map, 2048, fitspath, 0, "G");
       18: 8009:    free(map);
        -: 8010:  }
        -: 8011:
       72: 8012:  free(value);
       72: 8013:  return(err);
        -: 8014:}
        -: 8015:
       59: 8016:int PIOWriteVECT(const char *path,void *value,int off,int size)
        -: 8017:{
       59: 8018:  int fp=open(path,O_WRONLY|O_CREAT,0664);
       59: 8019:  int err=pwrite(fp,value,size,off);
       59: 8020:  close(fp);
       59: 8021:  return(err);
        -: 8022:}
        -: 8023:
        -: 8024:
        -: 8025:
        4: 8026:int main(int argc,char *argv[])  {
        -: 8027:
        -: 8028:  PIOSTRING Command;
        -: 8029:  PIOSTRING hostname;
        -: 8030:  int rank,size,mpi_size;
        -: 8031:  long i,j;
        -: 8032:  PIOLONG rg;
        4: 8033:  int stim_first_seed = 0;
        -: 8034:  time_t now;
        -: 8035:
        -: 8036:  //PIODOUBLE  dip[]={-0.000233797238224 , -0.00222070369388 , 0.00250271842609};
        -: 8037:
        -: 8038:  //TESPT;
        4: 8039:  MPI_Init(&argc, &argv);
        -: 8040:
        -: 8041:  int rank_size;
        4: 8042:  MPI_Comm_rank(MPI_COMM_WORLD,&rank_size);
        4: 8043:  rank=rank_size;
        4: 8044:  MPI_Comm_size(MPI_COMM_WORLD,&size);
        4: 8045:  mpi_size=size;
        -: 8046:  
        4: 8047:  if (rank==0) {
        -: 8048:    char rpath[PATH_MAX];
        1: 8049:    int err=realpath( argv[0], rpath);
        1: 8050:    if (err) 
        1: 8051:      fprintf( stderr, "%s: --------------------------\n", __FILE__ );
        1: 8052:    now = time( NULL);
        1: 8053:    fprintf( stderr, "%s: --------------------------\n", __FILE__ );
        1: 8054:    fprintf( stderr, "%s: Starting %s\n",                __FILE__, rpath);
        1: 8055:    fprintf( stderr, "%s: at %s",                        __FILE__, ctime( &now));
        1: 8056:    fprintf( stderr, "%s: with %d MPI ranks and %d OMP threads\n", __FILE__, mpi_size, omp_get_max_threads());
        1: 8057:    fprintf( stderr, "%s: --------------------------\n", __FILE__ );
        -: 8058:
        -: 8059:    /* Ensure mpi_rank is a power of two (required by some algo...) */
        1: 8060:    if (!isPowerOfTwo(mpi_size)) {
    #####: 8061:      fprintf(stderr,"INVALID mpi_size(%d), shall be a power of two!\n", mpi_size);
    #####: 8062:      return 1;
        -: 8063:    }
        1: 8064:    fprintf( stderr, "\nstarting troll with MAXSIMU=%d, MAXTHEOHPR=%d\n", MAXSIMU, MAXTHEOHPR);
        -: 8065:  }
        -: 8066:
        -: 8067:  /* read params */
        -: 8068:  troll_parContent par;
        4: 8069:  GetHostname( hostname);
        -: 8070:
        4: 8071:  int res = troll_readParam(&par, argv[1] );
        4: 8072:  if (res != 0) {
    #####: 8073:    fprintf(stderr, "Unable to parse the parameter file.\n");
    #####: 8074:    exit(res);
        -: 8075:  }
        -: 8076:
        -: 8077:  //TESPT;
        4: 8078:  Param = &par;
        -: 8079:
        4: 8080:  if (rank==0) { 
        1: 8081:    if (Param->flag_AVG12CO == _PAR_TRUE) fprintf(stderr,"DOCO\n");
    #####: 8082:    else fprintf(stderr,"NOCO\n");
        -: 8083:  }
        -: 8084:  /*-------------------------------------------------------------------------*/
        -: 8085:  /*   SAVE PARAMETER FILE                                                   */
        -: 8086:  /*-------------------------------------------------------------------------*/
        4: 8087:  if (rank==0) {
        -: 8088:    char commandtest[2048];
        1: 8089:    sprintf(commandtest,"cp %s %s.par",argv[1],Param->Out_Offset[0]);
        1: 8090:    int err=system(commandtest);
        1: 8091:    if (err) {
    #####: 8092:      fprintf(stderr,"Error while copy the parameters\n");
        -: 8093:    }
        -: 8094:  }
        -: 8095:
        4: 8096:  NUMBEROFITER = Param->N_IN_ITT;
        -: 8097:  
        -: 8098:  //TEST ----------- Create VEC and MAP folders for output ----------------------
        4: 8099:  if(rank==0){
        -: 8100:    
        -: 8101:    //Recup realative path  MAP and VEC
        1: 8102:    char *path_map = Param->MAP[0];
        1: 8103:    char *path_vec =Param->Out_Offset[0];
        -: 8104:
        -: 8105:    //Init variables
        -: 8106:    char *dirc_map,*dname_map,*dirc_vec,*dname_vec;
        -: 8107:    struct stat st;
        -: 8108:
        -: 8109:    //get absolute path map
        1: 8110:    dirc_map = strdup(path_map);
        1: 8111:    dname_map = dirname(dirc_map);
        -: 8112:
        -: 8113:    //get absolute path vec
        1: 8114:    dirc_vec = strdup(path_vec);
        1: 8115:    dname_vec = dirname(dirc_vec);
        -: 8116:   
        -: 8117:    //check if folders MPA and VEC exist,create them if they don't
        1: 8118:    if (stat(dname_map, &st) == -1) {
    #####: 8119:        mkdir(path_map, 0777);
    #####: 8120:        fprintf(stderr,"MAP = %s  folder created\n",dname_map);
        -: 8121:    }
        1: 8122:    if (stat(dname_vec, &st) == -1) {
    #####: 8123:        mkdir(path_vec, 0777); 
    #####: 8124:        fprintf(stderr,"VEC = %s  folder created\n",dname_vec);
        -: 8125:    }  
        -: 8126:  }
        -: 8127:
        -: 8128:
        -: 8129:  //TEST ----------------------------------------------------------------------
        -: 8130:
        -: 8131:  /*-------------------------------------------------------------------------*/
        -: 8132:  /* parameters consistency checks                                           */
        -: 8133:  /* and default values / legacy behavior for optional parameters            */
        -: 8134:  /*-------------------------------------------------------------------------*/
        -: 8135:
        -: 8136:  // global number of bolometers
        4: 8137:  nbolo = Param->n_Ptg_noPS;
        -: 8138:
        -: 8139:  // get the list of pixnames from Ptg_noPS objects and their frequency
        4: 8140:  pixnames = malloc( nbolo * DETNAMELEN);
        4: 8141:  assert( pixnames != NULL);
        4: 8142:  freqs = malloc( nbolo * sizeof( int));
        4: 8143:  assert( freqs != NULL);
        -: 8144:
       20: 8145:  for (i=0; i<nbolo; i++) {
       16: 8146:    strncpy( pixnames[i], get_pixname( Param->Ptg_noPS[i]), DETNAMELEN);
       16: 8147:    freqs[i] = strtol( pixnames[i], NULL, 10);
       16: 8148:    assert( freqs[i] != 0);
       16: 8149:    if (freqs[i]>MAXFREQ) MAXFREQ=freqs[i];
        -: 8150:  }
        4: 8151:  if (rank==0) fprintf(stderr,"MAXFREQ %d\n",MAXFREQ);
        4: 8152:  singleFreq = freqs[0]; // contains the common frequency to all bolometers, else 0
       16: 8153:  for (i=1; i<nbolo; i++) {
       12: 8154:    if (freqs[i] != singleFreq) singleFreq = 0;
        -: 8155:  }
        -: 8156:
        4: 8157:  assert( Param->n_OUT_NOPOL == Param->n_MAP);
        -: 8158:
        4: 8159:  if (Param->flag_KCMBIN == 0) {
    #####: 8160:    Param->KCMBIN = 0;
        -: 8161:  }
        -: 8162:
        -: 8163:#if 0
        -: 8164:  // disable FITPOLEFF and FITANGLE when nbolo=1
        -: 8165:  if (nbolo == 1) {
        -: 8166:    Param->FITANGLE = 0;
        -: 8167:    Param->FITPOLEFF = 0;
        -: 8168:  }
        -: 8169:#endif
        -: 8170:
        -: 8171:  // get CNN parameters if needed
        4: 8172:  memset(DOCNN,0,MAXTHEOHPR*sizeof(int));
        -: 8173:  
        4: 8174:  if (Param->flag_DOCNN==_PAR_TRUE) {
        4: 8175:    if (Param->n_DOCNN>MAXTHEOHPR) {
    #####: 8176:      fprintf(stderr,"To big DOCNN table [%d], should be smaller than [%d] as the max number of TF\n",(int)(Param->n_DOCNN),(int)(MAXTHEOHPR));
    #####: 8177:      exit(0);
        -: 8178:    }
        4: 8179:    COMP_CNN=1;
       56: 8180:    for (i=0;i<Param->n_DOCNN;i++) {
       52: 8181:      DOCNN[i]=Param->DOCNN[i];
       52: 8182:      if (DOCNN[i]==1) COMP_CNN+=2;
        -: 8183:    }
        -: 8184:    
        4: 8185:    int num_tensorflow=mpi_size;
        4: 8186:    if (Param->flag_CNN_CORE==_PAR_TRUE) num_tensorflow=Param->CNN_CORE;
        -: 8187:    
        -: 8188:    /* Determine my color for tensorflow serveur*/ 
        4: 8189:    int color = rank % num_tensorflow; 
        -: 8190:         
        -: 8191:    /* Split the intercommunicator */ 
        4: 8192:    MPI_Comm_split (MPI_COMM_WORLD, color, rank, &python_comm );
        -: 8193:
        4: 8194:    MPI_Comm_rank(python_comm, &python_rank );
        4: 8195:    MPI_Comm_size(python_comm, &mpi_python_size );
        -: 8196:
        4: 8197:    int ntensorflow=0;
        4: 8198:    for (i=0;i<mpi_size;i++) if ((i/num_tensorflow)==0) ntensorflow++;
        4: 8199:    int *tabtens = (int *) malloc(sizeof(int)*ntensorflow);
        4: 8200:    ntensorflow=0;
       20: 8201:    for (i=0;i<mpi_size;i++) {
       16: 8202:      if ((i/num_tensorflow)==0) {
       16: 8203:	tabtens[ntensorflow]=i;
        -: 8204:	//if (rank==0) fprintf(stderr,"%d %d\n",ntensorflow,tabtens[ntensorflow]);
       16: 8205:	ntensorflow++;
        -: 8206:      }
        -: 8207:    }
        4: 8208:    if (rank==0) fprintf(stderr,"USE %d tensoflow rank\n",ntensorflow);
        -: 8209:	
        -: 8210:    MPI_Group world_group;
        4: 8211:    MPI_Comm_group(MPI_COMM_WORLD, &world_group);
        -: 8212:    MPI_Group prime_group;
        4: 8213:    MPI_Group_incl(world_group,ntensorflow,tabtens,&prime_group );
        -: 8214:
        -: 8215:    // Create a new communicator based on the group
        4: 8216:    MPI_Comm_create_group(MPI_COMM_WORLD, prime_group, 0, &tensorflow_comm);
        -: 8217:    
        4: 8218:    free(tabtens);
        -: 8219:    
        4: 8220:    if (python_rank==0) {
        4: 8221:      MPI_Comm_rank(tensorflow_comm, &tensorflow_rank ); 
        4: 8222:      MPI_Comm_size(tensorflow_comm, &mpi_tensorflow_size );
        -: 8223:    }
        -: 8224:    
        4: 8225:    if (python_rank==0) {
        4: 8226:      InitPython(&MyPythonBackend,Param->CALLCNN,rank);
        -: 8227:    }
        -: 8228:    
        -: 8229:  }
        -: 8230:
        -: 8231:  // default value for REMHDIP is 1 for 545GHz-857GHz
        4: 8232:  if ((singleFreq >= 545) && (Param->flag_REMHDIP == 0)) {
    #####: 8233:    Param->REMHDIP = 1;
    #####: 8234:    Param->flag_REMHDIP = 1;
        -: 8235:  }
        -: 8236:
        -: 8237:  // default save inverse covariance matrix
        4: 8238:  if (Param->flag_saveCOV == 0) {
    #####: 8239:    Param->saveCOV = 1;
    #####: 8240:    Param->flag_saveCOV = 1;
        -: 8241:  }
        -: 8242:
        -: 8243:  // default don't save CO maps
        4: 8244:  if (Param->flag_saveCO == 0) {
    #####: 8245:    Param->saveCO = 0;
    #####: 8246:    Param->flag_saveCO = 1;
        -: 8247:  }
        -: 8248:
        -: 8249:  // default don't BUILDTF
        4: 8250:  if (Param->flag_BUILDTF == 0) {
    #####: 8251:    Param->BUILDTF = 0;
    #####: 8252:    Param->flag_BUILDTF = 1;
        -: 8253:  }
        -: 8254:
        4: 8255:  if (Param->n_bolomask == 0) {
        -: 8256:    // if bolomask is empty, produce a map with all bolometers
    #####: 8257:    assert( Param->n_MAP == 1);
    #####: 8258:    Param->n_bolomask = nbolo;
    #####: 8259:    Param->bolomask = malloc( nbolo * sizeof( PIOINT));
    #####: 8260:    assert( Param->bolomask != NULL);
    #####: 8261:    for (i=0; i<nbolo; i++) {
    #####: 8262:      Param->bolomask[i] = 1;
        -: 8263:    }
        -: 8264:  }
        -: 8265:
        4: 8266:  if (Param->flag_MAPRINGS == 0) {
        -: 8267:    // if MAPRINGS not given, set its default value according to DOMAXVRAIE
    #####: 8268:    Param->flag_MAPRINGS = 1;
    #####: 8269:    Param->n_MAPRINGS = Param->n_MAP;
    #####: 8270:    Param->MAPRINGS = malloc( Param->n_MAPRINGS * sizeof( PIOLONG));
    #####: 8271:    assert( Param->MAPRINGS != NULL);
    #####: 8272:    for (i=0; i<Param->n_MAPRINGS; i++) {
    #####: 8273:      if (Param->DOMAXVRAIE == 0) {
    #####: 8274:        Param->MAPRINGS[i] = FULL + HM12 + S12345 + YEAR12 + FULLODDEVEN;
        -: 8275:      }
        -: 8276:      else {
    #####: 8277:        Param->MAPRINGS[i] = FULL + HM12;
        -: 8278:      }
        -: 8279:    }
        -: 8280:  }
        4: 8281:  assert( Param->n_MAPRINGS == Param->n_MAP);
        -: 8282:
        -: 8283:  // manage addHPR lists and default values
        4: 8284:  if (Param->flag_addHPR_name == 1) {
    #####: 8285:    assert( Param->n_addHPR_name % nbolo == 0);
        -: 8286:    // if addHPR_factor is not given, set it to 1.0
    #####: 8287:    if (Param->flag_addHPR_factor == 0) {
    #####: 8288:      Param->addHPR_factor = malloc( sizeof( PIOFLOAT));
    #####: 8289:      if (Param->addHPR_factor == NULL) {
    #####: 8290:        fprintf( stderr, "ERROR: not enough memory to allocate Param->addHPR_factor\n");
    #####: 8291:        exit(-1);
        -: 8292:      }
    #####: 8293:      Param->addHPR_factor[0] = 1.0;
    #####: 8294:      Param->n_addHPR_factor = 1;
    #####: 8295:      Param->flag_addHPR_factor = 1;
        -: 8296:    }
    #####: 8297:    if ((Param->n_addHPR_factor == 1) && (Param->n_addHPR_name > 1)) {
        -: 8298:      // if only one addHPR_factor value is given, use it for all addHPR_name objects
    #####: 8299:      assert( realloc( Param->addHPR_factor, Param->n_addHPR_name * sizeof( PIOFLOAT)) != NULL);
    #####: 8300:      for (i=1; i<Param->n_addHPR_name; i++) {
    #####: 8301:        Param->addHPR_factor[i] = Param->addHPR_factor[0];
        -: 8302:      }
    #####: 8303:      Param->n_addHPR_factor = Param->n_addHPR_name;
        -: 8304:    }
        -: 8305:    // if addHPR_watts is not given, set it to 0
    #####: 8306:    if (Param->flag_addHPR_watts == 0) {
    #####: 8307:      Param->addHPR_watts = malloc( sizeof( PIOINT));
    #####: 8308:      if (Param->addHPR_watts == NULL) {
    #####: 8309:        fprintf( stderr, "ERROR: not enough memory to allocate Param->addHPR_watts\n");
    #####: 8310:        exit(-1);
        -: 8311:      }
    #####: 8312:      Param->addHPR_watts[0] = 0;
    #####: 8313:      Param->n_addHPR_watts = 1;
    #####: 8314:      Param->flag_addHPR_watts = 1;
        -: 8315:    }
    #####: 8316:    if ((Param->n_addHPR_watts == 1) && (Param->n_addHPR_name > 1)) {
        -: 8317:      // if only one addHPR_watts value is given, use it for all addHPR_name objects
    #####: 8318:      assert( realloc( Param->addHPR_watts, Param->n_addHPR_name * sizeof( PIOINT)) != NULL);
    #####: 8319:      for (i=1; i<Param->n_addHPR_name; i++) {
    #####: 8320:        Param->addHPR_watts[i] = Param->addHPR_watts[0];
        -: 8321:      }
    #####: 8322:      Param->n_addHPR_watts = Param->n_addHPR_name;
        -: 8323:    }
        -: 8324:  }
        -: 8325:
        -: 8326:
        -: 8327:  /*-------------------------------------------------------------------------*/
        -: 8328:  /* MPI: Ring dispatching between available ranks                           */
        -: 8329:  /*-------------------------------------------------------------------------*/
        4: 8330:  globalBeginRing = Param->BeginRing;
        4: 8331:  globalEndRing   = Param->EndRing;
        -: 8332:
        -: 8333:  /* Compute some frequently used values */
        4: 8334:  globalRangeRing = globalEndRing - globalBeginRing + 1;
        4: 8335:  globalRankInfo.BeginRing = (PIOLONG *)malloc(sizeof(PIOLONG) * mpi_size);
        4: 8336:  if (globalRankInfo.BeginRing == NULL) {
    #####: 8337:    perror("Error");
    #####: 8338:    return 1;
        -: 8339:  }
        4: 8340:  globalRankInfo.EndRing   = (PIOLONG *)malloc(sizeof(PIOLONG) * mpi_size);
        4: 8341:  if (globalRankInfo.EndRing == NULL) {
    #####: 8342:    perror("Error");
    #####: 8343:    return 1;
        -: 8344:  }
        -: 8345:
        4: 8346:  if (Param->flag_stim_paramfiles == 1) {
        -: 8347:    /* Compute load balancing per sample count, starting from the end where very long rings are */
    #####: 8348:    for (int irank = mpi_size-1; irank >= 0 ; irank--) {
    #####: 8349:      if (irank == mpi_size-1) {
    #####: 8350:        globalRankInfo.EndRing[irank] = globalEndRing;
        -: 8351:      } else {
    #####: 8352:        globalRankInfo.EndRing[irank] = globalRankInfo.BeginRing[irank+1] - 1;
        -: 8353:      }
    #####: 8354:      if (irank == 0) {
    #####: 8355:        globalRankInfo.BeginRing[irank] = globalBeginRing;
        -: 8356:      } else {
    #####: 8357:        long samples_to_process = (ENDRINGINDEX( globalRankInfo.EndRing[irank]) - BEGINRINGINDEX( globalBeginRing)) / (irank+1);
    #####: 8358:        int temp_beg_ring = globalRankInfo.EndRing[irank]-1;
    #####: 8359:        while (ENDRINGINDEX( globalRankInfo.EndRing[irank]) - BEGINRINGINDEX( temp_beg_ring) < samples_to_process) {
    #####: 8360:          temp_beg_ring--;
        -: 8361:        }
    #####: 8362:        globalRankInfo.BeginRing[irank] = temp_beg_ring+1;
        -: 8363:      }
        -: 8364:    }
        -: 8365:  } else {
        -: 8366:    /* Compute load balancing per ring count*/
        -: 8367:    // number of ranks to get an extra ring to proceed
        4: 8368:    PIOLONG balancing_correction = 0;
        4: 8369:    PIOLONG rings_per_rank = globalRangeRing / mpi_size;
        -: 8370:    /* Check border case: when more proc than ring to process */
        4: 8371:    if (rings_per_rank == 0) {
    #####: 8372:      if (rank==0) {
    #####: 8373:        fprintf(stderr,"ERROR: too few data to be processed ("PIOLONG_FMT" rings) regarding the available ranks (%d)\n",
        -: 8374:            globalRangeRing, mpi_size);
        -: 8375:      }
    #####: 8376:      return 1;
        -: 8377:    } else { // Take all available procs
        4: 8378:      balancing_correction = globalRangeRing - (rings_per_rank * mpi_size);
        -: 8379:    }
        -: 8380:
        4: 8381:    if (rank==0) {
        1: 8382:      fprintf( stderr, "LoadBalancing globalRangeRing      = "PIOLONG_FMT" \n", globalRangeRing);
        1: 8383:      fprintf( stderr, "LoadBalancing rings_per_rank       = "PIOLONG_FMT" \n", rings_per_rank);
        1: 8384:      fprintf( stderr, "LoadBalancing balancing_correction = "PIOLONG_FMT" \n", balancing_correction);
        -: 8385:    }
        -: 8386:
        4: 8387:    PIOLONG previous = globalBeginRing;
       20: 8388:    for (int irank = 0; irank < mpi_size; irank++) {
       16: 8389:      PIOLONG sup = (balancing_correction>0) ? 1:0;
       16: 8390:      PIOLONG range = rings_per_rank + sup;
       16: 8391:      globalRankInfo.BeginRing[irank] = previous;
       16: 8392:      globalRankInfo.EndRing[irank]   = previous+range-1; // -1 since this is an index of ring!
       16: 8393:      previous += range;
       16: 8394:      if (balancing_correction != 0) {
       12: 8395:        balancing_correction--;
        -: 8396:      }
        -: 8397:    }
        -: 8398:  }
        -: 8399:
        -: 8400:  /* Display ring dispatching between ranks */
        -: 8401: //if (Param->verbose > 0) {
       20: 8402:    for (int irank = 0; irank < mpi_size; irank++) {
       16: 8403:      if (rank == irank) {
       20: 8404:        fprintf( stderr, "  rank#%d/%d (%s, %.2fGB) begin=%ld end=%ld, (%ld rings, %de6 samples)\n",
        4: 8405:                irank, mpi_size, hostname, GetFreeMemGB(),
        8: 8406:                globalRankInfo.BeginRing[irank], globalRankInfo.EndRing[irank],
        4: 8407:                globalRankInfo.EndRing[irank] - globalRankInfo.BeginRing[irank] + 1,
        4: 8408:                (int)((ENDRINGINDEX( globalRankInfo.EndRing[irank]) - BEGINRINGINDEX(globalRankInfo.BeginRing[irank])) / 1e6));
        -: 8409:      }
       16: 8410:      MPI_Barrier(MPI_COMM_WORLD);
        -: 8411:    }
        -: 8412: // }
        -: 8413:
        -: 8414:  /*--- End : MPI: Ring dispatching --- */
        -: 8415:
        -: 8416:
        4: 8417:  PIOINT Nside=Param->Nside;
        -: 8418:
        4: 8419:  if (Param->flag_stim_paramfiles == 1) {
    #####: 8420:    assert( Param->n_stim_paramfiles == nbolo);
        -: 8421:  }
        -: 8422:
        -: 8423:#ifndef DOMAP
        -: 8424:  PIOLONG LMAX=Param->LMAX*(Param->LMAX+1)+Param->LMAX;
        -: 8425:#endif
        4: 8426:  MPI_Barrier(MPI_COMM_WORLD);
        4: 8427:  CUTRG=Param->CUTRG;
        -: 8428:
        4: 8429:  PIOSTRING *mapout = (PIOSTRING *) malloc(sizeof(PIOSTRING)*Param->n_MAP);
        -: 8430:
        4: 8431:  REMHDIP = Param->REMHDIP;
        -: 8432://  Param->REMDIP = Param->REMDIP; // ??? commented by SM Nov2018
        -: 8433:
        4: 8434:  assert( Param->n_NEP == nbolo);
        4: 8435:  assert( Param->n_Calibration == nbolo);
        4: 8436:  NEP_tab = malloc( nbolo * sizeof( double));
        -: 8437:
        4: 8438:  double avvnep=0;
        4: 8439:  for (i=0;i<nbolo;i++) avvnep+=Param->NEP[i]/Param->Calibration[i];
        4: 8440:  for (i=0;i<nbolo;i++) NEP_tab[i]=nbolo*Param->NEP[i]/Param->Calibration[i]/avvnep;
        4: 8441:  if (rank==0) {
        1: 8442:    for (i=0;i<nbolo;i++) fprintf( stderr,"NEP_tab[%ld (%s)]=%lf\n", i, pixnames[i], NEP_tab[i]);
        -: 8443:  }
        -: 8444:
        4: 8445:  MPI_Barrier(MPI_COMM_WORLD);
        -: 8446:
        -: 8447:  PIOINT  *badring;
        -: 8448:  PIOINT  *ibadring;
        -: 8449:  int rg_max;
        -: 8450:#ifdef GAIN_RATIO
        -: 8451:  PIODOUBLE  **gain_ratio = (PIODOUBLE **) malloc(nbolo*sizeof(PIODOUBLE *));
        -: 8452:  PIOLONG     **gain_ratio_off = (PIOLONG **) malloc(nbolo*sizeof(PIOLONG *));
        -: 8453:#endif
        -: 8454:
        4: 8455:  srand48((long)(rank+Param->SEED[0]));
        -: 8456:
        4: 8457:  PIOLONG *l_nhpix  = (PIOLONG *) malloc(sizeof(PIOLONG)*12*Nside*Nside);
        4: 8458:  hpix **l_hpix = (hpix **) malloc(sizeof(hpix *)*12*Nside*Nside);
        4: 8459:  memset(l_nhpix,0,sizeof(PIOLONG)*12*Nside*Nside);
        -: 8460:
        4: 8461:  assert( Param->n_Theo_noPS % nbolo == 0);
        4: 8462:  npixbeam = Param->n_Theo_noPS / nbolo;
        4: 8463:  assert( npixbeam+5 <= MAXTHEOHPR); // npixbeam+5 = (n_Theo_noPS per bolo) + ANGLE + POLEFF + TDUST + CO13 + SYNCROTRON
        -: 8464:
        -: 8465:  /*======================================================
        -: 8466:    =
        -: 8467:    =      read data
        -: 8468:    =
        -: 8469:    =*/
        -: 8470:
        4: 8471:  PIOFLOAT **theo = (PIOFLOAT **) malloc(sizeof(PIOFLOAT *)*npixbeam);
        -: 8472:
        -: 8473:  long vmem,phymem;
        -: 8474:
        -: 8475:  PIOLONG ib;
        4: 8476:  eta=(double *) malloc(sizeof(double)*nbolo); // (1-crosspol)/(1+crosspol)
        4: 8477:  eta_dest=(double *) malloc(sizeof(double)*nbolo);
        4: 8478:  dpsico=(double *) malloc(sizeof(double)*nbolo);
        4: 8479:  dpsisi=(double *) malloc(sizeof(double)*nbolo);
        -: 8480:
        4: 8481:  int nside128=128; // IF DO2048=1 then all 128 maps are used in 2048
        4: 8482:  if (Param->flag_TEMPLATE_NSIDE) {
        4: 8483:    nside128=Param->TEMPLATE_NSIDE;
        -: 8484:  }
        -: 8485:
        4: 8486:  PIOFLOAT *FREEFREE=NULL;
        4: 8487:  if (Param->flag_Theo_FREEFREE==_PAR_TRUE) {
    #####: 8488:    FREEFREE = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
    #####: 8489:    PIOLONG nsa  = noDMC_readObject_PIOFLOAT(Param->Theo_FREEFREE,0,12*nside128*nside128,FREEFREE);
    #####: 8490:    if (nsa<0) {
    #####: 8491:      fprintf(stderr, "Impossible to read Theo_FREEFREE: %s %d\n",Param->Theo_FREEFREE,(int) nsa);
        -: 8492:
    #####: 8493:      exit ( -1);
        -: 8494:    }
        -: 8495:  }
        -: 8496:
        4: 8497:  PIOLONG nadu3=Param->n_NADU;
        4: 8498:  GAINSTEPADU=Param->n_NADU;
        4: 8499:  DODISTOR=0;
        4: 8500:  fprintf(stderr,"debug print => nbolo = %d mpi_size = %d \n",nbolo,mpi_size);
        4: 8501:  if (GAINSTEPADU!=0) {
        4: 8502:    DODISTOR=0;
       20: 8503:    for (i=0;i<Param->n_NADU;i++) {
       16: 8504:      if (Param->NADU[i]>1) DODISTOR=Param->NADU[i];
        -: 8505:    }
        4: 8506:    if (DODISTOR>0) {
        4: 8507:      if (mpi_size<nbolo) {
    #####: 8508:	fprintf(stderr,"Number of bolometer should be bigger than number of bolometer for the fit_adu function\n");
    #####: 8509:	fprintf(stderr,"debug print => nbolo = %d mpi_size = %d \n",nbolo,mpi_size);
        -: 8510:	
    #####: 8511:	exit(-1);
        -: 8512:      }
        -: 8513:#if 0
        -: 8514:      // USELESS IF NOT USING
        -: 8515:      if (DODISTOR>16) nadudeg=7;
        -: 8516:      else nadudeg=1;
        -: 8517:#endif
        4: 8518:      GAINSTEPADU=nadu3; //Param->GAINSTEP;
        4: 8519:      nadu3=GAINSTEPADU;
        -: 8520:      //Param->GAINSTEP=1;
       20: 8521:      for (i=0;i<nbolo;i++) {
       16: 8522:	nadufit[i]=Param->NADU[i];
       16: 8523:	ADURGSTEP[i] = Param->NADUSTEP[i];
       16: 8524:	nadustep[i]=ADUSTEP;  // histogram independant from NADU
        -: 8525:      }
        -: 8526:    }
        -: 8527:  }
        4: 8528:  if (DODISTOR!=0) {
       20: 8529:    for (i=0;i<nbolo;i++) {
       16: 8530:      bspline[i] = bspline_alloc (3,nadufit[i]-2);
       16: 8531:      bspline_init_uniform (bspline[i], 0.0, 128.0);
       16: 8532:      if (rank==0) fprintf(stderr,"DODISTOR [%d]: %d %d\n",(int) i,(int) DODISTOR,(int) bspline[i]->Ncoefs);
        -: 8533:
       16: 8534:      if (ADURGSTEP[i]>2) {
    #####: 8535:	bsplineTime[i] = bspline_alloc (3,ADURGSTEP[i]-2);
    #####: 8536:	bspline_init_uniform (bsplineTime[i], 0.0, 1.0);
    #####: 8537:	if (rank==0) fprintf(stderr,"DODISTOR TIME [%d]: %d %d\n",(int) i,(int) ADURGSTEP[i],(int) bsplineTime[i]->Ncoefs);
        -: 8538:      }
        -: 8539:    }
        -: 8540:  }
        -: 8541:  else {
    #####: 8542:    if (rank==0) fprintf(stderr,"DODISTOR : %d\n",(int) DODISTOR);
        -: 8543:  }
        -: 8544:
        4: 8545:  if (rank==0) fprintf(stderr,"REMDIP : %d\n",(int) Param->REMDIP);
        -: 8546:
        4: 8547:  PIOFLOAT *skymodelI = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*2048*2048);
        4: 8548:  PIOFLOAT *skymodelQ = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*2048*2048);
        4: 8549:  PIOFLOAT *skymodelU = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*2048*2048);
        -: 8550:
        4: 8551:  PIOFLOAT *synchromodelI = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
        4: 8552:  PIOFLOAT *synchromodelQ = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
        4: 8553:  PIOFLOAT *synchromodelU = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
        -: 8554:
        4: 8555:  if (Param->flag_in_synchro_map_I==_PAR_TRUE) {
        -: 8556:
    #####: 8557:    PIOLONG nsa  = noDMC_readObject_PIOFLOAT(Param->in_synchro_map_I,0,12*nside128*nside128,synchromodelI);
    #####: 8558:    if (nsa<0) {
    #####: 8559:      fprintf(stderr, "Impossible to read in_template_map_I: %s %d\n",Param->in_synchro_map_I,(int) nsa);
        -: 8560:
    #####: 8561:      exit ( -1);
        -: 8562:    }
    #####: 8563:    nsa  = noDMC_readObject_PIOFLOAT(Param->in_synchro_map_Q,0,12*nside128*nside128,synchromodelQ);
    #####: 8564:    if (nsa<0) {
    #####: 8565:      fprintf(stderr, "Impossible to read in_template_map_Q: %s %d\n",Param->in_synchro_map_Q,(int) nsa);
        -: 8566:
    #####: 8567:      exit ( -1);
        -: 8568:    }
    #####: 8569:    nsa  = noDMC_readObject_PIOFLOAT(Param->in_synchro_map_U,0,12*nside128*nside128,synchromodelU);
    #####: 8570:    if (nsa<0) {
    #####: 8571:      fprintf(stderr, "Impossible to read in_template_map_U: %s %d\n",Param->in_synchro_map_U,(int) nsa);
        -: 8572:
    #####: 8573:      exit ( -1);
        -: 8574:    }
    #####: 8575:    DOSYNCHRO=1;
        -: 8576:  }
        -: 8577:  else {
        4: 8578:    free(synchromodelI);
        4: 8579:    free(synchromodelQ);
        4: 8580:    free(synchromodelU);
        -: 8581:  }
        -: 8582:
        4: 8583:  PIOFLOAT *comapI=NULL;
        4: 8584:  PIOFLOAT *comap13I=NULL;
        4: 8585:  if (Param->flag_Theo_CO==_PAR_TRUE) {
        4: 8586:    comapI = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
        4: 8587:    PIOLONG nsa  = noDMC_readObject_PIOFLOAT(Param->Theo_CO,0,12*nside128*nside128,comapI);
        4: 8588:    if (nsa<0) {
    #####: 8589:      fprintf(stderr, "Impossible to read Theo_CO: %s %d\n",Param->Theo_CO,(int) nsa);
        -: 8590:
    #####: 8591:      exit ( -1);
        -: 8592:    }
        -: 8593:  }
        -: 8594:
        4: 8595:  if (Param->flag_Theo_13CO==_PAR_TRUE) {
        4: 8596:    comap13I = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
        4: 8597:    PIOLONG nsa  = noDMC_readObject_PIOFLOAT(Param->Theo_13CO,0,12*nside128*nside128,comap13I);
        4: 8598:    if (nsa<0) {
    #####: 8599:      fprintf(stderr, "Impossible to read Theo_13CO: %s %d\n",Param->Theo_13CO,(int) nsa);
        -: 8600:
    #####: 8601:      exit ( -1);
        -: 8602:    }
        -: 8603:  }
        -: 8604:
        4: 8605:  PIOFLOAT *dustmapI=NULL;
        4: 8606:  PIOFLOAT *dustmapQ=NULL;
        4: 8607:  PIOFLOAT *dustmapU=NULL;
        -: 8608:
        4: 8609:  PIOFLOAT *tdustmapI=NULL;
        4: 8610:  PIOFLOAT *tdustmapQ=NULL;
        4: 8611:  PIOFLOAT *tdustmapU=NULL;
        -: 8612:
        4: 8613:  if (Param->flag_Theo_Dust_I==_PAR_TRUE) {
        4: 8614:    dustmapI = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
        4: 8615:    PIOLONG nsa  = noDMC_readObject_PIOFLOAT(Param->Theo_Dust_I,0,12*nside128*nside128,dustmapI);
        4: 8616:    if (nsa<0) {
    #####: 8617:      fprintf(stderr, "Impossible to read Theo_Dust_I: %s %d\n",Param->Theo_Dust_I,(int) nsa);
        -: 8618:
    #####: 8619:      exit ( -1);
        -: 8620:    }
        4: 8621:    dustmapQ = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
        4: 8622:    nsa  = noDMC_readObject_PIOFLOAT(Param->Theo_Dust_Q,0,12*nside128*nside128,dustmapQ);
        4: 8623:    if (nsa<0) {
    #####: 8624:      fprintf(stderr, "Impossible to read Theo_Dust_Q: %s %d\n",Param->Theo_Dust_Q,(int) nsa);
        -: 8625:
    #####: 8626:      exit ( -1);
        -: 8627:    }
        4: 8628:    dustmapU = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
        4: 8629:    nsa  = noDMC_readObject_PIOFLOAT(Param->Theo_Dust_U,0,12*nside128*nside128,dustmapU);
        4: 8630:    if (nsa<0) {
    #####: 8631:      fprintf(stderr, "Impossible to read Theo_Dust_U:%s %d\n",Param->Theo_Dust_U,(int) nsa);
        -: 8632:
    #####: 8633:      exit ( -1);
        -: 8634:    }
        -: 8635:  }
        4: 8636:  if (Param->flag_Theo_TDust_I==_PAR_TRUE) {
        -: 8637:
    #####: 8638:    DOTDUST=1;
        -: 8639:
    #####: 8640:    tdustmapI = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
    #####: 8641:    PIOLONG nsa  = noDMC_readObject_PIOFLOAT(Param->Theo_TDust_I,0,12*nside128*nside128,tdustmapI);
    #####: 8642:    if (nsa<0) {
    #####: 8643:      fprintf(stderr, "Impossible to read Theo_Dust_I: %s %d\n",Param->Theo_Dust_I,(int) nsa);
        -: 8644:
    #####: 8645:      exit ( -1);
        -: 8646:    }
    #####: 8647:    tdustmapQ = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
    #####: 8648:    nsa  = noDMC_readObject_PIOFLOAT(Param->Theo_TDust_Q,0,12*nside128*nside128,tdustmapQ);
    #####: 8649:    if (nsa<0) {
    #####: 8650:      fprintf(stderr, "Impossible to read Theo_Dust_Q: %s %d\n",Param->Theo_Dust_Q,(int) nsa);
        -: 8651:
    #####: 8652:      exit ( -1);
        -: 8653:    }
    #####: 8654:    tdustmapU = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
    #####: 8655:    nsa  = noDMC_readObject_PIOFLOAT(Param->Theo_TDust_U,0,12*nside128*nside128,tdustmapU);
    #####: 8656:    if (nsa<0) {
    #####: 8657:      fprintf(stderr, "Impossible to read Theo_Dust_U:%s %d\n",Param->Theo_Dust_U,(int) nsa);
        -: 8658:
    #####: 8659:      exit ( -1);
        -: 8660:    }
        -: 8661:  }
        4: 8662:  PIOFLOAT *addpol=NULL;
        4: 8663:  if (Param->flag_ADDPOL==_PAR_TRUE) {
    #####: 8664:    addpol= (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*128*128*2);
    #####: 8665:    PIOLONG nsa  = noDMC_readObject_PIOFLOAT(Param->ADDPOL,0,12*128*128*2,addpol);
    #####: 8666:    if (nsa<0) {
    #####: 8667:      fprintf(stderr, "Impossible to read ADDPOL: %s %d\n",Param->ADDPOL,(int) nsa);
        -: 8668:
    #####: 8669:      exit ( -1);
        -: 8670:    }
        -: 8671:  }
        -: 8672:
        4: 8673:  PIOFLOAT *inpolarQ=NULL;
        4: 8674:  PIOFLOAT *inpolarU=NULL;
        4: 8675:  inpolarQ = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
        4: 8676:  inpolarU = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*12*nside128*nside128);
        -: 8677:
        4: 8678:  long nnoisesim = 1048576;
        4: 8679:  fftw_complex  *in_fft = NULL;
        4: 8680:  fftw_complex  *out_fft = NULL;
        4: 8681:  fftw_plan     p1 = NULL, p2 = NULL;
        -: 8682:
        4: 8683:  if (Param->flag_stim_paramfiles == 1) {
        -: 8684:    // stim_paramfiles parameter overrides TESTPOL
    #####: 8685:    Param->TESTPOL = -1;
        -: 8686:  }
        -: 8687:
        4: 8688:  if (Param->TESTPOL==0) {
    #####: 8689:    assert( (Param->n_Calibration == 5 * nbolo)
        -: 8690:            && "Error: simulations inside troll requires 5 calibration values per bolo for ADCNL residuals");
        -: 8691:    // prepare FFTW for adding noise from noise Fourier Transform
    #####: 8692:    in_fft  = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * nnoisesim);
    #####: 8693:    out_fft = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * nnoisesim);
    #####: 8694:    p1 = fftw_plan_dft_1d( nnoisesim, in_fft, out_fft, FFTW_FORWARD, FFTW_ESTIMATE );
    #####: 8695:    p2 = fftw_plan_dft_1d( nnoisesim, in_fft, out_fft, FFTW_BACKWARD, FFTW_ESTIMATE );
        -: 8696:  }
        -: 8697:
        -: 8698:  //long stepadu=(globalEndRing-globalBeginRing+1)/Param->REMDIP;
        4: 8699:  int number_of_iterations = 1;
        -: 8700:
       20: 8701:  for (ib=0;ib<nbolo;ib++) {
        -: 8702:
       16: 8703:    if (Param->n_in_template_map_I>0) {
       16: 8704:      PIOLONG nsa  = noDMC_readObject_PIOFLOAT(Param->in_template_map_I[ib],0,12*2048*2048,skymodelI);
       16: 8705:      if (nsa<0) {
    #####: 8706:	fprintf(stderr, "Impossible to read in_template_map_I: %s %d\n",Param->in_template_map_I[ib],(int) nsa);
        -: 8707:
    #####: 8708:	exit ( -1);
        -: 8709:      }
       16: 8710:      nsa  = noDMC_readObject_PIOFLOAT(Param->in_template_map_Q[ib],0,12*2048*2048,skymodelQ);
       16: 8711:      if (nsa<0) {
    #####: 8712:	fprintf(stderr, "Impossible to read in_template_map_Q: %s %d\n",Param->in_template_map_Q[ib],(int) nsa);
        -: 8713:
    #####: 8714:	exit ( -1);
        -: 8715:      }
       16: 8716:      nsa  = noDMC_readObject_PIOFLOAT(Param->in_template_map_U[ib],0,12*2048*2048,skymodelU);
       16: 8717:      if (nsa<0) {
    #####: 8718:	fprintf(stderr, "Impossible to read in_template_map_U: %s %d\n",Param->in_template_map_U[ib],(int) nsa);
        -: 8719:
    #####: 8720:	exit ( -1);
        -: 8721:      }
        -: 8722:    }
        -: 8723:    else {
    #####: 8724:      memset(skymodelI,0,12*2048*2048*sizeof(PIOFLOAT));
    #####: 8725:      memset(skymodelQ,0,12*2048*2048*sizeof(PIOFLOAT));
    #####: 8726:      memset(skymodelU,0,12*2048*2048*sizeof(PIOFLOAT));
        -: 8727:    }
        -: 8728:
       16: 8729:    if (Param->flag_in_polar_fit_Q==_PAR_TRUE) {
       16: 8730:      PIOLONG nsa  = noDMC_readObject_PIOFLOAT(Param->in_polar_fit_Q[ib],0,12*nside128*nside128,inpolarQ);
       16: 8731:      if (nsa<0) {
    #####: 8732:	fprintf(stderr, "Impossible to read in_polar_fit_Q: %s %d\n",Param->in_polar_fit_Q[ib],(int) nsa);
        -: 8733:
    #####: 8734:	exit ( -1);
        -: 8735:      }
       16: 8736:      nsa  = noDMC_readObject_PIOFLOAT(Param->in_polar_fit_U[ib],0,12*nside128*nside128,inpolarU);
       16: 8737:      if (nsa<0) {
    #####: 8738:	fprintf(stderr, "Impossible to read in_polar_fit_U: %s %d\n",Param->in_polar_fit_U[ib],(int) nsa);
        -: 8739:
    #####: 8740:	exit ( -1);
        -: 8741:      }
        -: 8742:    }
        -: 8743:
        -: 8744:
       16: 8745:    double *tfnoise=NULL;
       16: 8746:    if (Param->TESTPOL==0) {
    #####: 8747:      tfnoise=(double *)malloc(sizeof(double)*nnoisesim);
    #####: 8748:      int fp=open(Param->Signal_noPS[2*nbolo+ib],O_RDONLY,0664);
    #####: 8749:      int err=read(fp,tfnoise,sizeof(double)*nnoisesim);
    #####: 8750:      close(fp);
    #####: 8751:      if (err<0) {
    #####: 8752:        fprintf(stderr,"Do not succeed to read Signal_noPS[%ld]: %s %d %ld\n",2*nbolo+ib,Param->Signal_noPS[2*nbolo+ib],err,(long) nnoisesim);
    #####: 8753:        exit(-1);
        -: 8754:      }
    #####: 8755:      double reg=sqrt(1.21)/((double)nnoisesim); //Take into account effect of the correlation
    #####: 8756:      for (i=0;i<nnoisesim;i++) tfnoise[i]*=reg;
        -: 8757:    }
        -: 8758:
       16: 8759:    eta[ib]=(1.-Param->CrossPol[ib])/(1.+Param->CrossPol[ib]);
       16: 8760:    if (Param->D_NOPOL) eta_dest[ib]=0;
       16: 8761:    else eta_dest[ib]=eta[ib];
        -: 8762:
       16: 8763:    dpsico[ib]=1;
       16: 8764:    dpsisi[ib]=0;
       16: 8765:    double sxi= (Param->Calibration[ib]/Param->NEP[ib])*(Param->Calibration[ib]/Param->NEP[ib]);
       16: 8766:    if (rank==0) fprintf(stderr,"SXI %d %lg\n",(int) ib,sxi);
       32: 8767:    sprintf(Command,"begin=%lld;end=%lld",
       16: 8768:            (long long) (globalRankInfo.BeginRing[rank]),
       16: 8769:            (long long) (globalRankInfo.EndRing[rank]));
        -: 8770:
       16: 8771:    int ring_count = globalEndRing-globalBeginRing+1;
       16: 8772:    badring = (PIOINT *) malloc(sizeof(PIOINT)*ring_count);
       16: 8773:    if (badring == NULL) {
    #####: 8774:      fprintf(stderr, "**** ERROR **** Memory allocation error !!!!\n");
    #####: 8775:      fprintf(stderr, "** rank = %d  globalRankInfo.BeginRing[rank]="PIOLONG_FMT"  globalRankInfo.EndRing[rank]="PIOLONG_FMT"\n", rank, globalRankInfo.BeginRing[rank], globalRankInfo.EndRing[rank]);
        -: 8776:    }
        -: 8777:
       16: 8778:    assert( check_pixname( Param->Badring[ib], pixnames[ib]));
       16: 8779:    int tperr = noDMC_readObject_PIOINT(Param->Badring[ib],globalBeginRing,ring_count,badring);
       16: 8780:    if (tperr<0) {
    #####: 8781:      fprintf(stderr, "Impossible to read Badring[%ld]: %s %d\n",ib,Param->Badring[ib],tperr);
    #####: 8782:      exit ( -1);
        -: 8783:    }
        -: 8784:
       16: 8785:    ibadring=(PIOINT *) malloc(sizeof(PIOINT)*ring_count);
        -: 8786:    // compute ring taking into account the badring
        -: 8787:    {
       16: 8788:      rg_max=0;
     4160: 8789:      for (i=0;i<ring_count;i++) {
     4144: 8790:	ibadring[i]=rg_max;
     4144: 8791:	if (badring[i]==0) {
     4060: 8792:	  rg_max++;
        -: 8793:	}
        -: 8794:      }
        -: 8795:    }
       16: 8796:    if (rank==0) fprintf(stderr,"RG_MAX %ld\n",(long) rg_max);
        -: 8797:    /*=========================================================================================
        -: 8798:      Compute spline in Time:
        -: 8799:      =========================================================================================*/
        -: 8800:    
       16: 8801:    if (ADURGSTEP[ib]>2) {
    #####: 8802:      for (i=globalBeginRing;i<=globalEndRing;i++) {
    #####: 8803:	double sadu=((double) ibadring[i-globalBeginRing])/rg_max;
        -: 8804:	//	if (rank==0) fprintf(stderr,"RG_MAX %ld %lf\n",(long) i,(double) sadu);
    #####: 8805:	bspline_value(bsplineTime[ib],sadu,rg_start[ib]+i,rg_end[ib]+i);
    #####: 8806:	double *vals = bsplineTime[ib]->vals;
    #####: 8807:	for (j=rg_start[ib][i];j<=rg_end[ib][i];j++) rg_vals[ib][j-rg_start[ib][i]+4*i]=vals[j];
        -: 8808:      }
        -: 8809:    }
        -: 8810:
        -: 8811:
        -: 8812:
        -: 8813:    int iter;
        -: 8814:    PIOFLOAT *stim_hpr[MAXSIMU];
       32: 8815:    for (iter = 0; iter < number_of_iterations; iter++) {
       16: 8816:      stim_hpr[iter] = NULL;
        -: 8817:    }
        -: 8818:
       16: 8819:    if (Param->flag_stim_paramfiles == 1) {
        -: 8820:
    #####: 8821:      if (rank==0) {
    #####: 8822:        GetProcMem(&vmem,&phymem);
    #####: 8823:        fprintf(stderr,"\nbefore stim bolo loop: used VMEM %.1lf[PHYS %.1lf]MB\n",
    #####: 8824:            (double) vmem/1024./1024., (double) phymem/1024./1024.);
        -: 8825:      }
        -: 8826:
        -: 8827:      stimParameters stimPar;
        -: 8828:      // read stim parameter file for this bolometer and broadcast it to all MPI ranks
    #####: 8829:      init_stim( &stimPar, Param->stim_paramfiles[ib]);
    #####: 8830:      number_of_iterations = stimPar.Param.iterations;
    #####: 8831:      if (number_of_iterations > MAXSIMU) {
    #####: 8832:        fprintf(stderr, "Number of simulation iterations %d > MAXSIMU %d\n", number_of_iterations, MAXSIMU);
    #####: 8833:        exit ( -1);
        -: 8834:      }
    #####: 8835:      if ((number_of_iterations > 1) && (stimPar.Param.stay_in_memory == -1)) {
    #####: 8836:        stimPar.Param.stay_in_memory = 1;
        -: 8837:      } else {
    #####: 8838:        stimPar.Param.stay_in_memory = 0;
        -: 8839:      }
    #####: 8840:      stim_first_seed = stimPar.Param.random_seed;
        -: 8841:
        -: 8842:      // iterate on stim
    #####: 8843:      for (iter = 0; iter < number_of_iterations; iter++) {
    #####: 8844:        stim_hpr[iter] = malloc( ring_count * RINGSIZE * sizeof( PIOFLOAT));
    #####: 8845:        assert( stim_hpr[iter] != NULL);
    #####: 8846:        stim( &stimPar, globalRankInfo.BeginRing[rank], ring_count, stim_hpr[iter]);
    #####: 8847:        stimPar.Param.random_seed++;
        -: 8848:      }
    #####: 8849:      free_stim( &stimPar);
        -: 8850:
    #####: 8851:      if (rank==0) {
    #####: 8852:        GetProcMem(&vmem,&phymem);
    #####: 8853:        fprintf(stderr,"\nafter stim bolo loop: used VMEM %.1lf[PHYS %.1lf]MB\n",
    #####: 8854:            (double) vmem/1024./1024., (double) phymem/1024./1024.);
        -: 8855:      }
        -: 8856:
        -: 8857:    }
        -: 8858:
       32: 8859:    for (rg=globalRankInfo.BeginRing[rank];rg<=globalRankInfo.EndRing[rank];rg+=Param->RSTEP) {
        -: 8860:
       16: 8861:      if (badring[rg-globalBeginRing]==0) {
        -: 8862:
        -: 8863:        PIOFLOAT *h,*fsl;
        -: 8864:        PIODOUBLE *ph,*th,*psi;
        -: 8865:        PIOFLOAT *diporb;
       12: 8866:        PIOBYTE surv=-1;
       12: 8867:        if (rg>=240&&rg<=5720)    surv=1;
       12: 8868:        if (rg>=5721&&rg<=11194)  surv=2;
       12: 8869:        if (rg>=11195&&rg<=16691) surv=3;
       12: 8870:        if (rg>=16692&&rg<=21720) surv=4;
       12: 8871:        if (rg>=21721)            surv=5;
       12: 8872:        if (Param->EndRing == 27005) {
        -: 8873:          // DX11 / RD12ll half-mission
    #####: 8874:          if (rg>13471)           surv+=10;
        -: 8875:        }
        -: 8876:        else {
        -: 8877:          // RD12RC* half-mission
       12: 8878:          if (rg>13144)           surv+=10;
        -: 8879:        }
        -: 8880:
        -: 8881:        PIOFLOAT *y[MAXSIMU];
        -: 8882:        // get rid of gcc "maybe-uninitialized" warning depending on optimsation level
       24: 8883:        for (iter = 0; iter < number_of_iterations; iter++) {
       12: 8884:          y[iter] = NULL;
        -: 8885:        }
        -: 8886:
       12: 8887:        sprintf(Command,"ring=%lld",(long long)(rg));
       12: 8888:        assert( check_pixname( Param->Hit_noPS[ib], pixnames[ib]));
       12: 8889:        h = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*RINGSIZE);
       12: 8890:        assert( (h != NULL) && "Not enough memory to allocate hitcount HPR array");
       12: 8891:        tperr = noDMC_readObject_PIOFLOAT(Param->Hit_noPS[ib],rg*RINGSIZE,RINGSIZE,h);
       12: 8892:        if (tperr<0) {
    #####: 8893:          fprintf(stderr, "Impossible to read Hit_noPS[%ld]: %s %d\n",ib,Param->Hit_noPS[ib],tperr);          exit ( -1);
        -: 8894:        }
        -: 8895:
       12: 8896:        if (Param->flag_fsl == _PAR_TRUE) {
       12: 8897:          assert( check_pixname( Param->fsl[ib], pixnames[ib]));
       12: 8898:          fsl = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*RINGSIZE);
       12: 8899:          assert( (fsl != NULL) && "Not enough memory to allocate FSL HPR array");
       12: 8900:          tperr = noDMC_readObject_PIOFLOAT(Param->fsl[ib],rg*RINGSIZE,RINGSIZE,fsl);
       12: 8901:          if (tperr<0) {
    #####: 8902:            fprintf(stderr, "Impossible to read fsl[%ld]: %s %d\n",ib,Param->fsl[ib],tperr);
    #####: 8903:            exit ( -1);
        -: 8904:          }
        -: 8905:        } else {
    #####: 8906:          fsl = NULL;
        -: 8907:        }
        -: 8908:
       12: 8909:        if (Param->flag_stim_paramfiles == 0) {
       12: 8910:          assert( check_pixname( Param->Signal_noPS[ib], pixnames[ib]));
       12: 8911:          y[0] = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*RINGSIZE);
       12: 8912:          assert( (y[0] != NULL) && "Not enough memory to allocate signal HPR array");
       12: 8913:          tperr = noDMC_readObject_PIOFLOAT(Param->Signal_noPS[ib],rg*RINGSIZE,RINGSIZE,y[0]);
       12: 8914:          if (tperr<0) {
    #####: 8915:            fprintf(stderr, "Impossible to read Signal_noPS[%ld]: %s %d\n",ib,Param->Signal_noPS[ib],tperr);
    #####: 8916:            exit ( -1);
        -: 8917:          }
        -: 8918:        } else {
    #####: 8919:          for (iter = 0; iter < number_of_iterations; iter++) {
    #####: 8920:            y[iter] = stim_hpr[iter] + RINGSIZE * (rg - globalRankInfo.BeginRing[rank]);
        -: 8921:          }
        -: 8922:        }
        -: 8923:
        -: 8924:
        -: 8925:        /*========================================================================
        -: 8926:          =
        -: 8927:          =                  AJOUT TOISIM
        -: 8928:          =*/
        -: 8929:
       12: 8930:        assert( check_pixname( Param->DipOrb_noPS[ib], pixnames[ib]));
       12: 8931:        diporb = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*RINGSIZE);
       12: 8932:        assert( (diporb != NULL) && "Not enough memory to allocate total dipole HPR array");
       12: 8933:        tperr = noDMC_readObject_PIOFLOAT(Param->DipOrb_noPS[ib],rg*RINGSIZE,RINGSIZE,diporb);
       12: 8934:        if (tperr<0) {
    #####: 8935:          fprintf(stderr, "Impossible to read DipOrb_noPS[%ld]: %s %d\n",ib,Param->DipOrb_noPS[ib],tperr);
    #####: 8936:          exit ( -1);
        -: 8937:        }
        -: 8938:
       12: 8939:        if (Param->KCMBIN == 1) {
        -: 8940:          // input HPR are in KCMB, convert them to watts
    #####: 8941:          for (i=0; i<RINGSIZE; i++) {
    #####: 8942:            y[0][i] *= Param->Calibration[ib];
        -: 8943:          }
        -: 8944:        }
        -: 8945:
       12: 8946:        if (Param->ADDDIP == 1) {
        -: 8947:          // for projection only, signal must contain the total dipole, add it if it's not here
    #####: 8948:          for (i=0; i<RINGSIZE; i++) {
    #####: 8949:            y[0][i] = y[0][i] + diporb[i] * Param->Calibration[ib];
        -: 8950:          }
        -: 8951:        }
        -: 8952:
       12: 8953:        if (Param->flag_addHPR_name == 1) {
    #####: 8954:          PIOFLOAT *addhpr = (PIOFLOAT *) malloc( sizeof( PIOFLOAT) * RINGSIZE);
    #####: 8955:          for (int i = 0; i < Param->n_addHPR_name / nbolo; i++) {
    #####: 8956:            assert( check_pixname( Param->addHPR_name[i*nbolo+ib], pixnames[ib]));
    #####: 8957:            tperr = noDMC_readObject_PIOFLOAT( Param->addHPR_name[i*nbolo+ib], rg*RINGSIZE, RINGSIZE, addhpr);
    #####: 8958:            if (tperr<0) {
    #####: 8959:              fprintf(stderr, "Error %d while reading addHPR_name[%ld]: %s\n", tperr, i*nbolo+ib, Param->addHPR_name[i*nbolo+ib]);
    #####: 8960:              exit ( -1);
        -: 8961:            }
    #####: 8962:            for (j=0; j<RINGSIZE; j++) {
    #####: 8963:              addhpr[j] *= Param->addHPR_factor[i*nbolo+ib];
    #####: 8964:              if (!Param->addHPR_watts[i*nbolo+ib]) {
        -: 8965:                // convert addhpr from KCMB to Watts
    #####: 8966:                addhpr[j] *= Param->Calibration[ib];
        -: 8967:              }
    #####: 8968:              y[0][j] += addhpr[j];
        -: 8969:            }
        -: 8970:          }
    #####: 8971:          free( addhpr);
        -: 8972:        }
        -: 8973:
        -: 8974:        PIOSTRING tpname;
       72: 8975:        for (i=0;i<npixbeam;i++) {
        -: 8976://          assert( check_pixname( Param->Theo_noPS[i*nbolo+ib], pixnames[ib]));
       60: 8977:          theo[i] = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*RINGSIZE);
       60: 8978:          tperr = noDMC_readObject_PIOFLOAT(Param->Theo_noPS[i*nbolo+ib],rg*RINGSIZE,RINGSIZE,theo[i]);
       60: 8979:          if (tperr<0) {
    #####: 8980:            fprintf(stderr, "Impossible to read Theo_noPS[%ld]: %s %d\n",i*nbolo+ib,Param->Theo_noPS[i*nbolo+ib],tperr);
    #####: 8981:            exit ( -1);
        -: 8982:          }
        -: 8983:        }
        -: 8984:
        -: 8985:        PIOFLOAT *ADU;
       12: 8986:        if (Param->flag_ADU==_PAR_TRUE) {
       12: 8987:          assert( check_pixname( Param->ADU[ib], pixnames[ib]));
       12: 8988:          ADU = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*RINGSIZE);
       12: 8989:          tperr = noDMC_readObject_PIOFLOAT(Param->ADU[ib],rg*RINGSIZE,RINGSIZE,ADU);
       12: 8990:          if (tperr<0) {
    #####: 8991:            fprintf(stderr, "Impossible to read ADU[%ld]: %s %d %ld\n",ib,Param->ADU[ib],tperr,(long) rg);
    #####: 8992:            exit ( -1);
        -: 8993:          }
        -: 8994:        }
        -: 8995:        else {
    #####: 8996:          ADU = (PIOFLOAT *) _PIOMALLOC(sizeof(PIOFLOAT)*RINGSIZE);
    #####: 8997:          for (i=0;i<RINGSIZE;i++) ADU[i]=0;
        -: 8998:        }
        -: 8999:
        -: 9000:        PIOFLOAT *phase;
       12: 9001:        if (Param->flag_phase==_PAR_TRUE) {
       12: 9002:          assert( check_pixname( Param->phase[ib], pixnames[ib]));
       12: 9003:          phase = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*RINGSIZE);
       12: 9004:          tperr = noDMC_readObject_PIOFLOAT(Param->phase[ib],rg*RINGSIZE,RINGSIZE,phase);
       12: 9005:          if (tperr<0) {
    #####: 9006:            fprintf(stderr, "Impossible to read phase[%ld]: %s %d %ld\n",ib,Param->phase[ib],tperr,(long) rg);
    #####: 9007:            exit ( -1);
        -: 9008:          }
        -: 9009:	  // normalize the phase to make it usable by 2D neural network 
       12: 9010:	  if (Param->flag_PHASECNN==_PAR_TRUE) {
    #####: 9011:	    float pmin=1E30;
    #####: 9012:	    float pmax=-1E30;
    #####: 9013:	    for (i=0;i<RINGSIZE;i++) {
    #####: 9014:	      if (pmin>phase[i]&&h[i]>0) pmin=phase[i];
    #####: 9015:	      if (pmax<phase[i]&&h[i]>0) pmax=phase[i];
        -: 9016:	    }
    #####: 9017:	    if (pmax>pmin) {
    #####: 9018:	      for (i=0;i<RINGSIZE;i++) {
    #####: 9019:		if (h[i]>0) phase[i]=(phase[i]-pmin)/(pmax-pmin)*2*M_PI;
        -: 9020:	      }
        -: 9021:	    
        -: 9022:	      // normalize the dynamics
    #####: 9023:	      if (Param->PHASECNN==1) {
    #####: 9024:		float *hhisto=(float *) malloc(sizeof(float)*RINGSIZE);
    #####: 9025:		memset(hhisto,0,sizeof(float)*RINGSIZE);
    #####: 9026:		for (i=0;i<RINGSIZE;i++) {
    #####: 9027:		  if (h[i]>0) hhisto[(int)((RINGSIZE-1)*phase[i]/(2*M_PI))]+=h[i];
        -: 9028:		}
    #####: 9029:		for (i=1;i<RINGSIZE;i++) {
    #####: 9030:		  hhisto[i]+=hhisto[i-1];
        -: 9031:		}
    #####: 9032:		for (i=0;i<RINGSIZE;i++) {
    #####: 9033:		  hhisto[i]=2*M_PI*hhisto[i]/hhisto[RINGSIZE-1];
        -: 9034:		}
    #####: 9035:		for (i=0;i<RINGSIZE;i++) {
    #####: 9036:		  if (h[i]>0) phase[i]=hhisto[(int)((RINGSIZE-1)*phase[i]/(2*M_PI))];
        -: 9037:		}
        -: 9038:
    #####: 9039:		free(hhisto);
        -: 9040:	      }
        -: 9041:	    }
        -: 9042:	    else {
    #####: 9043:	      for (i=0;i<RINGSIZE;i++) phase[i]=0;
        -: 9044:	    }
        -: 9045:	  }
        -: 9046:        }
        -: 9047:        else {
    #####: 9048:          phase = (PIOFLOAT *) _PIOMALLOC(sizeof(PIOFLOAT)*RINGSIZE);
    #####: 9049:          for (i=0;i<RINGSIZE;i++) phase[i]=0;
        -: 9050:        }
        -: 9051:
        -: 9052:        //====================================================================================
        -: 9053:        //  E2E
        -: 9054:        //
        -: 9055:
       12: 9056:        if (Param->TESTPOL==0) {
        -: 9057:          // inline production of a colored noise TOI and projection in HPR
    #####: 9058:          assert( check_pixname( Param->Signal_noPS[nbolo+ib], pixnames[ib]));
    #####: 9059:          long ntoisample=(ENDRINGINDEX(rg)-BEGINRINGINDEX(rg)+1);
    #####: 9060:          PIOINT *posnoise=(PIOINT *) malloc(sizeof(PIOINT)*ntoisample);
    #####: 9061:          assert( (posnoise != NULL) && "Not enough memory to allocate HPR index TOI array");
    #####: 9062:          tperr = noDMC_readObject_PIOINT(Param->Signal_noPS[nbolo+ib],BEGINRINGINDEX(rg),ntoisample,posnoise);
        -: 9063:
    #####: 9064:          PIODOUBLE *tpin   = (PIODOUBLE *) in_fft;
    #####: 9065:          PIODOUBLE *tpout  = (PIODOUBLE *) out_fft;
        -: 9066:          // build white noise TOI
    #####: 9067:          for (j=0;j<nnoisesim;j++) {
    #####: 9068:            tpin[2*j]=sqrt(-2*log( drand48()))*cos(2*M_PI*drand48());
    #####: 9069:            tpin[2*j+1]=0;
        -: 9070:          }
    #####: 9071:          fftw_execute(p1);
        -: 9072:
        -: 9073:          // convolve (multiply in frequency domain) white noise TOI with noise Fourier transform
    #####: 9074:          for (j=0;j<nnoisesim;j++) {
    #####: 9075:            tpin[2*j]=tpout[2*j]*tfnoise[j];
    #####: 9076:            tpin[2*j+1]=tpout[2*j+1]*tfnoise[j];
        -: 9077:          }
    #####: 9078:          fftw_execute(p2);
        -: 9079:
        -: 9080:          // projection of colored noise TOI into HPR
    #####: 9081:          for (int iter = 0; iter < number_of_iterations; iter++) {
    #####: 9082:            for (i=0;i<ntoisample;i++) {
    #####: 9083:              if (posnoise[i]>=0&&posnoise[i]<RINGSIZE) {
    #####: 9084:                if (h[posnoise[i]]>0) {
    #####: 9085:                  y[iter][posnoise[i]]+=tpout[2*i]/h[posnoise[i]];
        -: 9086:                }
        -: 9087:              }
        -: 9088:            }
        -: 9089:          }
    #####: 9090:          free(posnoise);
        -: 9091:
        -: 9092:          // ADC nonlinearity simulation
    #####: 9093:          for (int iter = 0; iter < number_of_iterations; iter++) {
    #####: 9094:            for (i=0;i<RINGSIZE;i++) {
    #####: 9095:              double adux=ADU[i]*1E-3-Param->Calibration[nbolo+ib*4+1];
    #####: 9096:              y[iter][i] /= Param->Calibration[nbolo+ib*4]+
    #####: 9097:                            Param->Calibration[nbolo+ib*4+2]*
    #####: 9098:                            (adux)*exp(-(adux)*(adux)*Param->Calibration[nbolo+ib*4+3]);
        -: 9099:            }
        -: 9100:          }
        -: 9101:
        -: 9102:#if 0
        -: 9103:          PIOSTRING thepath;
        -: 9104:          sprintf(thepath,"/redtruck/delouis/TROLL_OUT/test_%d",rank);
        -: 9105:          FILE *fp=fopen(thepath,"w");
        -: 9106:          fwrite(y,RINGSIZE*sizeof(PIOFLOAT),1,fp);
        -: 9107:          fclose(fp);
        -: 9108:          sprintf(thepath,"/redtruck/delouis/TROLL_OUT/testn_%d",rank);
        -: 9109:          fp=fopen(thepath,"w");
        -: 9110:          fwrite(tpout,nnoisesim*sizeof(PIODOUBLE),1,fp);
        -: 9111:          fclose(fp);
        -: 9112:          MPI_Barrier(MPI_COMM_WORLD);
        -: 9113:          exit(0);
        -: 9114:#endif
        -: 9115:        }
        -: 9116:
        -: 9117:        //
        -: 9118:        //====================================================================================
        -: 9119:
       12: 9120:        if (Param->TESTPOL==4) {
    #####: 9121:          for (int iter = 0; iter < number_of_iterations; iter++) {
    #####: 9122:            for (i=0;i<RINGSIZE;i++) {
    #####: 9123:              double adux=ADU[i]*1E-3-Param->Calibration[nbolo+ib*4+1];
    #####: 9124:              y[iter][i] *= Param->Calibration[nbolo+ib*4]+
    #####: 9125:                            Param->Calibration[nbolo+ib*4+2]*
    #####: 9126:                            (adux)*exp(-(adux)*(adux)*Param->Calibration[nbolo+ib*4+3]);
        -: 9127:            }
        -: 9128:          }
        -: 9129:        }
        -: 9130:
       12: 9131:        assert( check_pixname( Param->Ptg_noPS[ib], pixnames[ib]));
       12: 9132:        ph = (PIODOUBLE *) malloc(sizeof(PIODOUBLE)*RINGSIZE);
       12: 9133:        tperr = noDMC_readObject_PIODOUBLE(Param->Ptg_noPS[ib],rg*RINGSIZE,RINGSIZE,ph);
       12: 9134:        if (tperr<0) {
    #####: 9135:          fprintf( stderr, "Impossible to read Ptg_noPS[%ld]: %s %d\n", ib, Param->Ptg_noPS[ib], tperr);
    #####: 9136:          exit ( -1);
        -: 9137:        }
        -: 9138:
       12: 9139:        sprintf( tpname,"%s_TUPLE_1",Param->Ptg_noPS[ib]);
       12: 9140:        th = (PIODOUBLE *) malloc(sizeof(PIODOUBLE)*RINGSIZE);
       12: 9141:        tperr = noDMC_readObject_PIODOUBLE(tpname,rg*RINGSIZE,RINGSIZE,th);
       12: 9142:        if (tperr<0) {
    #####: 9143:          fprintf(stderr, "Impossible to read Ptg_noPS[%ld]: %s %d\n", ib, tpname, tperr);
    #####: 9144:          exit ( -1);
        -: 9145:        }
        -: 9146:
       12: 9147:        sprintf(tpname,"%s_TUPLE_2",Param->Ptg_noPS[ib]);
       12: 9148:        psi = (PIODOUBLE *) malloc(sizeof(PIODOUBLE)*RINGSIZE);
       12: 9149:        tperr = noDMC_readObject_PIODOUBLE(tpname,rg*RINGSIZE,RINGSIZE,psi);
       12: 9150:        if (tperr<0) {
    #####: 9151:          fprintf(stderr, "Impossible to read Ptg_noPS[%ld]: %s %d\n", ib, tpname, tperr);
    #####: 9152:          exit ( -1);
        -: 9153:        }
       12: 9154:        if (Param->flag_delta_psi == _PAR_TRUE) {
       12: 9155:          float delta_psi_radians = Param->delta_psi[ib] * M_PI / 180.0;
   331980: 9156:          for (i=0; i<RINGSIZE; i++) {
   331968: 9157:            psi[i] += delta_psi_radians;
        -: 9158:            // psi must be in [-pi, +pi]
   331968: 9159:            if (psi[i] >  M_PI) psi[i] -= 2*M_PI;
   331968: 9160:            if (psi[i] < -M_PI) psi[i] += 2*M_PI;
        -: 9161:          }
        -: 9162:        }
        -: 9163:
        -: 9164:	/*========================= ~ NORTH ECLIPTIC POLE COORDINATE (max hit count smoothed at 30 degree)
        -: 9165:	  th,ph=(1.0899100645823487, 1.6705050780074633)
        -: 9166:	  iarg=13523074
        -: 9167:	  vec=(-0.08825391070996505, 0.8821818245983525, 0.46256510416666663)
        -: 9168:	  lat,lon=(27.552753250600432, 95.712890625)
        -: 9169:	  
        -: 9170:	  Phase=0 is defined as the nearest point of the ring to this direction
        -: 9171:	*/
        -: 9172:	
        -: 9173:#define EPOLEX (-0.08825391070996505)
        -: 9174:#define EPOLEY (0.8821818245983525)
        -: 9175:#define EPOLEZ (0.46256510416666663)
        -: 9176:	
        -: 9177:	double mmat[9],rres[3];
        -: 9178:	double v0[3],v1[3],v2[3];
        -: 9179:	int k,l;
        -: 9180:	
       12: 9181:	memset(mmat,0,9*sizeof(double));
       12: 9182:	memset(rres,0,3*sizeof(double));
        -: 9183:	
        -: 9184:	
   331980: 9185:	for (i=0;i<RINGSIZE;i++) if (h[i]>0) {
        -: 9186:	    double vec[3];
   196385: 9187:	    ang2vec(th[i],ph[i],vec);
   196385: 9188:	    for (k=0;k<3;k++) for (l=0;l<3;l++) mmat[k+3*l]+=vec[k]*vec[l];
   196385: 9189:	    for (k=0;k<3;k++) rres[k]+=vec[k];
        -: 9190:	  }
        -: 9191:	
       12: 9192:	if (lusol(mmat,rres,3)==0) {
       12: 9193:	  for (k=0;k<3;k++) v2[k]=rres[k];
       12: 9194:	  double tmp=0;
       12: 9195:	  for (k=0;k<3;k++) tmp+=v2[k]*v2[k];
       12: 9196:	  for (k=0;k<3;k++) v2[k]/=sqrt(tmp);
       12: 9197:	  v1[0]=0;v1[1]=1;v1[2]=-v2[1]/v2[2];
       12: 9198:	  tmp=0;
       12: 9199:	  for (k=0;k<3;k++) tmp+=v1[k]*v1[k];
       12: 9200:	  for (k=0;k<3;k++) v1[k]/=sqrt(tmp);
       12: 9201:	  mmat[0]=v1[0];mmat[1]=v1[1];mmat[2]=v2[0];mmat[3]=v2[1];
       12: 9202:	  rres[0]=v1[2];rres[1]=v2[2];
       12: 9203:	  if (lusol(mmat,rres,2)!=0) {
    #####: 9204:	    fprintf(stderr,"%s %d %d\n",__FILE__,__LINE__,rank);
        -: 9205:	  }
       12: 9206:	  v0[0]=rres[0];v0[1]=rres[1];v0[2]=-1;
       12: 9207:	  tmp=0;
       12: 9208:	  for (k=0;k<3;k++) tmp+=v0[k]*v0[k];
       12: 9209:	  for (k=0;k<3;k++) v0[k]/=sqrt(tmp);
       12: 9210:	  double navr=0,avr=0,avr2=0;
        -: 9211:	  //fprintf(stderr,"PHASE v0 %ld %lf %lf %lf\n",(long) rg,v0[0],v0[1],v0[2]);
        -: 9212:	  //fprintf(stderr,"PHASE v1 %ld %lf %lf %lf\n",(long) rg,v1[0],v1[1],v1[2]);
        -: 9213:	  //fprintf(stderr,"PHASE v2 %ld %lf %lf %lf\n",(long) rg,v2[0],v2[1],v2[2]);
        -: 9214:	  
       12: 9215:	  PIOFLOAT vphase0=1E30;
       12: 9216:	  PIOINT iph0=0;
        -: 9217:	  
   331980: 9218:	  for (i=0;i<RINGSIZE;i++) if (h[i]>0) {
        -: 9219:	      double vec[3];
   196385: 9220:	      ang2vec(th[i],ph[i],vec);
   196385: 9221:	      double xx=vec[0]*v0[0]+vec[1]*v0[1]+vec[2]*v0[2];
   196385: 9222:	      double yy=vec[0]*v1[0]+vec[1]*v1[1]+vec[2]*v1[2];
   196385: 9223:	      if (Param->flag_phase!=_PAR_TRUE) {
    #####: 9224:		phase[i]=atan2(yy,xx);
        -: 9225:	      }
   196385: 9226:	      tmp=sqrt(xx*xx+yy*yy);
   196385: 9227:	      navr+=1;
   196385: 9228:	      avr+=tmp;
   196385: 9229:	      avr2+=tmp*tmp;
   589155: 9230:	      tmp=(vec[0]-(EPOLEX))*(vec[0]-(EPOLEX))+
   196385: 9231:		(vec[1]-(EPOLEY))*(vec[1]-(EPOLEY))+
   196385: 9232:		(vec[2]-(EPOLEZ))*(vec[2]-(EPOLEZ));
   196385: 9233:	      if (tmp<vphase0) {
     7689: 9234:		vphase0=tmp;
     7689: 9235:		iph0=i;
        -: 9236:	      } 
        -: 9237:	    }
        -: 9238:	    
       12: 9239:	  if (Param->flag_phase!=_PAR_TRUE) {
    #####: 9240:	    for (i=0;i<RINGSIZE;i++) phase[i]=fmod(phase[i]+3*M_PI-phase[iph0],2*M_PI);
        -: 9241:	    
        -: 9242:	    //if phase goes in the wrong direction invert the direction (warning 1-0~ 2M_Pi)
    #####: 9243:	    if (phase[1]<phase[0]||phase[2]<phase[1]) {
        -: 9244:	      // fmod to ensure [0,2*M_PI[ domain
    #####: 9245:	      for (i=0;i<RINGSIZE;i++) phase[i]=fmod(4*M_PI-phase[i],2*M_PI);
        -: 9246:	    }
        -: 9247:	  }
        -: 9248:
       12: 9249:	  long nrg_htmp = 0;
        -: 9250:
        -: 9251:	  //long off_adu=(32000/Param->REMDIP)*((rg-globalBeginRing)/stepadu);
        -: 9252:          //if (off_adu>=32000) off_adu=(32000/Param->REMDIP)*(Param->REMDIP-1);
        -: 9253:
        -: 9254:
        -: 9255:	  // BUILE TF IS NEEDED
       12: 9256:	  if (Param->BUILDTF>0) {
        -: 9257:	    double *bmat,*bvec;
        -: 9258:
    #####: 9259:	    bmat=(double *) malloc(Param->BUILDTF*Param->BUILDTF*4*sizeof(double));
    #####: 9260:	    bvec=(double *) malloc(Param->BUILDTF*2*sizeof(double));
        -: 9261:
    #####: 9262:	    memset(bmat,0,Param->BUILDTF*Param->BUILDTF*4*sizeof(double));
    #####: 9263:	    memset(bvec,0,Param->BUILDTF*2*sizeof(double));
        -: 9264:
    #####: 9265:	    for (i=0;i<RINGSIZE;i++) {
        -: 9266:	      long ipix;
    #####: 9267:	      if (h[i]>0) {
    #####: 9268:		ang2pix_ring( Nside, th[i], ph[i], &ipix);
    #####: 9269:		double co= cos(2*psi[i]);
    #####: 9270:		double si= sin(2*psi[i]);
    #####: 9271:		double model=diporb[i]+(skymodelI[ipix]+eta[ib]*co*skymodelQ[ipix]+eta[ib]*si*skymodelU[ipix]);
    #####: 9272:		for (j=0;j<Param->BUILDTF;j++) {
    #####: 9273:		  for (k=0;k<Param->BUILDTF;k++) {
    #####: 9274:		    bmat[2*j   + (2*k)*Param->BUILDTF*2  ] += cos(phase[i]*(j+1))*cos(phase[i]*(k+1));
    #####: 9275:		    bmat[2*j+1 + (2*k)*Param->BUILDTF*2  ] += sin(phase[i]*(j+1))*cos(phase[i]*(k+1));
    #####: 9276:		    bmat[2*j   + (2*k+1)*Param->BUILDTF*2] += cos(phase[i]*(j+1))*sin(phase[i]*(k+1));
    #####: 9277:		    bmat[2*j+1 + (2*k+1)*Param->BUILDTF*2] += sin(phase[i]*(j+1))*sin(phase[i]*(k+1));
        -: 9278:		  }
    #####: 9279:		  bvec[2*j  ]+=model*cos(phase[i]*(j+1));
    #####: 9280:		  bvec[2*j+1]+=model*sin(phase[i]*(j+1));
        -: 9281:		}
        -: 9282:	      }
        -: 9283:	    }
        -: 9284:
    #####: 9285:	    lusol(bmat,bvec,Param->BUILDTF*2);
        -: 9286:
    #####: 9287:	    for (i=0;i<RINGSIZE;i++) {
    #####: 9288:	      if (h[i]>0) {
    #####: 9289:		for (j=0;j<Param->BUILDTF;j++) {
    #####: 9290:		  theo[j*2][i]=bvec[2*j]*cos(phase[i]*(j+1))+bvec[2*j+1]*sin(phase[i]*(j+1));
    #####: 9291:		  theo[j*2+1][i]=-bvec[2*j]*sin(phase[i]*(j+1))+bvec[2*j+1]*cos(phase[i]*(j+1));
        -: 9292:		}
        -: 9293:	      }
        -: 9294:	    }
    #####: 9295:	    free(bmat);
    #####: 9296:	    free(bvec);
        -: 9297:	  }
        -: 9298:
   331980: 9299:          for (i=0;i<RINGSIZE;i++) if (h[i]>0) {
        -: 9300:            long ipix;
        -: 9301:            long ipix128;
        -: 9302:            long l_ipix128;
   196385: 9303:            nrg_htmp++;
        -: 9304:            double vecpix[3];
   196385: 9305:            ang2pix_ring( Nside, th[i], ph[i], &ipix);
   196385: 9306:            ang2pix_ring( nside128, th[i], ph[i], &ipix128); // Beware taht nside128 could be different from 128
   196385: 9307:            ang2pix_ring( 128, th[i], ph[i], &l_ipix128);
   196385: 9308:            int testmap=0;
   196385: 9309:            if (dustmapI!=NULL) {
   196385: 9310:              if (dustmapI[ipix128]>-1E10) testmap=1;
    #####: 9311:              else testmap=0;
        -: 9312:            }
    #####: 9313:            else testmap=1;
        -: 9314:
   196385: 9315:            if (testmap) {
   196385: 9316:              ang2vec(th[i], ph[i],vecpix);
        -: 9317:              hpix *tp_hpix;
        -: 9318:
   196385: 9319:              if (l_nhpix[ipix]==0) {
    86135: 9320:                l_hpix[ipix] = (hpix *) malloc(sizeof(hpix));
        -: 9321:              }
        -: 9322:              else {
   110250: 9323:                l_hpix[ipix] = (hpix *) realloc(l_hpix[ipix],(l_nhpix[ipix]+1)*sizeof(hpix));
        -: 9324:              }
   196385: 9325:              tp_hpix=l_hpix[ipix]+l_nhpix[ipix];
   392770: 9326:              for (int iter = 0; iter < number_of_iterations; iter++) {
   196385: 9327:                tp_hpix->listp[iter]=(y[iter][i]-Param->Monop[ib])/Param->Calibration[ib];
        -: 9328:              }
        -: 9329:
   196385: 9330:              tp_hpix->sig=tp_hpix->listp[0];
        -: 9331:
   196385: 9332:	      tp_hpix->phase=phase[i];
        -: 9333:
   196385: 9334:	      phase[i]=fmod(phase[i]+rg*M_PI/30.,2*M_PI);
        -: 9335:
        -: 9336:              //double soldip=SOLDIPX*vecpix[0]+SOLDIPY*vecpix[1]+SOLDIPZ*vecpix[2];
        -: 9337:              //tp_hpix->soldip = diporb[i];
   196385: 9338:              tp_hpix->dip    = diporb[i];
        -: 9339:              //tp_hpix->thsig  = diporb[i];
   196385: 9340:              tp_hpix->hit    = 1/sqrt(h[i]);
   196385: 9341:              if (fsl != NULL) {
   196385: 9342:                tp_hpix->fsl = fsl[i]*Param->FSLCOEF[ib];
        -: 9343:              } else {
    #####: 9344:                tp_hpix->fsl = 0.0;
        -: 9345:              }
        -: 9346:#if 0
        -: 9347:              tp_hpix->sig=ADU[i]/104978.;
        -: 9348:#endif
   196385: 9349:              tp_hpix->corr_nl = 0;
   196385: 9350:              tp_hpix->corr_cnn = 0;
   196385: 9351:	      tp_hpix->adu    = (PIOINT) (floor(ADU[i]));
   196385: 9352:              if (tp_hpix->adu+16000<0) tp_hpix->adu=-16000;
   196385: 9353:              if (tp_hpix->adu+16000>31999) tp_hpix->adu=15999;
   196385: 9354:              tp_hpix->adu=tp_hpix->adu+16000;
        -: 9355:	      // SADU should be driven by the badring information!!!
        -: 9356:              //tp_hpix->sadu=(rg-globalBeginRing)/((float)((globalEndRing+1) - globalBeginRing));
   196385: 9357:	      tp_hpix->sadu=((float) ibadring[rg-globalBeginRing])/rg_max;
        -: 9358:#if 0
        -: 9359:              tp_hpix->adu=(tp_hpix->adu+16000)/Param->REMDIP+off_adu;
        -: 9360:              if (tp_hpix->adu<=0||tp_hpix->adu>31999) {
        -: 9361:                fprintf(stderr,"ADUPROB %lg %lg %lg\n",ADU[i],(double) off_adu,diporb[i]);
        -: 9362:              }
        -: 9363:#endif
        -: 9364:
   196385: 9365:              tp_hpix->co= cos(2*psi[i]);
   196385: 9366:              tp_hpix->si= sin(2*psi[i]);
   196385: 9367:              for (j=0;j<npixbeam;j++) tp_hpix->listofpix[j]=theo[j][i]; //-diporb[i];
        -: 9368:
   196385: 9369:	      tp_hpix->model  =	diporb[i]+(skymodelI[ipix]+eta[ib]*tp_hpix->co*skymodelQ[ipix]+eta[ib]*tp_hpix->si*skymodelU[ipix]);
        -: 9370:
        -: 9371:
   196385: 9372:              tp_hpix->w=h[i]*sxi;
   196385: 9373:              if (comapI!=NULL) tp_hpix->comap=comapI[ipix128];
    #####: 9374:              else tp_hpix->comap=0;
        -: 9375:
        -: 9376:// extra theo tempaltes
        -: 9377:// ANGLE, POLEFF and CO13
        -: 9378:// the npixbeam is updated later
        -: 9379:// here npixbeam is the number of TF
        -: 9380:// npixbeam+1 ANGLE
        -: 9381:// npixbeam+2 POLEFF
        -: 9382:// npixbeam+3 TDUST
        -: 9383:// npixbeam+4 CO13
        -: 9384:// npixbeam+5 SYNCROTRON
   196385: 9385:             long moveindex=0;
   196385: 9386:             if (Param->FITANGLE==1) {
   196385: 9387:	       if (eta[ib]>1E-2) {
   589155: 9388:		 tp_hpix->listofpix[npixbeam]= eta[ib]*tp_hpix->co*inpolarU[ipix128]
   392770: 9389:		   -eta[ib]*tp_hpix->si*inpolarQ[ipix128];  // ANGLE
        -: 9390:	       }
        -: 9391:	       else {
    #####: 9392:		 tp_hpix->listofpix[npixbeam]= tp_hpix->co*inpolarU[ipix128]
    #####: 9393:		   -tp_hpix->si*inpolarQ[ipix128];  // ANGLE
        -: 9394:	       }
   196385: 9395:	       moveindex++;
        -: 9396:             }
   196385: 9397:             if (Param->FITPOLEFF==1) {
   196385: 9398:	       if (eta[ib]>1E-2) {
   589155: 9399:		 tp_hpix->listofpix[npixbeam+moveindex]= eta[ib]*tp_hpix->co*inpolarQ[ipix128]
   392770: 9400:		   +eta[ib]*tp_hpix->si*inpolarU[ipix128];  // POLAREFFICIENCY
        -: 9401:	       }
        -: 9402:	       else {
    #####: 9403:		 tp_hpix->listofpix[npixbeam+moveindex]= tp_hpix->co*inpolarQ[ipix128]
    #####: 9404:		   +tp_hpix->si*inpolarU[ipix128];  // POLAREFFICIENCY
        -: 9405:	       }
   196385: 9406:	       moveindex++;
        -: 9407:              }
   196385: 9408:             if (DOTDUST==1) {
    #####: 9409:                tp_hpix->listofpix[npixbeam+moveindex]= tdustmapQ[ipix128]+eta[ib]*tp_hpix->co*tdustmapQ[ipix128]
    #####: 9410:                  +eta[ib]*tp_hpix->si*tdustmapU[ipix128];  // TDUST (sed variation)
    #####: 9411:                moveindex++;
        -: 9412:              }
   196385: 9413:              if (comap13I!=NULL) {
   196385: 9414:                 tp_hpix->listofpix[npixbeam+moveindex]= comap13I[ipix128];  // CO13
   196385: 9415:		 moveindex++;
        -: 9416:              }
        -: 9417:
   196385: 9418:	      if (DOSYNCHRO==1) {
    #####: 9419:		tp_hpix->listofpix[npixbeam+moveindex]=
    #####: 9420:		  synchromodelI[ipix128]
    #####: 9421:		  +eta[ib]*tp_hpix->co*synchromodelQ[ipix128]
    #####: 9422:		  +eta[ib]*tp_hpix->si*synchromodelU[ipix128];
        -: 9423:	      }
        -: 9424:
   196385: 9425:              if (FREEFREE!=NULL) tp_hpix->freefree=(FREEFREE[ipix128]);
   196385: 9426:              else tp_hpix->freefree=0;
        -: 9427:
   392770: 9428:              if (dustmapI!=NULL) tp_hpix->dustmap=(dustmapI[ipix128]
   196385: 9429:                                                    +eta[ib]*tp_hpix->co*dustmapQ[ipix128]
   196385: 9430:                                                    +eta[ib]*tp_hpix->si*dustmapU[ipix128]);
    #####: 9431:              else tp_hpix->dustmap=0;
   392770: 9432:              if (dustmapI!=NULL) tp_hpix->pdustmap=eta[ib]*(tp_hpix->co*dustmapQ[ipix128]
   196385: 9433:							     +tp_hpix->si*dustmapU[ipix128]);
    #####: 9434:              else tp_hpix->pdustmap=0;
        -: 9435:
        -: 9436:#if 1
   196385: 9437:              if (dustmapI!=NULL&&Param->OUT_NOPOL[0]%2==1) {
   196385: 9438:                if (nbolo==1) {
    #####: 9439:                  tp_hpix->dustmap =tp_hpix->co*comapI[ipix128]+tp_hpix->si*dustmapI[ipix128];
    #####: 9440:                  tp_hpix->comap   =-tp_hpix->si*comapI[ipix128]+tp_hpix->co*dustmapI[ipix128];
        -: 9441:                }
   196385: 9442:                if (dustmapI!=NULL&&(Param->OUT_NOPOL[0]/2)%2==1) {
    #####: 9443:                  tp_hpix->listofpix[npixbeam]=tp_hpix->co*dustmapQ[ipix128]+tp_hpix->si*dustmapU[ipix128];
        -: 9444:                }
        -: 9445:              }
        -: 9446:
        -: 9447:#endif
        -: 9448:
        -: 9449:#if 0
        -: 9450:	      //JMD ????
        -: 9451:              if (simdustmapQ!=NULL) tp_hpix->sig+=(eta[ib]*tp_hpix->co*simdustmapQ[ipix]
        -: 9452:                                                    +eta[ib]*tp_hpix->si*simdustmapU[ipix])*0.0007;
        -: 9453:#endif
        -: 9454:
   196385: 9455:	      if (Param->n_ADDCO13>0) {
    #####: 9456:		for (int iter = 0; iter < number_of_iterations; iter++) {
    #####: 9457:		  tp_hpix->listp[iter]+=Param->ADDCO13[ib]*comap13I[ipix128];
        -: 9458:		}
        -: 9459:	      }
        -: 9460:	      
   196385: 9461:	      if (addpol!=NULL) {
    #####: 9462:		for (int iter = 0; iter < number_of_iterations; iter++) {
    #####: 9463:		  tp_hpix->listp[iter]+=eta[ib]*(tp_hpix->co*addpol[2*l_ipix128]+tp_hpix->si*addpol[2*l_ipix128+1]);
        -: 9464:		}
        -: 9465:	      }
        -: 9466:
   196385: 9467:              tp_hpix->surv = surv;
   196385: 9468:              tp_hpix->ib = ib;
   196385: 9469:              tp_hpix->rg = rg;
        -: 9470:#if GAIN_RATIO
        -: 9471:              if (gain_ratio_off[ib][rg]>10000000) {
        -: 9472:                tp_hpix->gi = gain_ratio_off[ib][rg];
        -: 9473:                //tp_hpix->ggi = gain_ratio[ib][rg];
        -: 9474:              }
        -: 9475:              else {
        -: 9476:              }
        -: 9477:#endif
        -: 9478:#define NBPH (4096)
   196385: 9479:              tp_hpix->gi = rg;
        -: 9480:              //tp_hpix->ggi = 1.;
   196385: 9481:              tp_hpix->hrg = (phase[i]*NBPH)/(2*M_PI);
        -: 9482:              //tp_hpix->xrg = (double) (rg-240)/25000.;
   196385: 9483:              tp_hpix->ipix = ipix;
   196385: 9484:              l_nhpix[ipix]+=1;
   196385: 9485:              if (isnan(tp_hpix->sig)||isnan(tp_hpix->w)||isnan(tp_hpix->dip)) {
    #####: 9486:                fprintf(stderr,"NAN NAN NAN %lf %lf %lf %ld %ld\n",tp_hpix->dip,tp_hpix->sig,tp_hpix->w,(long)rg,(long)i);
        -: 9487:              }
   196385: 9488:              if (Param->TESTPOL==3) {
        -: 9489://                double xxx=((tp_hpix->adu-off_adu)-16000/Param->REMDIP)*Param->REMDIP/1000.;
        -: 9490://                tp_hpix->sig  = (0.99+0.001*tp_hpix->ib)*(tp_hpix->dip+tp_hpix->fsl) + 1E-5*exp(-xxx*xxx);
        -: 9491:              }
        -: 9492:
        -: 9493:            }
        -: 9494:	    }
        -: 9495:
        -: 9496:
        -: 9497:
        -: 9498:
       12: 9499:          if ((rank==0) && (rg==globalRankInfo.BeginRing[rank]) ) {
    #####: 9500:            GetProcMem(&vmem,&phymem);
    #####: 9501:            if (Param->TESTPOL==0) {
    #####: 9502:              fprintf(stderr,"Com %s Rank: %ld[%d] MEM %.1lf[%.1lf]MB Nd=%ld %lg %lg [%lg,%lg,%lg,%lg]\n",
        -: 9503:		      Command, (long) rank, getpid(),
    #####: 9504:		      (double) vmem/1024./1024.,
    #####: 9505:		      (double) phymem/1024./1024.,
        -: 9506:		      (long) nrg_htmp,
    #####: 9507:		      avr/navr,sqrt(avr2/navr-(avr/navr)*(avr/navr)),
    #####: 9508:		      Param->Calibration[nbolo+ib*4],Param->Calibration[nbolo+ib*4+1],
    #####: 9509:		      Param->Calibration[nbolo+ib*4+2],Param->Calibration[nbolo+ib*4+3]);
        -: 9510:            }
        -: 9511:            else {
    #####: 9512:              fprintf(stderr,"Com %s Rank: %ld[%d] MEM %.1lf[%.1lf]MB Nd=%ld  %lg %lg \n",
        -: 9513:		      Command, (long) rank, getpid(),
    #####: 9514:		      (double) vmem/1024./1024.,
    #####: 9515:		      (double) phymem/1024./1024.,
        -: 9516:		      (long) nrg_htmp,
    #####: 9517:		      avr/navr,sqrt(avr2/navr-(avr/navr)*(avr/navr)));
        -: 9518:            }
        -: 9519:          }
        -: 9520:        }
        -: 9521:
       12: 9522:        free(h);
       12: 9523:        if (Param->flag_stim_paramfiles == 0) {
       12: 9524:          free(y[0]);
        -: 9525:        }
       12: 9526:        free(fsl);
       12: 9527:        free(diporb);
       12: 9528:        for (i=0;i<npixbeam;i++) free(theo[i]);
       12: 9529:        free(phase);
       12: 9530:        free(th);
       12: 9531:        free(ph);
       12: 9532:        free(psi);
       12: 9533:        free(ADU);
        -: 9534:      } // if not badring
        -: 9535:    } // end ring loop
        -: 9536:
       16: 9537:    if (Param->TESTPOL==0) {
    #####: 9538:      free(tfnoise);
        -: 9539:    }
        -: 9540:
       16: 9541:    if (Param->flag_stim_paramfiles == 1) {
    #####: 9542:      for (int iter = 0; iter < number_of_iterations; iter++) {
    #####: 9543:        free( stim_hpr[iter]);
        -: 9544:      }
        -: 9545:    }
        -: 9546:
       16: 9547:    if (rank==0) {
        4: 9548:      GetProcMem(&vmem,&phymem);
       12: 9549:      fprintf(stderr,"\nafter troll bolometer %s (%ld/%ld): used VMEM %.1lf[PHYS %.1lf]MB\n",
       12: 9550:          pixnames[ib], ib, nbolo-1, (double) vmem/1024./1024., (double) phymem/1024./1024.);
        -: 9551:    }
        -: 9552:
        -: 9553:  } // end bolometer loop
        -: 9554:
        4: 9555:  fftw_free(in_fft);
        4: 9556:  fftw_free(out_fft);
        -: 9557:
        4: 9558:  if (Param->flag_ADDPOL==_PAR_TRUE) {
    #####: 9559:    free(addpol);
        -: 9560:  }
        4: 9561:  if (skymodelI!=NULL) {
        4: 9562:    free(skymodelI);
        4: 9563:    free(skymodelQ);
        4: 9564:    free(skymodelU);
        -: 9565:  }
        4: 9566:  if (inpolarQ!=NULL) {
        4: 9567:    free(inpolarQ);
        4: 9568:    free(inpolarU);
        -: 9569:  }
        4: 9570:  if (comapI!=NULL) {
        4: 9571:    free(comapI);
        -: 9572:  }
        4: 9573:  if (FREEFREE!=NULL) {
    #####: 9574:    free(FREEFREE);
        -: 9575:  }
        4: 9576:  if (dustmapI!=NULL) {
        4: 9577:    free(dustmapI);
        4: 9578:    free(dustmapQ);
        4: 9579:    free(dustmapU);
        -: 9580:  }
        4: 9581:  if (Param->FITANGLE==1) {
        4: 9582:    if (rank==0) fprintf(stderr,"FITANGLE\n");
        4: 9583:    npixbeam+=1;
        4: 9584:    DOFITANGLE=1;
        -: 9585:  }
        4: 9586:  if (Param->FITPOLEFF==1) {
        4: 9587:    if (rank==0) fprintf(stderr,"FITPOL\n");
        4: 9588:    npixbeam+=1;
        4: 9589:    DOFITPOLEFF=1;
        -: 9590:  }
        -: 9591:
        4: 9592:  if (DOTDUST==1) {
    #####: 9593:    if (rank==0) fprintf(stderr,"DTDUST\n");
    #####: 9594:    free(tdustmapI);
    #####: 9595:    free(tdustmapQ);
    #####: 9596:    free(tdustmapU);
    #####: 9597:    npixbeam+=1;
        -: 9598:  }
        -: 9599:
        4: 9600:  if (comap13I!=NULL) {
        4: 9601:    if (rank==0) fprintf(stderr,"13CO\n");
        4: 9602:    npixbeam+=1;
        4: 9603:    DOCO13=1;
        -: 9604:  }
        -: 9605:
        4: 9606:  if (DOSYNCHRO==1) {
    #####: 9607:    if (rank==0) fprintf(stderr,"SYNCHRO\n");
    #####: 9608:    free(synchromodelI);
    #####: 9609:    free(synchromodelQ);
    #####: 9610:    free(synchromodelU);
    #####: 9611:    npixbeam+=1;
        -: 9612:  }
        -: 9613:
        4: 9614:  PrintFreeMemOnNodes( rank, mpi_size, "before pixel balancing");
        -: 9615:
        4: 9616:  if ((Param->OUT_NOPOL[0]/2)%2==1) npixbeam++;
        4: 9617:  if (rank==0) fprintf(stderr,"NPIX %d\n",(int) npixbeam);
        -: 9618:  /*======================================================
        -: 9619:    =
        -: 9620:    =      compute load balancing between proc
        -: 9621:    =
        -: 9622:    =*/
        -: 9623:
        4: 9624:  long *begpix = (long *) malloc(sizeof(long)*mpi_size);
        4: 9625:  long *edpix = (long *) malloc(sizeof(long)*mpi_size);
        -: 9626:#ifndef OPTIPIX
        -: 9627:  long maxitt = 0;
        -: 9628:#endif
        -: 9629:  long rrk;
        -: 9630:
        -: 9631:  PIOINT *mask;
        -: 9632:
        -: 9633:#ifdef OPTIPIX
        4: 9634:  if (Param->flag_Mask==_PAR_TRUE) {
        -: 9635:    PIOSTRING commask;
        4: 9636:    sprintf(commask,"begin=0;end=%lld",(long long) 12*Nside*Nside);
        4: 9637:    mask = (PIOINT *) malloc(sizeof(PIOINT)*(12*Nside*Nside));
        4: 9638:    long resmask=(long) noDMC_readObject_PIOINT(Param->Mask,0,12*Nside*Nside,mask);
        4: 9639:    if (rank==0) fprintf(stderr,"Mask %ld\n",(long) resmask);
        -: 9640:  }
        -: 9641:  else {
    #####: 9642:    mask = (PIOINT *) _PIOMALLOC(sizeof(PIOINT)*12*Nside*Nside);
    #####: 9643:    memset(mask,1,sizeof(PIOINT)*nnbpix);
        -: 9644:  }
        -: 9645:
        4: 9646:  if (rank==0) fprintf(stderr,"Sort pixel to make it run faster\n");
        4: 9647:  nnbpix=12*Nside*Nside/mpi_size;
       20: 9648:  for (i=0;i<mpi_size;i++) {
       16: 9649:    begpix[i]=i*nnbpix;
       16: 9650:    edpix[i]=(i+1)*nnbpix-1;
        -: 9651:  }
        4: 9652:  int *stat_pix = (int *) malloc( 2*12*Nside*Nside*sizeof(int));
        4: 9653:  memset(stat_pix,0,2*12*Nside*Nside*sizeof(int));
        4: 9654:  realpix = (int *) malloc(sizeof(int)*nnbpix);
        4: 9655:  irealpix = (int *) malloc(sizeof(int)*nnbpix);
        4: 9656:  int *newmask = (int *) malloc(sizeof(int)*nnbpix);
        -: 9657:  //int *inv_stat_pix;
        -: 9658:  {
        4: 9659:    long l_nr=12*Nside*Nside;
201326596: 9660:    for (i=0;i<l_nr;i++) {
201326592: 9661:      stat_pix[i]=l_nhpix[i];
        -: 9662:    }
        -: 9663:
        -: 9664:#ifdef OPTIMPI
        -: 9665:    {
        4: 9666:      int *l_stat_pix = (int *) malloc(12*Nside*Nside*sizeof(int));
        4: 9667:      MPI_Reduce(stat_pix,l_stat_pix,12*Nside*Nside,MPI_INT,MPI_SUM,0,MPI_COMM_WORLD);
        -: 9668:
        4: 9669:      memcpy(stat_pix,l_stat_pix,12*Nside*Nside*sizeof(int));
        4: 9670:      free(l_stat_pix);
        -: 9671:    }
        -: 9672:#endif
        -: 9673:
        4: 9674:    if (rank==0) {
        -: 9675:#ifndef OPTIMPI
        -: 9676:      MPI_Status statu;
        -: 9677:      int *l_stat_pix = (int *) malloc(12*Nside*Nside*sizeof(int));
        -: 9678:      for (rrk=1;rrk<mpi_size;rrk++) {
        -: 9679:        MPI_Recv(l_stat_pix,sizeof(int)*12*Nside*Nside, MPI_BYTE, rrk,31, MPI_COMM_WORLD,&statu);
        -: 9680:        for (j=0;j<12*Nside*Nside;j++) stat_pix[j]+=l_stat_pix[j];
        -: 9681:      }
        -: 9682:      free(l_stat_pix);
        -: 9683:#endif
        1: 9684:      fprintf(stderr,"regrid\n");
        1: 9685:      hpint *statp = (hpint *) malloc(12*Nside*Nside*sizeof(hpint));
        -: 9686:
 50331649: 9687:      for (j=0;j<12*Nside*Nside;j++) {
 50331648: 9688:	statp[j].ipx=j;
 50331648: 9689:	statp[j].hit=stat_pix[j]*mask[j];
        -: 9690:      }
        -: 9691:
        1: 9692:      fprintf(stderr,"sort\n");
        1: 9693:      qsort(statp,12*Nside*Nside,sizeof(hpint),compar_int);
        -: 9694:
        5: 9695:      for (rrk=0;rrk<mpi_size;rrk++) {
 12582916: 9696:	for (i=0;i<nnbpix/4;i++) {
        -: 9697:
 12582912: 9698:	  stat_pix[i           +(mpi_size-1-rrk)*nnbpix] = statp[i*mpi_size*4+rrk].ipx;
 12582912: 9699:	  stat_pix[i+nnbpix/4  +(mpi_size-1-rrk)*nnbpix] = statp[i*mpi_size*4+2*mpi_size-1-rrk].ipx;
 12582912: 9700:	  stat_pix[i+nnbpix/2  +rrk*nnbpix]              = statp[i*mpi_size*4+2*mpi_size+rrk].ipx;
 12582912: 9701:	  stat_pix[i+3*nnbpix/4+rrk*nnbpix]              = statp[i*mpi_size*4+2*mpi_size+2*mpi_size-1-rrk].ipx;
        -: 9702:
        -: 9703:#if 0
        -: 9704:	  if (i==0) fprintf(stderr,"%d %d %d %d %d %d\n",(int) (mpi_size-1-rrk),
        -: 9705:			    statp[i*mpi_size*2+rrk].hit,statp[i*mpi_size*2+2*mpi_size-1-rrk].hit,
        -: 9706:			    (int) rrk,
        -: 9707:			    statp[i*mpi_size*4+2*mpi_size+rrk].ipx,statp[i*mpi_size*4+2*mpi_size+2*mpi_size-1-rrk].ipx);
        -: 9708:#endif
 12582912: 9709:	  stat_pix[12*Nside*Nside+statp[i*mpi_size*4+rrk].ipx]=(mpi_size-1-rrk);
 12582912: 9710:	  stat_pix[12*Nside*Nside+statp[i*mpi_size*4+2*mpi_size-1-rrk].ipx]=(mpi_size-1-rrk);
 12582912: 9711:	  stat_pix[12*Nside*Nside+statp[i*mpi_size*4+2*mpi_size+rrk].ipx]=rrk;
 12582912: 9712:	  stat_pix[12*Nside*Nside+statp[i*mpi_size*4+2*mpi_size+2*mpi_size-1-rrk].ipx]=rrk;
        -: 9713:	}
        -: 9714:      }
        1: 9715:      free(statp);
        -: 9716:#if 0
        -: 9717:      FILE *fp=fopen("statpix.dat","w");
        -: 9718:      fwrite(stat_pix,sizeof(int)*12*Nside*Nside,1,fp);
        -: 9719:      fclose(fp);
        -: 9720:#endif
        -: 9721:    }
        -: 9722:#ifndef OPTIMPI
        -: 9723:    else  {
        -: 9724:      MPI_Send(stat_pix, sizeof(int)*12*Nside*Nside, MPI_BYTE, 0, 31, MPI_COMM_WORLD);
        -: 9725:    }
        -: 9726:#endif
        -: 9727:    // NOT A BCAST TO BE CHANGED TO MPI_SCATTER FOR OPTIMALITY
        4: 9728:    MPI_Bcast(stat_pix,sizeof(int)*12*Nside*Nside*2, MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 9729:
        4: 9730:    for (i=0;i<nnbpix;i++) realpix[i]=stat_pix[i+rank*nnbpix];
        4: 9731:    for (i=0;i<nnbpix;i++) irealpix[i]=stat_pix[12*Nside*Nside+i+rank*nnbpix];
        4: 9732:    for (i=0;i<nnbpix;i++) newmask[i]=mask[realpix[i]];
        -: 9733:  }
        4: 9734:  free(mask);
        4: 9735:  mask=newmask;
        -: 9736:  // AND NOW IN FRONT OF YOUR EYES MIX PIXELS TO GET THEM EFFICIENTLY COMPUTED!!!
        -: 9737:#if 1
        -: 9738:
        4: 9739:  if (rank==0) fprintf(stderr,"rebin pixel\n");
        4: 9740:  hpix **new_hpix = (hpix **) malloc(sizeof(hpix *)*12*Nside*Nside);
        4: 9741:  long l_nr=12*Nside*Nside;
201326596: 9742:  for (i=0;i<l_nr;i++) {
201326592: 9743:    new_hpix[i]=l_hpix[stat_pix[i]];
201326592: 9744:    if (l_nhpix[stat_pix[i]]>0) {
   282520: 9745:      for (j=0;j<l_nhpix[stat_pix[i]];j++) {
   196385: 9746:	new_hpix[i][j].ipix=i;
        -: 9747:      }
        -: 9748:    }
        -: 9749:    //new_hpix[i]=l_hpix[i];
        -: 9750:  }
        4: 9751:  free(l_hpix);
        4: 9752:  l_hpix=new_hpix;
        -: 9753:
        4: 9754:  PIOLONG *new_nhpix = (PIOLONG *) malloc(sizeof(PIOLONG)*12*Nside*Nside);
        -: 9755:
201326596: 9756:  for (i=0;i<l_nr;i++) {
        -: 9757:    //new_nhpix[i]=l_nhpix[i];
201326592: 9758:    new_nhpix[i]=l_nhpix[stat_pix[i]];
        -: 9759:  }
        4: 9760:  free(l_nhpix);
        4: 9761:  l_nhpix=new_nhpix;
        -: 9762:#endif
        4: 9763:  free(stat_pix);
        -: 9764:
        4: 9765:  GetProcMem(&vmem,&phymem);
        6: 9766:  if (rank==0) fprintf(stderr,"Rank: %ld[%d] MEM %.1lf[%.1lf]MB line=%d\n",
        -: 9767:              (long) rank, getpid(),
        1: 9768:              (double) vmem/1024./1024.,
        1: 9769:              (double) phymem/1024./1024.,__LINE__);
        4: 9770:  MPI_Barrier(MPI_COMM_WORLD);
        -: 9771:
        -: 9772:#else
        -: 9773:  double *stat_pix = (double *) malloc( 12*Nside*Nside*sizeof(double));
        -: 9774:  memset(stat_pix,0,12*Nside*Nside*sizeof(double));
        -: 9775:  //int *inv_stat_pix;
        -: 9776:  {
        -: 9777:    long l_nr=12*Nside*Nside;
        -: 9778:    for (i=0;i<l_nr;i++) {
        -: 9779:      stat_pix[i]=l_nhpix[i];
        -: 9780:    }
        -: 9781:
        -: 9782:
        -: 9783:    if (rank==0) {
        -: 9784:      MPI_Status statu;
        -: 9785:      double *l_stat_pix = (double *) malloc(12*Nside*Nside*sizeof(double));
        -: 9786:      for (rrk=1;rrk<mpi_size;rrk++) {
        -: 9787:        MPI_Recv(l_stat_pix,sizeof(double)*12*Nside*Nside, MPI_BYTE, rrk,31, MPI_COMM_WORLD,&statu);
        -: 9788:        for (j=0;j<12*Nside*Nside;j++) stat_pix[j]+=l_stat_pix[j];
        -: 9789:      }
        -: 9790:      free(l_stat_pix);
        -: 9791:      nmatpix=0;
        -: 9792:      for (j=0;j<12*Nside*Nside;j++) {
        -: 9793:        if (stat_pix[j]>0) {
        -: 9794:          nmatpix++;
        -: 9795:        }
        -: 9796:      }
        -: 9797:      stat_pix[0]=stat_pix[0];
        -: 9798:      maxitt=stat_pix[0];
        -: 9799:      for (j=1;j<12*Nside*Nside;j++) {
        -: 9800:        if (maxitt<stat_pix[j]) maxitt=stat_pix[j];
        -: 9801:        stat_pix[j]=stat_pix[j]+stat_pix[j-1];
        -: 9802:
        -: 9803:      }
        -: 9804:      double step_pix=stat_pix[12*Nside*Nside-1]/mpi_size;
        -: 9805:      fprintf(stderr,"step_pix=%lf\n",step_pix);
        -: 9806:      int k=1;
        -: 9807:      begpix[0]=0;
        -: 9808:      for (j=1;j<12*Nside*Nside;j++) {
        -: 9809:        if (k*step_pix<stat_pix[j]) {
        -: 9810:          edpix[k-1]=j-1;
        -: 9811:          begpix[k]=j;
        -: 9812:          k++;
        -: 9813:        }
        -: 9814:      }
        -: 9815:      edpix[mpi_size-1]=12*Nside*Nside-1;
        -: 9816:      if (Param->verbose > 0) {
        -: 9817:        for (j=0;j<mpi_size;j++) {
        -: 9818:          fprintf(stderr,"rank=%ld begpix=%ld endpix=%ld npix=%ld %lg\n",j,begpix[j],edpix[j],edpix[j]-begpix[j],stat_pix[edpix[j]]-stat_pix[begpix[j]]);
        -: 9819:        }
        -: 9820:      }
        -: 9821:    }
        -: 9822:    else  {
        -: 9823:      MPI_Send(stat_pix, sizeof(double)*12*Nside*Nside, MPI_BYTE, 0, 31, MPI_COMM_WORLD);
        -: 9824:    }
        -: 9825:    MPI_Bcast(begpix,sizeof(long)*mpi_size, MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 9826:    MPI_Bcast(edpix,sizeof(long)*mpi_size, MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 9827:    MPI_Bcast(&maxitt,sizeof(long), MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 9828:    MPI_Bcast(&nmatpix,sizeof(long),MPI_BYTE, 0, MPI_COMM_WORLD);
        -: 9829:  }
        -: 9830:  free(stat_pix);
        -: 9831:
        -: 9832:  if (Param->flag_Mask==_PAR_TRUE) {
        -: 9833:    PIOSTRING commask;
        -: 9834:    sprintf(commask,"begin=%lld;end=%lld",(long long) begpix[rank],(long long) edpix[rank]);
        -: 9835:    mask = (PIOINT *) malloc(sizeof(PIOINT)*(edpix[rank]-begpix[rank]+1));
        -: 9836:    long resmask=(long) noDMC_readObject_PIOINT(Param->Mask,begpix[rank],edpix[rank]-begpix[rank]+1,mask);
        -: 9837:    if (rank==0) fprintf(stderr,"Mask %ld\n",(long) resmask);
        -: 9838:  }
        -: 9839:  else {
        -: 9840:    mask = (PIOINT *) _PIOMALLOC(sizeof(PIOINT)*nnbpix);
        -: 9841:    memset(mask,1,sizeof(PIOINT)*nnbpix);
        -: 9842:  }
        -: 9843:#endif
        -: 9844:
        4: 9845:  GetProcMem(&vmem,&phymem);
        6: 9846:  if (rank==0) fprintf(stderr,"Rank: %ld[%d] MEM %.1lf[%.1lf]MB line=%d\n",
        -: 9847:              (long) rank, getpid(),
        1: 9848:              (double) vmem/1024./1024.,
        1: 9849:              (double) phymem/1024./1024.,__LINE__);
        4: 9850:  MPI_Barrier(MPI_COMM_WORLD);
        -: 9851:
        -: 9852:  /*======================================================
        -: 9853:    =
        -: 9854:    =      order data per pixel and per proc
        -: 9855:    =
        -: 9856:    =*/
        -: 9857:
        4: 9858:  nnbpix = edpix[rank]-begpix[rank]+1;
        -: 9859:
        4: 9860:  loc_hpix = (hpix **) malloc(sizeof(hpix *)*nnbpix);
        4: 9861:  loc_nhpix = (PIOLONG *) malloc(sizeof(PIOLONG)*nnbpix);
        4: 9862:  memset(loc_nhpix,0,sizeof(PIOLONG)*nnbpix);
        -: 9863:
        4: 9864:  MPI_Barrier(MPI_COMM_WORLD);
        -: 9865:
        -: 9866:#if 0
        -: 9867:  long ndata=0;
        -: 9868:  for (rrk=0;rrk<mpi_size;rrk++) {
        -: 9869:    MPI_Status statu;
        -: 9870:    PIOLONG l_nsamp;
        -: 9871:    if (rrk==rank) {
        -: 9872:      int rk2;
        -: 9873:      memcpy(loc_nhpix,l_nhpix+begpix[rank],sizeof(long)*(nnbpix));
        -: 9874:      for (j=0;j<nnbpix;j++) loc_hpix[j]=l_hpix[j+begpix[rank]];
        -: 9875:      for (rk2=0;rk2<mpi_size;rk2++) {
        -: 9876:        hpix *tbs;
        -: 9877:        long ntbs=0,k;
        -: 9878:        if (rk2!=rrk) {
        -: 9879:          MPI_Recv(&ntbs,sizeof(long), MPI_BYTE, rk2,450, MPI_COMM_WORLD,&statu);
        -: 9880:
        -: 9881:          GetProcMem(&vmem,&phymem);
        -: 9882:          if (rank==0) fprintf(stderr,"Rank: %ld[%d] MEM %.1lf[%.1lf]MB line=%d %ld\n",
        -: 9883:                  (long) rank, rk2,
        -: 9884:                  (double) vmem/1024./1024.,
        -: 9885:                  (double) phymem/1024./1024.,__LINE__,ntbs);
        -: 9886:          if (ntbs>0) {
        -: 9887:            tbs=(hpix *) malloc(sizeof(hpix)*(ntbs));
        -: 9888:            MPI_Recv(tbs,sizeof(hpix)*ntbs, MPI_BYTE, rk2,451, MPI_COMM_WORLD,&statu);
        -: 9889:
        -: 9890:            for (k=0;k<ntbs;k++) {
        -: 9891:              j=tbs[k].ipix-begpix[rrk];
        -: 9892:              if (loc_nhpix[j]==0) {
        -: 9893:                loc_hpix[j] = (hpix *) malloc(sizeof(hpix));
        -: 9894:              }
        -: 9895:              else {
        -: 9896:                loc_hpix[j] = (hpix *) realloc(loc_hpix[j],(1+loc_nhpix[j])*sizeof(hpix));
        -: 9897:              }
        -: 9898:              memcpy(loc_hpix[j]+loc_nhpix[j],tbs+k,sizeof(hpix));
        -: 9899:              loc_nhpix[j] +=1;
        -: 9900:            }
        -: 9901:
        -: 9902:            free(tbs);
        -: 9903:          }
        -: 9904:        }
        -: 9905:      }
        -: 9906:    }
        -: 9907:    else {
        -: 9908:      hpix *tbs;
        -: 9909:      long ntbs=0;
        -: 9910:      for (j=begpix[rrk];j<=edpix[rrk];j++) if (l_nhpix[j]>0) {
        -: 9911:        if (ntbs==0) {
        -: 9912:          tbs=(hpix *) malloc(sizeof(hpix)*(l_nhpix[j]));
        -: 9913:        }
        -: 9914:        else {
        -: 9915:          tbs=(hpix *) realloc(tbs,sizeof(hpix)*(ntbs+l_nhpix[j]));
        -: 9916:        }
        -: 9917:
        -: 9918:        memcpy(tbs+ntbs,l_hpix[j], sizeof(hpix)*(l_nhpix[j]));
        -: 9919:        free(l_hpix[j]);
        -: 9920:        ntbs+=l_nhpix[j];
        -: 9921:      }
        -: 9922:      MPI_Send(&ntbs, sizeof(long), MPI_BYTE, rrk, 450, MPI_COMM_WORLD);
        -: 9923:      if (ntbs>0) {
        -: 9924:        MPI_Send(tbs, sizeof(hpix)*(ntbs), MPI_BYTE, rrk, 451, MPI_COMM_WORLD);
        -: 9925:        free(tbs);
        -: 9926:      }
        -: 9927:    }
        -: 9928:  }
        -: 9929:#else
        -: 9930:
        -: 9931:  //========================================================================
        -: 9932:  // USE iterative approach to avoid slow down while exchanging data
        4: 9933:  long nstep=log((double)(mpi_size))/log(2.0)+0.001;
        4: 9934:  long exch=1;
        -: 9935:  int is,js;
       12: 9936:  for (is=0;is<nstep;is++) {
        -: 9937:    MPI_Status statu;
        8: 9938:    exch*=2;
       20: 9939:    for (js=0;js<mpi_size;js+=exch) {
       12: 9940:      long rk0=exch*((long)(rank/exch));
        -: 9941:      int k;
       44: 9942:      for (k=0;k<exch;k++) {
       32: 9943:        if (rank%exch==k) {
        -: 9944:          hpix *tbs;
       12: 9945:          long ntbs=0,kk;
        -: 9946:          //fprintf (stderr,"%d <- %d\n",(int)rank,(int)(rk0+(k+exch/2)%(exch)));
       12: 9947:          MPI_Recv(&ntbs,sizeof(long), MPI_BYTE,rk0+(k+exch/2)%(exch),450, MPI_COMM_WORLD,&statu);
        -: 9948:
       12: 9949:          if (rank==0) {
        3: 9950:            GetProcMem( &vmem, &phymem);
       15: 9951:            fprintf(stderr,"Rank: %d(%s, free=%.2fGB) [%d/%d] used MEM virt:%.1lf[phys:%.1lf]MB line=%d ntbs:%ldMB\n",
        6: 9952:                  rank, hostname, GetFreeMemGB(), (int) (rk0+(k+exch/2)%(exch)),(int) exch,
        3: 9953:                  (double) vmem/1024./1024.,
        6: 9954:                  (double) phymem/1024./1024.,__LINE__,sizeof(hpix)*ntbs/1024/1024);
        -: 9955:          }
       12: 9956:          if (ntbs>0) {
       10: 9957:            tbs=(hpix *) malloc(sizeof(hpix)*(ntbs));
       10: 9958:            if (tbs == NULL) {
    #####: 9959:              GetProcMem( &vmem, &phymem);
    #####: 9960:              fprintf(stderr,"Rank: %d(%s, free=%.2fGB) [%d/%d] used MEM virt:%.1lf[phys:%.1lf]MB line=%d ntbs:%ldMB\n",
    #####: 9961:                    rank, hostname, GetFreeMemGB(), (int) (rk0+(k+exch/2)%(exch)),(int) exch,
    #####: 9962:                    (double) vmem/1024./1024.,
    #####: 9963:                    (double) phymem/1024./1024.,__LINE__,sizeof(hpix)*ntbs/1024/1024);
    #####: 9964:              sleep(10); // wait for other ranks to fail allocation and display error message
    #####: 9965:              return 1;
        -: 9966:            }
       10: 9967:            MPI_Recv(tbs,sizeof(hpix)*ntbs, MPI_BYTE, rk0+(k+exch/2)%(exch),451, MPI_COMM_WORLD,&statu);
        -: 9968:
   196155: 9969:            for (kk=0;kk<ntbs;kk++) {
   196145: 9970:              j=tbs[kk].ipix;
   196145: 9971:              if (l_nhpix[j]==0) {
    85996: 9972:                l_hpix[j] = (hpix *) malloc(sizeof(hpix));
        -: 9973:              }
        -: 9974:              else {
   110149: 9975:                l_hpix[j] = (hpix *) realloc(l_hpix[j],(1+l_nhpix[j])*sizeof(hpix));
        -: 9976:              }
   196145: 9977:              memcpy(l_hpix[j]+l_nhpix[j],tbs+kk,sizeof(hpix));
   196145: 9978:              l_nhpix[j] +=1;
        -: 9979:            }
        -: 9980:
       10: 9981:            free(tbs);
        -: 9982:          }
        -: 9983:        }
       32: 9984:        if ((rank+exch/2)%exch==k) {
       12: 9985:          hpix *tbs=NULL;
       12: 9986:          long ntbs=0;
150994956: 9987:          for (j=begpix[js+k];j<=edpix[js+k];j++){
150994944: 9988:	    if (l_nhpix[j]>0) {
    86049: 9989:	      if (ntbs==0) {
       10: 9990:		tbs=(hpix *) malloc(sizeof(hpix)*(l_nhpix[j]));
       10: 9991:		if (tbs == NULL) {
    #####: 9992:		  GetProcMem( &vmem, &phymem);
    #####: 9993:		  fprintf(stderr,"Rank: %d(%s, free=%.2fGB) [%d/%d] used MEM virt:%.1lf[phys:%.1lf]MB line=%d ntbs:%ldMB\n",
    #####: 9994:			  rank, hostname, GetFreeMemGB(), (int) (rk0+(k+exch/2)%(exch)),(int) exch,
    #####: 9995:			  (double) vmem/1024./1024.,
    #####: 9996:			  (double) phymem/1024./1024.,__LINE__,sizeof(hpix)*ntbs/1024/1024);
    #####: 9997:		  sleep(10); // wait for other ranks to fail allocation and display error message
    #####: 9998:		  return 1;
        -: 9999:		}
        -:10000:	      }
        -:10001:	      else {
    86039:10002:		tbs=(hpix *) realloc(tbs,sizeof(hpix)*(ntbs+l_nhpix[j]));
    86039:10003:		if (tbs == NULL) {
    #####:10004:		  GetProcMem( &vmem, &phymem);
    #####:10005:		  fprintf(stderr,"Rank: %d(%s, free=%.2fGB) [%d/%d] used MEM virt:%.1lf[phys:%.1lf]MB line=%d ntbs:%ldMB\n",
    #####:10006:			  rank, hostname, GetFreeMemGB(), (int) (rk0+(k+exch/2)%(exch)),(int) exch,
    #####:10007:			  (double) vmem/1024./1024.,
    #####:10008:			  (double) phymem/1024./1024.,__LINE__,sizeof(hpix)*ntbs/1024/1024);
    #####:10009:		  sleep(10); // wait for other ranks to fail allocation and display error message
    #####:10010:		  return 1;
        -:10011:		}
        -:10012:	      }
        -:10013:
    86049:10014:	      memcpy(tbs+ntbs,l_hpix[j], sizeof(hpix)*(l_nhpix[j]));
    86049:10015:	      free(l_hpix[j]);
    86049:10016:	      ntbs+=l_nhpix[j];
        -:10017:	    }
        -:10018:	  }
        -:10019:          //fprintf (stderr,"%d -> %d\n",rank,rk0+k);
       12:10020:          MPI_Send(&ntbs, sizeof(long), MPI_BYTE, rk0+k, 450, MPI_COMM_WORLD);
       12:10021:          if (ntbs>0) {
       10:10022:            MPI_Send(tbs, sizeof(hpix)*(ntbs), MPI_BYTE, rk0+k, 451, MPI_COMM_WORLD);
       10:10023:            free(tbs);
        -:10024:          }
        -:10025:        }
        -:10026:      }
        -:10027:    }
        -:10028:  }
        -:10029:
        -:10030:
        4:10031:  memcpy(loc_nhpix,l_nhpix+begpix[rank],sizeof(long)*(nnbpix));
        4:10032:  for (j=0;j<nnbpix;j++) loc_hpix[j]=l_hpix[j+begpix[rank]];
        -:10033:
        -:10034:
        -:10035:#endif
        -:10036:
        4:10037:  free(l_hpix);
        4:10038:  free(l_nhpix);
        -:10039:
        -:10040:
        4:10041:  PIOFLOAT *REFMAPI=NULL;
        4:10042:  PIOFLOAT *REFMAPQ=NULL;
        4:10043:  PIOFLOAT *REFMAPU=NULL;
        -:10044:
        4:10045:  if (Param->flag_REFMAPI==_PAR_TRUE) {
    #####:10046:    if (rank==0) fprintf(stderr,"DO REFMAPI CHI2\n");
        -:10047:    PIOSTRING commask;
    #####:10048:    sprintf(commask,"begin=%lld;end=%lld",(long long) begpix[rank],(long long) edpix[rank]);
    #####:10049:    REFMAPI = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*(edpix[rank]-begpix[rank]+1));
    #####:10050:    long resmask=(long) noDMC_readObject_PIOFLOAT(Param->REFMAPI,begpix[rank],edpix[rank]-begpix[rank]+1,REFMAPI);
    #####:10051:    if (rank==0) fprintf(stderr,"REFMAPI %ld\n",(long) resmask);
    #####:10052:    REFMAPQ = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*(edpix[rank]-begpix[rank]+1));
    #####:10053:    resmask=(long) noDMC_readObject_PIOFLOAT(Param->REFMAPQ,begpix[rank],edpix[rank]-begpix[rank]+1,REFMAPQ);
    #####:10054:    if (rank==0) fprintf(stderr,"REFMAPQ %ld\n",(long) resmask);
    #####:10055:    REFMAPU = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*(edpix[rank]-begpix[rank]+1));
    #####:10056:    resmask=(long) noDMC_readObject_PIOFLOAT(Param->REFMAPU,begpix[rank],edpix[rank]-begpix[rank]+1,REFMAPU);
    #####:10057:    if (rank==0) fprintf(stderr,"REFMAPU %ld\n",(long) resmask);
        -:10058:  }
        -:10059:
        -:10060:
        -:10061:#ifndef DOMAP
        -:10062:  PIOFLOAT **alm_map = (PIOFLOAT **) malloc(LMAX*sizeof(PIOFLOAT *));
        -:10063:  {
        -:10064:    PIOSTRING commask;
        -:10065:    PIOFLOAT *tmpalm;
        -:10066:    sprintf(commask,"begin=%lld;end=%lld",(long long) begpix[rank],(long long) edpix[rank]);
        -:10067:    for (i=0;i<LMAX;i++) {
        -:10068:      fprintf(stderr,"ALM %ld\n",(long) PIOReadMAPObject((void **) &tmpalm,Param->ALMMAP[i],"PIOFLOAT",commask,NULL));
        -:10069:      alm_map[i]=tmpalm;
        -:10070:    }
        -:10071:  }
        -:10072:#endif
        -:10073:
        4:10074:  GetProcMem(&vmem,&phymem);
        6:10075:  if (rank%64==0) fprintf(stderr,"Rank: %ld[%d] MEM %.1lf[%.1lf]MB line=%d\n",
        -:10076:              (long) rank, getpid(),
        1:10077:              (double) vmem/1024./1024.,
        1:10078:              (double) phymem/1024./1024.,__LINE__);
        -:10079:
        4:10080:  PrintFreeMemOnNodes( rank, mpi_size, "before matrix computation");
        -:10081:
        -:10082:  /*======================================================
        -:10083:    =
        -:10084:    =     Compute matrix size
        -:10085:    =
        -:10086:    =*/
        4:10087:  flg_rg = (PIOBYTE **) malloc(nbolo*sizeof(PIOBYTE *));
       20:10088:  for (ib=0;ib<nbolo;ib++) {
       16:10089:    flg_rg[ib]= (PIOBYTE *) malloc(sizeof(PIOBYTE)*
        -:10090:                                       (globalRangeRing));
        -:10091:
       16:10092:    memset(flg_rg[ib],0,sizeof(PIOBYTE)*(globalRangeRing));
        -:10093:  }
        -:10094:
        -:10095:  PIOLONG k;
        -:10096:  long i0;
        4:10097:  flgpix = (PIOBYTE *) malloc(sizeof(PIOBYTE)*nnbpix);
        4:10098:  memset(flgpix,0,sizeof(PIOBYTE)*nnbpix);
        -:10099:
        -:10100:  MPI_Status statu;
        -:10101:
        4:10102:  long l_nmatpix=0;
 50331652:10103:  for (k=0;k<nnbpix;k++) if (mask[k]==1) {
 43374348:10104:    long ndata = loc_nhpix[k];
 43374348:10105:    if (ndata>2) {
    19487:10106:      hpix *htmp = loc_hpix[k];
    19487:10107:      double II=0,QQ=0,UU=0,QU=0,IQ=0,IU=0;
    89281:10108:      for (i0=0;i0<ndata;i0++) {
   139588:10109:        double CO0=eta[(int) htmp[i0].ib]*(dpsico[(int) htmp[i0].ib]*htmp[i0].co
    69794:10110:                                     -dpsisi[(int) htmp[i0].ib]*htmp[i0].si);
   139588:10111:        double SI0=eta[(int) htmp[i0].ib]*(dpsico[(int) htmp[i0].ib]*htmp[i0].si
    69794:10112:                                     +dpsisi[(int) htmp[i0].ib]*htmp[i0].co);
    69794:10113:        II+= htmp[i0].w;
    69794:10114:        QQ+= htmp[i0].w*CO0*CO0;
    69794:10115:        UU+= htmp[i0].w*SI0*SI0;
    69794:10116:        IQ+= htmp[i0].w*CO0;
    69794:10117:        IU+= htmp[i0].w*SI0;
    69794:10118:        QU+= htmp[i0].w*SI0*CO0;
        -:10119:
        -:10120:      }
    38974:10121:      if (Param->OUT_NOPOL[0]%2==1&&II>0) {
    19487:10122:        flgpix[k]=1;
    89281:10123:        for (i0=0;i0<ndata;i0++) {
    69794:10124:          flg_rg[htmp[i0].ib][htmp[i0].rg-globalBeginRing]=1;
    69794:10125:          l_nmatpix++;
        -:10126:        }
        -:10127:      }
        -:10128:      else {
    #####:10129:        double cond=cond_3_3_thres(II,IQ,IU,IQ,QQ,QU,IU,QU,UU);
        -:10130:
    #####:10131:        if (cond < Param->seuilcond) {
    #####:10132:          flgpix[k]=1;
    #####:10133:          for (i0=0;i0<ndata;i0++) {
    #####:10134:            flg_rg[htmp[i0].ib][htmp[i0].rg-globalBeginRing]=1;
        -:10135:            //flg_rg2[htmp[i0].ib][htmp[i0].hrg-globalBeginRing*CUTRG]=1;
    #####:10136:            l_nmatpix++;
        -:10137:          }
        -:10138:        }
        -:10139:        else {
    #####:10140:          flgpix[k]=0;
        -:10141:
        -:10142:        // Print detail for pix that does not meet cond requirement
        -:10143://        fprintf(stderr,"[DBG COND] Pix#%ld is flagged out! II=%g IQ=%g IU=%g QQ=%g QU=%g UU=%g \n",
        -:10144://                k+begpix[rank], II, IQ, IU, QQ, QU, UU);
        -:10145:        }
        -:10146:      }
        -:10147:    }
        -:10148:    else {
        -:10149:      //      fprintf(stderr,"[DBG COND] Pix#%ld is flagged out! ndata<=2\n", k+begpix[rank]);
 43354861:10150:      flgpix[k]=0;
        -:10151:    }
        -:10152:  }
        -:10153:
        -:10154:  //inv_stat_pix = (int *) malloc(l_nmatpix*sizeof(int));
        -:10155:  //the_stat_pix = (int *) malloc(sizeof(int)*nnbpix);
        -:10156:
        -:10157:  //for (j=0;j<nnbpix;j++) the_stat_pix[j]=-1;
        -:10158:
        4:10159:  l_nmatpix=0;
 50331652:10160:  for (j=0;j<nnbpix;j++) {
 50331648:10161:    if (flgpix[j]==1) {
        -:10162:      //inv_stat_pix[l_nmatpix]=j+begpix[rank];
        -:10163:      //the_stat_pix[j]=l_nmatpix;
    19487:10164:      l_nmatpix++;
        -:10165:    }
        -:10166:  }
        4:10167:  if (rank==0) fprintf(stderr,"l_nmatpix[%d] %ld\n",rank,(long) l_nmatpix);
        -:10168:
        -:10169:#ifdef OPTIMPI
        -:10170:  long lb;
        4:10171:  MPI_Reduce(&l_nmatpix,&lb,1,MPI_LONG,MPI_SUM,0,MPI_COMM_WORLD);
        4:10172:  nmatpix=lb;
        -:10173:#else
        -:10174:  if (rank==0) {
        -:10175:    long lb;
        -:10176:    nmatpix=l_nmatpix;
        -:10177:    for (rrk=1;rrk<mpi_size;rrk++) {
        -:10178:      MPI_Recv(&lb,sizeof(long), MPI_BYTE, rrk,450, MPI_COMM_WORLD,&statu);
        -:10179:      nmatpix+=lb;
        -:10180:    }
        -:10181:  }
        -:10182:  else MPI_Send(&l_nmatpix, sizeof(long), MPI_BYTE, 0, 450, MPI_COMM_WORLD);
        -:10183:#endif
        4:10184:  MPI_Bcast(&nmatpix, sizeof(long), MPI_BYTE, 0, MPI_COMM_WORLD);
        -:10185:
       20:10186:  for (ib=0;ib<nbolo;ib++) {
       16:10187:    PIOBYTE *l_flg_rg = (PIOBYTE *) malloc(sizeof(PIOBYTE)*
        -:10188:                                           (globalRangeRing));
        -:10189:
       80:10190:    for (rrk=0;rrk<mpi_size;rrk++) {
       64:10191:      if (rrk==rank) memcpy(l_flg_rg ,flg_rg[ib] ,sizeof(PIOBYTE)*
        -:10192:                            (globalRangeRing));
       64:10193:      MPI_Bcast(l_flg_rg,sizeof(PIOBYTE)*
        -:10194:                (globalRangeRing), MPI_BYTE, rrk, MPI_COMM_WORLD);
       64:10195:      for (i=0;i<(globalRangeRing);i++) if (l_flg_rg[i]==1) flg_rg[ib][i]=1;
        -:10196:
        -:10197:    }
       16:10198:    free(l_flg_rg);
        -:10199:  }
        -:10200:
        -:10201:#if 0
        -:10202:  if (CUTRG>1) {
        -:10203:    for (ib=0;ib<nbolo;ib++) {
        -:10204:      PIOBYTE *l_flg_rg = (PIOBYTE *) malloc(sizeof(PIOBYTE)*
        -:10205:					     (globalRangeRing)*CUTRG);
        -:10206:
        -:10207:      for (rrk=0;rrk<mpi_size;rrk++) {
        -:10208:	if (rrk==rank) memcpy(l_flg_rg ,flg_rg2[ib] ,sizeof(PIOBYTE)*
        -:10209:			    d  (globalRangeRing)*CUTRG);
        -:10210:	MPI_Bcast(l_flg_rg,sizeof(PIOBYTE)*
        -:10211:		  (globalRangeRing)*CUTRG, MPI_BYTE, rrk, MPI_COMM_WORLD);
        -:10212:	for (i=0;i<(globalRangeRing)*CUTRG;i++) if (l_flg_rg[i]==1) flg_rg2[ib][i]=1;
        -:10213:
        -:10214:      }
        -:10215:      free(l_flg_rg);
        -:10216:    }
        -:10217:  }
        -:10218:#endif
        -:10219:
        4:10220:  GetProcMem(&vmem,&phymem);
        6:10221:  if (rank%64==0) fprintf(stderr,"Rank: %ld[%d] MEM %.1lf[%.1lf]MB line=%d\n",
        -:10222:              (long) rank, getpid(),
        1:10223:              (double) vmem/1024./1024.,
        1:10224:              (double) phymem/1024./1024.,__LINE__);
        -:10225:
        4:10226:  rgord = (PIOINT **) malloc(nbolo*sizeof(PIOINT *));
        4:10227:  PIOINT **rgordinv = (PIOINT **) malloc(nbolo*sizeof(PIOINT *));
        4:10228:  newnr  = (PIOLONG *) malloc((nbolo+1)*sizeof(PIOLONG));
        4:10229:  rgord2 = (PIOINT **) malloc(nbolo*sizeof(PIOINT *));
        4:10230:  PIOINT **rgordinv2 = (PIOINT **) malloc(nbolo*sizeof(PIOINT *));
        4:10231:  newnr2  = (PIOLONG *) malloc((nbolo+1)*sizeof(PIOLONG));
        -:10232:
        4:10233:  newnr[0]=0;
       20:10234:  for (ib=0;ib<nbolo;ib++) {
       16:10235:    rgord[ib] = (PIOINT *) malloc(sizeof(PIOINT)*
        -:10236:                                  (globalRangeRing));
       16:10237:    rgordinv[ib] = (PIOINT *) malloc(sizeof(PIOINT)*
        -:10238:                                     (globalRangeRing));
        -:10239:
       16:10240:    newnr[ib+1]=0;
     4160:10241:    for (i=0;i<(globalRangeRing);i++) if (flg_rg[ib][i]>0) {
       48:10242:      rgord[ib][i]=newnr[ib+1];
       48:10243:      rgordinv[ib][newnr[ib+1]]=i;
       48:10244:      newnr[ib+1]++;
        -:10245:    }
        -:10246:  }
        4:10247:  for (ib=1;ib<nbolo+1;ib++) newnr[ib]+=newnr[ib-1];
        -:10248:
        4:10249:  newnr2[0]=0;
       20:10250:  for (ib=0;ib<nbolo;ib++) {
       16:10251:    rgord2[ib] = (PIOINT *) malloc(sizeof(PIOINT)*
       16:10252:                                  (globalRangeRing)*CUTRG);
       16:10253:    rgordinv2[ib] = (PIOINT *) malloc(sizeof(PIOINT)*
       16:10254:                                     (globalRangeRing)*CUTRG);
        -:10255:
       16:10256:    newnr2[ib+1]=0;
     4160:10257:    for (i=0;i<(globalRangeRing)*CUTRG;i++) if (flg_rg[ib][i/CUTRG]>0) {
       48:10258:      rgord2[ib][i]=newnr2[ib+1];
       48:10259:      rgordinv2[ib][newnr2[ib+1]]=i;
       48:10260:      newnr2[ib+1]++;
        -:10261:    }
        -:10262:  }
        4:10263:  for (ib=1;ib<nbolo+1;ib++) newnr2[ib]+=newnr2[ib-1];
        -:10264:
        4:10265:  nmatco=nbolo;
        4:10266:  if (Param->flag_Theo_CO!=_PAR_TRUE) nmatco=0;
        4:10267:  nfreefree=nbolo;
        4:10268:  if (Param->flag_Theo_FREEFREE!=_PAR_TRUE) nfreefree=0;
        4:10269:  nmatdust=nbolo;
        4:10270:  if (Param->flag_Theo_Dust_I!=_PAR_TRUE) nmatdust=0;
        -:10271:
        4:10272:  if (rank==0) fprintf(stderr,"NMATCO %ld NMATDUST %ld\n FREEFREE %ld\n",(long)  nmatco,(long)  nmatdust,(long)  nfreefree);
        -:10273:
        -:10274:#ifdef DONSIDE
        4:10275:  PIOLONG nmat= nmatpix*2+newnr[nbolo]+nbolo*npixbeam+nbolo*(nadu3)+nmatco+nmatdust+nfreefree;
        -:10276:#else
        -:10277:  PIOLONG nmat= nmatpix*2+newnr[nbolo]+nbolo*(nadu3)+nmatco+nmatdust+nfreefree;
        -:10278:#endif
        -:10279:
        -:10280:
        4:10281:  if (rank==0) {
        1:10282:    fprintf(stderr,"RK%d SHOULD DETERMINE %ld VALUES ",rank,(long) nmat);
        1:10283:    for (i=0;i<nbolo+1;i++) fprintf(stderr,"%ld ",(long) newnr[i]);
        1:10284:    fprintf(stderr,"\n");
        -:10285:  }
        -:10286:
        4:10287:  if (Param->TESTPOL==7) {
        -:10288:    double dpsico2[30];
        -:10289:    double dpsisi2[30];
    #####:10290:    for (k=0;k<nbolo;k++) dpsico2[k]=cos((k-(nbolo-1)/2.)*0.0174);
    #####:10291:    for (k=0;k<nbolo;k++) dpsisi2[k]=sin((k-(nbolo-1)/2.)*0.0174);
    #####:10292:    for (k=0;k<nnbpix;k++)  {
    #####:10293:      long ndata = loc_nhpix[k];
    #####:10294:      hpix *htmp = loc_hpix[k];
        -:10295:      int l1;
        -:10296:      double l_th,l_ph;
    #####:10297:      pix2ang_ring(Nside,k+begpix[rank],&l_th,&l_ph);
    #####:10298:      for (l1=0;l1<ndata;l1++) {
        -:10299:
    #####:10300:        double CO1=eta[htmp[l1].ib]*(dpsico2[htmp[l1].ib]*htmp[l1].co
    #####:10301:                                        -dpsisi2[htmp[l1].ib]*htmp[l1].si);
    #####:10302:        double SI1=eta[htmp[l1].ib]*(dpsico2[htmp[l1].ib]*htmp[l1].si
    #####:10303:                                    +dpsisi2[htmp[l1].ib]*htmp[l1].co);
        -:10304:
    #####:10305:          htmp[l1].listp[0] = htmp[l1].dip+htmp[l1].fsl+1E-4*(CO1*cos(l_th*4)+SI1*sin(l_th*3));
        -:10306:      }
        -:10307:    }
        -:10308:  }
        -:10309:
        4:10310:  if (Param->REMHDIP==1) {
        -:10311:    PIOFLOAT *templatemap;
        4:10312:    templatemap = (PIOFLOAT *) malloc(sizeof(PIOFLOAT)*(edpix[rank]-begpix[rank]+1));
        4:10313:    PIOLONG nmask = noDMC_readObject_PIOFLOAT(Param->TEMPLATEMAP,begpix[rank],edpix[rank]-begpix[rank]+1,templatemap);
        4:10314:    if (nmask!=0) {
    #####:10315:      fprintf(stderr,"Impossible to read TEMPLATEMAP %ld %ld\n",(long) (edpix[rank]-begpix[rank]+1), (long) nmask);
    #####:10316:      exit(0);
        -:10317:    }
        -:10318:
 50331652:10319:    for (k=0;k<nnbpix;k++)  {
 50331648:10320:      long ndata = loc_nhpix[k];
 50331648:10321:      hpix *htmp = loc_hpix[k];
        -:10322:      int l1;
        -:10323:      //double tmpmap=templatemap[k];
        -:10324:      //if (k==0) fprintf(stderr,"PIX %lf\n",tmpmap);
 50528033:10325:      for (l1=0;l1<ndata;l1++) {
        -:10326:
   196385:10327:          htmp[l1].freefree  = htmp[l1].dip;
   196385:10328:          htmp[l1].dip  = htmp[l1].model;
        -:10329:          //htmp[l1].dip  = tmpmap+htmp[l1].dip;
        -:10330:	  //htmp[l1].model = htmp[l1].dip+tmpmap;
        -:10331:      }
        -:10332:    }
        4:10333:    free(templatemap);
        -:10334:  }
        -:10335:
        -:10336:#if 0 //NOT YET USED
        -:10337:  else {
        -:10338:    PIODOUBLE *templatemap;
        -:10339:    templatemap = (PIODOUBLE *) malloc(sizeof(PIODOUBLE)*(edpix[rank]-begpix[rank]+1));
        -:10340:    PIOLONG nmask = noDMC_readObject_PIODOUBLE(Param->TEMPLATEMAP,begpix[rank],edpix[rank]-begpix[rank]+1,templatemap);
        -:10341:    if (nmask!=0) {
        -:10342:      fprintf(stderr,"Impossible to read templatemap\n");
        -:10343:      exit(0);
        -:10344:    }
        -:10345:    for (k=0;k<nnbpix;k++)  {
        -:10346:      long ndata = loc_nhpix[k];
        -:10347:      hpix *htmp = loc_hpix[k];
        -:10348:      int l1;
        -:10349:      double tmpmap=templatemap[k];
        -:10350:      for (l1=0;l1<ndata;l1++) {
        -:10351:
        -:10352:          //htmp[l1].dipmod  = tmpmap+htmp[l1].dip;
        -:10353:          htmp[l1].dipmod  = 1;//htmp[l1].dip;
        -:10354:      }
        -:10355:    }
        -:10356:    free(templatemap);
        -:10357:  }
        -:10358:#endif
        -:10359:
        -:10360: //========================================================================
        -:10361:  // if ADU option is open do the histogram and transfrom the adu field in the data
        -:10362:
        -:10363:  double *histo_adu[MAXADUBOLO];
        -:10364:  double *xadu[MAXADUBOLO];
       20:10365:  for (i=0;i<nbolo;i++) {
       16:10366:    histo_adu[i] =(double *) malloc(nadustep[i]*sizeof(double));
       16:10367:    memset(histo_adu[i],0,nadustep[i]*sizeof(double));
       16:10368:    xadu[i] = (double *) malloc(128*sizeof(double));
        -:10369:  }
        -:10370:
        4:10371:  double *histo_gi = (double *) malloc(32000*sizeof(double)*nbolo);
        4:10372:  double *histo2_gi = (double *) malloc(32000*sizeof(double)*nbolo);
        4:10373:  double *histon_gi = (double *) malloc(32000*sizeof(double)*nbolo);
        4:10374:  int *invgi       = (int *)    malloc(32000*sizeof(int)*nbolo);
        4:10375:  GAINSTEP = Param->GAINSTEP;
        -:10376:  //GAINSTEP = nadu3;
        4:10377:  double *xgi      = (double *) malloc(GAINSTEP*sizeof(double)*nbolo);
        4:10378:  double *nxgi     = (double *) malloc(GAINSTEP*sizeof(double)*nbolo);
        -:10379:
        4:10380:  double mat_dip[4*nbolo];
        4:10381:  double vec_dip[2*nbolo];
        -:10382:
        4:10383:  memset(mat_dip,0,4*sizeof(double)*nbolo);
        4:10384:  memset(vec_dip,0,2*sizeof(double)*nbolo);
        -:10385:
        4:10386:  memset(histo_gi ,0,nbolo*32000*sizeof(double));
        4:10387:  memset(histo2_gi ,0,nbolo*32000*sizeof(double));
        4:10388:  memset(histon_gi ,0,nbolo*32000*sizeof(double));
        -:10389:
        4:10390:  if (Param->OUT_NOPOL[0]%2==0) {
    #####:10391:    for (k=0;k<nnbpix;k++)  {
    #####:10392:      if (flgpix[k]>0) {
    #####:10393:        long ndata = loc_nhpix[k];
    #####:10394:        hpix *htmp = loc_hpix[k];
        -:10395:        int l1;
    #####:10396:        double DI=0,DQ=0,DU=0;
    #####:10397:        double II2=0,IQ2=0,IU2=0,QQ2=0,QU2=0,UU2=0;
    #####:10398:        for (l1=0;l1<ndata;l1++) {
    #####:10399:          long ri1=htmp[l1].rg-globalBeginRing;
    #####:10400:          if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -:10401:
    #####:10402:            double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####:10403:                                              -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####:10404:            double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####:10405:                                              +dpsisi[htmp[l1].ib]*htmp[l1].co);
        -:10406:
    #####:10407:            DI+=htmp[l1].w*htmp[l1].dip;
    #####:10408:            DQ+=htmp[l1].w*htmp[l1].dip*CO1;
    #####:10409:            DU+=htmp[l1].w*htmp[l1].dip*SI1;
        -:10410:
    #####:10411:            II2+=htmp[l1].w;
    #####:10412:            IQ2+=htmp[l1].w*CO1;
    #####:10413:            IU2+=htmp[l1].w*SI1;
    #####:10414:            QQ2+=htmp[l1].w*CO1*CO1;
    #####:10415:            QU2+=htmp[l1].w*SI1*CO1;
    #####:10416:            UU2+=htmp[l1].w*SI1*SI1;
        -:10417:          }
        -:10418:        }
    #####:10419:        solvemap(&DI,&DQ,&DU,II2,IQ2,IU2,QQ2,QU2,UU2);
        -:10420:
    #####:10421:        for (l1=0;l1<ndata;l1++) {
    #####:10422:          long ri1=htmp[l1].rg-globalBeginRing;
    #####:10423:          if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####:10424:            double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    #####:10425:                                              -dpsisi[htmp[l1].ib]*htmp[l1].si);
    #####:10426:            double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    #####:10427:                                              +dpsisi[htmp[l1].ib]*htmp[l1].co);
        -:10428:
    #####:10429:            double li=htmp[l1].w,lco=CO1*htmp[l1].w,lsi=SI1*htmp[l1].w;
    #####:10430:            solvemap(&li,&lco,&lsi,II2,IQ2,IU2,QQ2,QU2,UU2);
    #####:10431:            double divi=NEP_tab[htmp[l1].ib]*htmp[l1].hit*(1-(li+CO1*lco+SI1*lsi));
    #####:10432:            divi=divi*divi;
        -:10433:
        -:10434:            long l3;
        -:10435:
    #####:10436:            for (l3=0;l3<ndata;l3++) if (l3!=l1) {
    #####:10437:                long ri3=htmp[l3].rg-globalBeginRing;
    #####:10438:                if (flg_rg[htmp[l3].ib][ri3]!=0) {
    #####:10439:               li=htmp[l3].w;lco=CO1*htmp[l3].w;lsi=SI1*htmp[l3].w;
    #####:10440:               solvemap(&li,&lco,&lsi,II2,IQ2,IU2,QQ2,QU2,UU2);
    #####:10441:               double sigma=NEP_tab[htmp[l3].ib]*htmp[l3].hit*(li+CO1*lco+SI1*lsi);
    #####:10442:               divi+=sigma*sigma;
        -:10443:                }
        -:10444:              }
    #####:10445:            double ww=1/divi;
    #####:10446:            double tmp=(htmp[l1].dip); //-(DI+CO1*DQ+SI1*DU));
        -:10447:
    #####:10448:            histo_gi[htmp[l1].rg+htmp[l1].ib*32000]+=ww*tmp;
    #####:10449:            histo2_gi[htmp[l1].rg+htmp[l1].ib*32000]+=ww*tmp*tmp;
    #####:10450:            histon_gi[htmp[l1].rg+htmp[l1].ib*32000]+=ww;
        -:10451:
        -:10452:#if 1
    #####:10453:            if (DODISTOR!=0) histo_adu[htmp[l1].ib][htmp[l1].adu]+=ww;
        -:10454:#else
        -:10455:            if (DODISTOR!=0) histo_adu[htmp[l1].ib][htmp[l1].adu]=1;
        -:10456:#endif
        -:10457:
    #####:10458:            mat_dip[0+4*htmp[l1].ib]+=ww*htmp[l1].dip*htmp[l1].dip;
    #####:10459:            mat_dip[1+4*htmp[l1].ib]+=ww*htmp[l1].dip;
    #####:10460:            mat_dip[2+4*htmp[l1].ib]+=ww*htmp[l1].dip;
    #####:10461:            mat_dip[3+4*htmp[l1].ib]+=ww;
        -:10462:
    #####:10463:            vec_dip[0+2*htmp[l1].ib]+=ww*htmp[l1].listofpix[0]*htmp[l1].dip;
    #####:10464:            vec_dip[1+2*htmp[l1].ib]+=ww*htmp[l1].listofpix[0];
        -:10465:
        -:10466:          }
        -:10467:        }
        -:10468:      }
        -:10469:    }
        -:10470:  }// NO POL METHOD
        -:10471:  else {
 50331652:10472:    for (k=0;k<nnbpix;k++)  {
 50331648:10473:      if (flgpix[k]>0) {
    19487:10474:        long ndata = loc_nhpix[k];
    19487:10475:        hpix *htmp = loc_hpix[k];
        -:10476:        int l1;
    19487:10477:        double DI=0;
    19487:10478:        double II2=0;
    89281:10479:        for (l1=0;l1<ndata;l1++) {
    69794:10480:          long ri1=htmp[l1].rg-globalBeginRing;
    69794:10481:          if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -:10482:
        -:10483:
    69794:10484:            DI+=htmp[l1].w*htmp[l1].dip;
        -:10485:
    69794:10486:            II2+=htmp[l1].w;
        -:10487:          }
        -:10488:        }
    19487:10489:        DI=DI/II2;
        -:10490:
    89281:10491:        for (l1=0;l1<ndata;l1++) {
    69794:10492:          long ri1=htmp[l1].rg-globalBeginRing;
    69794:10493:          if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -:10494:
    69794:10495:            double divi=NEP_tab[htmp[l1].ib]*htmp[l1].hit;
        -:10496:
    69794:10497:            divi=divi*divi;
    69794:10498:            double ww=1/divi;
        -:10499:
    69794:10500:            double tmp=(htmp[l1].dip);
        -:10501:
    69794:10502:            histo_gi[ htmp[l1].rg+htmp[l1].ib*32000]+=ww*tmp;
    69794:10503:            histo2_gi[htmp[l1].rg+htmp[l1].ib*32000]+=ww*tmp*tmp;
    69794:10504:            histon_gi[htmp[l1].rg+htmp[l1].ib*32000]+=ww;
        -:10505:
        -:10506:#if 1
    69794:10507:            if (DODISTOR!=0) histo_adu[htmp[l1].ib][htmp[l1].adu]+=ww;
        -:10508:#else
        -:10509:            if (DODISTOR!=0) histo_adu[htmp[l1].ib][htmp[l1].adu]=1;
        -:10510:#endif
        -:10511:
    69794:10512:	    mat_dip[0+4*htmp[l1].ib]+=ww*htmp[l1].dip*htmp[l1].dip;
    69794:10513:	    mat_dip[1+4*htmp[l1].ib]+=ww*htmp[l1].dip;
    69794:10514:	    mat_dip[2+4*htmp[l1].ib]+=ww*htmp[l1].dip;
    69794:10515:	    mat_dip[3+4*htmp[l1].ib]+=ww;
        -:10516:
    69794:10517:	    vec_dip[0+2*htmp[l1].ib]+=ww*(htmp[l1].sig)*htmp[l1].dip;
    69794:10518:	    vec_dip[1+2*htmp[l1].ib]+=ww*(htmp[l1].sig);
        -:10519:          }
        -:10520:        }
        -:10521:      }
        -:10522:    }
        -:10523:
        -:10524:  }
        -:10525:
        -:10526:
        -:10527:  /*===============================================================================================
        -:10528:    COMPUTE CUTTING RING FOR OPTIMAL MAP-MAKING
        -:10529:    ===============================================================================================*/
        -:10530:
        4:10531:  if (CUTRG>1) {
        -:10532:    int l_rank;
    #####:10533:    for (l_rank=0;l_rank<mpi_size;l_rank++) {
    #####:10534:      long nring=globalRankInfo.EndRing[l_rank]-globalRankInfo.BeginRing[l_rank]+1;
    #####:10535:      PIOLONG * histo_phase = (PIOLONG *) malloc(sizeof(PIOLONG)*NBPH*nbolo*nring);
    #####:10536:      PIOLONG * l_histo_phase = (PIOLONG *) malloc(sizeof(PIOLONG)*NBPH*nbolo*nring);
        -:10537:      int l1;
    #####:10538:      memset(histo_phase,0,sizeof(PIOLONG)*NBPH*nbolo*nring);
    #####:10539:      for (k=0;k<nnbpix;k++)  {
    #####:10540:        if (flgpix[k]>0) {
    #####:10541:          long ndata = loc_nhpix[k];
    #####:10542:          hpix *htmp = loc_hpix[k];
    #####:10543:          for (l1=0;l1<ndata;l1++) {
    #####:10544:            long ri1=htmp[l1].rg-globalBeginRing;
    #####:10545:            if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####:10546:              if (htmp[l1].rg>=globalRankInfo.BeginRing[l_rank]&&htmp[l1].rg<=globalRankInfo.EndRing[l_rank]) {
    #####:10547:                histo_phase[htmp[l1].hrg+(htmp[l1].rg-globalRankInfo.BeginRing[l_rank]+htmp[l1].ib*nring)*NBPH]+=ndata-1;
        -:10548:              }
        -:10549:            }
        -:10550:          }
        -:10551:        }
        -:10552:      }
    #####:10553:      if (rank==0) {
    #####:10554:        for (rrk=1;rrk<mpi_size;rrk++) {
    #####:10555:          MPI_Recv(l_histo_phase,sizeof(PIOLONG)*NBPH*nbolo*nring, MPI_BYTE, rrk,351, MPI_COMM_WORLD,&statu);
    #####:10556:          for (l1=0;l1<NBPH*nbolo*nring;l1++) histo_phase[l1]+=l_histo_phase[l1];
        -:10557:        }
    #####:10558:        for (ib=0;ib<nbolo;ib++) {
    #####:10559:          for (j=0;j<nring;j++) {
    #####:10560:            for (l1=1;l1<NBPH;l1++) histo_phase[l1+(j+ib*nring)*NBPH]+=histo_phase[l1-1+(j+ib*nring)*NBPH];
    #####:10561:            if (histo_phase[NBPH-1+(j+ib*nring)*NBPH]==0) {
    #####:10562:              for (l1=0;l1<NBPH;l1++) histo_phase[l1+(j+ib*nring)*NBPH]=(l1*CUTRG)/NBPH;
        -:10563:            }
        -:10564:            else {
    #####:10565:	      for (l1=0;l1<NBPH;l1++) histo_phase[l1+(j+ib*nring)*NBPH]=(histo_phase[l1+(j+ib*nring)*NBPH]*CUTRG)/(1+histo_phase[NBPH-1+(j+ib*nring)*NBPH]);
        -:10566:            }
    #####:10567:            for (l1=0;l1<NBPH;l1++) if (histo_phase[l1+(j+ib*nring)*NBPH]>CUTRG-1) histo_phase[l1+(j+ib*nring)*NBPH]=CUTRG-1;
        -:10568:          }
        -:10569:        }
        -:10570:
    #####:10571:        fprintf(stderr,"Ring %d %d Done\n",(int) globalRankInfo.BeginRing[l_rank], (int) globalRankInfo.EndRing[l_rank]);
        -:10572:
        -:10573:      }
        -:10574:      else {
    #####:10575:        MPI_Send(histo_phase, sizeof(PIOLONG)*NBPH*nbolo*nring, MPI_BYTE, 0, 351, MPI_COMM_WORLD);
        -:10576:      }
        -:10577:
    #####:10578:      MPI_Bcast(histo_phase, sizeof(PIOLONG)*NBPH*nbolo*nring, MPI_BYTE, 0, MPI_COMM_WORLD);
        -:10579:
    #####:10580:      for (k=0;k<nnbpix;k++)  {
    #####:10581:        long ndata = loc_nhpix[k];
    #####:10582:        hpix *htmp = loc_hpix[k];
        -:10583:        int l1;
    #####:10584:        for (l1=0;l1<ndata;l1++) {
    #####:10585:          long ri1=htmp[l1].rg-globalBeginRing;
    #####:10586:          if (flg_rg[htmp[l1].ib][ri1]!=0) {
    #####:10587:            if (htmp[l1].rg>=globalRankInfo.BeginRing[l_rank]&&htmp[l1].rg<=globalRankInfo.EndRing[l_rank]) {
    #####:10588:              htmp[l1].hrg=htmp[l1].rg*CUTRG+histo_phase[htmp[l1].hrg+(htmp[l1].rg-globalRankInfo.BeginRing[l_rank]+htmp[l1].ib*nring)*NBPH];
        -:10589:            }
        -:10590:          }
        -:10591:        }
        -:10592:      }
    #####:10593:      free(histo_phase);
    #####:10594:      free(l_histo_phase);
        -:10595:    }
        -:10596:  }
        -:10597:
        -:10598:  //============================================================
        -:10599:  // remove dipole from the first harmonic
        -:10600:  //
        -:10601:
        -:10602:#ifdef OPTIMPI
        -:10603:  double l_mat[4*100];
        -:10604:  double l_vec[2*100];
        4:10605:  MPI_Reduce(mat_dip,l_mat,4*nbolo,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        4:10606:  MPI_Reduce(vec_dip,l_vec,2*nbolo,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
        -:10607:#endif
        -:10608:
        4:10609:  if (rank==0) {
        -:10610:#ifndef OPTIMPI
        -:10611:    MPI_Status statu;
        -:10612:// MAX NBDETECTOR =100
        -:10613:    double l_mat[4*100];
        -:10614:    double l_vec[2*100];
        -:10615:
        -:10616:    for (rrk=1;rrk<mpi_size;rrk++) {
        -:10617:      MPI_Recv(l_mat,sizeof(double)*4*nbolo, MPI_BYTE, rrk,71, MPI_COMM_WORLD,&statu);
        -:10618:      MPI_Recv(l_vec,sizeof(double)*2*nbolo, MPI_BYTE, rrk,71, MPI_COMM_WORLD,&statu);
        -:10619:      for (j=0;j<4*nbolo;j++) mat_dip[j]+=l_mat[j];
        -:10620:      for (j=0;j<2*nbolo;j++) vec_dip[j]+=l_vec[j];
        -:10621:    }
        -:10622:#endif
        -:10623:
        5:10624:    for (j=0;j<nbolo;j++) {
        -:10625:
        4:10626:      lusol(mat_dip+4*j,vec_dip+2*j,2);
        -:10627:
        4:10628:      fprintf(stderr,"GAIN DIP BOL %s (%ld/%ld): %lf\n", pixnames[j], j, nbolo-1, vec_dip[2*j]);
        -:10629:    }
        -:10630:  }
        -:10631:#ifndef OPTIMPI
        -:10632:  else  {
        -:10633:    MPI_Send(mat_dip, sizeof(double)*4*nbolo, MPI_BYTE, 0, 71, MPI_COMM_WORLD);
        -:10634:    MPI_Send(vec_dip, sizeof(double)*2*nbolo, MPI_BYTE, 0, 71, MPI_COMM_WORLD);
        -:10635:  }
        -:10636:#endif
        -:10637:
        -:10638:
        4:10639:  if (Param->flag_ADU==_PAR_TRUE) {
       20:10640:    for (ib=0;ib<nbolo;ib++) {
       16:10641:      if (rank==0) {
        -:10642:        MPI_Status statu;
        -:10643:        int rrk;
        -:10644:        double *l_histo;
        -:10645:	PIOSTRING saveg;
        -:10646:
        4:10647:        if (nadustep[ib]<32000) {
    #####:10648:          l_histo = (double *) malloc((32000)*sizeof(double));
        -:10649:        }
        -:10650:        else {
        4:10651:          l_histo = (double *) malloc((nadustep[ib])*sizeof(double));
        -:10652:        }
       16:10653:        for (rrk=1;rrk<mpi_size;rrk++) {
       12:10654:          if (DODISTOR!=0) {
       12:10655:            MPI_Recv(l_histo,sizeof(double)*nadustep[ib], MPI_BYTE, rrk,51, MPI_COMM_WORLD,&statu);
       12:10656:            for (j=0;j<nadustep[i];j++) histo_adu[ib][j]+=l_histo[j];
        -:10657:          }
       12:10658:          MPI_Recv(l_histo,sizeof(double)*32000, MPI_BYTE, rrk,54, MPI_COMM_WORLD,&statu);
       12:10659:          for (j=0;j<32000;j++) histo_gi[j+ib*32000]+=l_histo[j];
       12:10660:          MPI_Recv(l_histo,sizeof(double)*32000, MPI_BYTE, rrk,55, MPI_COMM_WORLD,&statu);
       12:10661:          for (j=0;j<32000;j++) histo2_gi[j+ib*32000]+=l_histo[j];
       12:10662:          MPI_Recv(l_histo,sizeof(double)*32000, MPI_BYTE, rrk,56, MPI_COMM_WORLD,&statu);
       12:10663:          for (j=0;j<32000;j++) histon_gi[j+ib*32000]+=l_histo[j];
        -:10664:        }
        4:10665:        free(l_histo);
        -:10666:
        4:10667:        int tmpi=0;
        -:10668:
        4:10669:        if (DODISTOR!=0) {
        4:10670:          memset(xadu[ib],0,sizeof(double)*128);
        -:10671:
   128000:10672:	  for (j=1;j<ADUSTEP;j++) {
   127996:10673:	    histo_adu[ib][j]+=histo_adu[ib][j-1];
        -:10674:	  }
   128004:10675:	  for (j=0;j<ADUSTEP;j++) {
   128000:10676:	    histo_adu[ib][j]*=128./histo_adu[ib][ADUSTEP-1];
   128000:10677:	    if (histo_adu[ib][j]>=128.0) histo_adu[ib][j]=128.0; // cas pbs d'arrondi
        -:10678:	  }
        -:10679:
        4:10680:	  double *nxadu=(double *) malloc(128*sizeof(double));
        4:10681:	  memset(nxadu,0,128*sizeof(double));
   128000:10682:	  for (j=1;j<ADUSTEP;j++) {
   127996:10683:	    int xii=(int) histo_adu[ib][j];
   127996:10684:	    if (xii>=128) xii=127;
   127996:10685:	    xadu[ib][xii]+=j;
   127996:10686:	    nxadu[xii]+=1;
        -:10687:	  }
      516:10688:	  for (j=0;j<128;j++) {
      512:10689:	    xadu[ib][j]/=nxadu[j];
        -:10690:	  }
        4:10691:	  free(nxadu);
        -:10692:
        4:10693:          sprintf(saveg,"%s_HISTO_ADU",Param->Out_Offset[ib]);
        8:10694:          fprintf(stderr,"Write HISTO_ADU  %lld\n",(long long) (PIOWriteVECT(saveg,histo_adu[ib],0,
        8:10695:                                                                             sizeof(PIODOUBLE)*nadustep[ib])/sizeof(PIODOUBLE)));
        -:10696:
        4:10697:          sprintf(saveg,"%s_XADU",Param->Out_Offset[ib]);
        8:10698:          fprintf(stderr,"Write XADU  %lld\n",(long long) (PIOWriteVECT(saveg,xadu[ib],0,
        4:10699:                                                                        sizeof(PIODOUBLE)*(128))/sizeof(PIODOUBLE)));
        -:10700:        }
        4:10701:        sprintf(saveg,"%s_HISTO_GAIN",Param->Out_Offset[ib]);
       28:10702:        for (i=0;i<32000;i++) if (histon_gi[i+ib*32000]>0) histo_gi[i+ib*32000]=
       12:10703:                                                             histo2_gi[i+ib*32000]
       24:10704:                                                             -histo_gi[i+ib*32000]*histo_gi[i+ib*32000]/histon_gi[i+ib*32000];
        4:10705:        fprintf(stderr,"Write HISTO_GAIN  %lld\n",(long long) (PIOWriteVECT(saveg,histo_gi+ib*32000,0,32000*sizeof(double))/sizeof(double)));
        4:10706:        for (i=1;i<32000;i++) histo_gi[i+ib*32000]+=histo_gi[i-1+ib*32000];
        -:10707:
        4:10708:        double step=(histo_gi[31999+ib*32000]+1)/GAINSTEP;
        4:10709:	tmpi=0;
        4:10710:        memset(xgi+ib*GAINSTEP,0,sizeof(double)*GAINSTEP);
        4:10711:        memset(nxgi+ib*GAINSTEP,0,sizeof(double)*GAINSTEP);
        4:10712:        invgi[0+ib*32000]=0;
   128000:10713:        for (i=1;i<32000;i++) {
   127996:10714:          invgi[i+ib*32000]=tmpi;
   127996:10715:          xgi[tmpi+ib*GAINSTEP]+=(i)*(histo_gi[i+ib*32000]-histo_gi[i-1+ib*32000]);
   127996:10716:          nxgi[tmpi+ib*GAINSTEP]+=(histo_gi[i+ib*32000]-histo_gi[i-1+ib*32000]);
   127996:10717:          if (histo_gi[i+ib*32000]>step*(1+tmpi)) {
    #####:10718:            if (tmpi<GAINSTEP-1) {
    #####:10719:	      tmpi++;
        -:10720:	    }
        -:10721:          }
        -:10722:        }
   128004:10723:        for (i=0;i<32000;i++) {
   128000:10724:          if (invgi[i+ib*32000]>=GAINSTEP) invgi[i+ib*32000]=GAINSTEP-1;
        -:10725:        }
        -:10726:
        8:10727:        for (i=0;i<GAINSTEP;i++) {
        4:10728:          xgi[i+ib*GAINSTEP]/=nxgi[i+ib*GAINSTEP];
        -:10729:        }
        -:10730:
        4:10731:        sprintf(saveg,"%s_INV_GI",Param->Out_Offset[ib]);
        4:10732:        fprintf(stderr,"Write INV_GI  %lld\n",(long long) PIOWriteVECT(saveg,invgi+ib*32000,0,32000*sizeof(int))/sizeof(int));
        -:10733:
        4:10734:        sprintf(saveg,"%s_XGI",Param->Out_Offset[ib]);
        4:10735:        fprintf(stderr,"Write XGI  %lld\n",(long long) PIOWriteVECT(saveg,xgi+ib*GAINSTEP,0,sizeof(PIODOUBLE)*GAINSTEP)/sizeof(PIODOUBLE));
        -:10736:      }
        -:10737:      else {
       12:10738:        if (DODISTOR!=0) MPI_Send(histo_adu[ib], sizeof(double)*nadustep[ib], MPI_BYTE, 0, 51, MPI_COMM_WORLD);
       12:10739:	MPI_Send(histo_gi+ib*32000, sizeof(double)*32000, MPI_BYTE, 0, 54, MPI_COMM_WORLD);
       12:10740:        MPI_Send(histo2_gi+ib*32000, sizeof(double)*32000, MPI_BYTE, 0, 55, MPI_COMM_WORLD);
       12:10741:        MPI_Send(histon_gi+ib*32000, sizeof(double)*32000, MPI_BYTE, 0, 56, MPI_COMM_WORLD);
        -:10742:      }
        -:10743:    }
        -:10744:
        4:10745:    if (DODISTOR!=0) {
       20:10746:      for (ib=0;ib<nbolo;ib++) {
       16:10747:	MPI_Bcast(histo_adu[ib],sizeof(double)*nadustep[ib], MPI_BYTE, 0, MPI_COMM_WORLD);
        -:10748:      }
        -:10749:    }
        -:10750:
        4:10751:    MPI_Bcast(invgi,sizeof(int)*32000*nbolo, MPI_BYTE, 0, MPI_COMM_WORLD);
        4:10752:    MPI_Bcast(xgi,sizeof(double)*GAINSTEP*nbolo, MPI_BYTE, 0, MPI_COMM_WORLD);
        -:10753:
 50331652:10754:    for (k=0;k<nnbpix;k++)  {
 50331648:10755:      long ndata = loc_nhpix[k];
 50331648:10756:      hpix *htmp = loc_hpix[k];
        -:10757:      int l1;
 50528033:10758:      for (l1=0;l1<ndata;l1++) {
   196385:10759:        htmp[l1].gi=invgi[htmp[l1].gi+32000*htmp[l1].ib];
        -:10760:      }
        -:10761:    }
        -:10762:  }
        -:10763:
        4:10764:  if (DODISTOR!=0) {
        -:10765:  
 50331652:10766:    for (k=0;k<nnbpix;k++) {
 50331648:10767:      long ndata = loc_nhpix[k];
 50331648:10768:      hpix *htmp = loc_hpix[k];
        -:10769:      int l1;
 50528033:10770:      for (l1=0;l1<ndata;l1++) {
        -:10771:
   196385:10772:        double xxadu=histo_adu[htmp[l1].ib][htmp[l1].adu];
   196385:10773:        bspline_value(bspline[htmp[l1].ib], xxadu, &(htmp[l1].istart),&(htmp[l1].iend));
   196385:10774:        if (htmp[l1].istart<0) {
    #####:10775:          fprintf(stderr,"xadu1=%lg %lg\n",xxadu,(double) histo_adu[htmp[l1].ib][htmp[l1].adu]);
    #####:10776:          exit(-1);
        -:10777:        }
   196385:10778:        if (htmp[l1].iend-htmp[l1].istart>3) fprintf(stderr,"SUP 4 %ld\n",(long) (htmp[l1].iend-htmp[l1].istart));
   196385:10779:        double *vals = bspline[htmp[l1].ib]->vals;
   196385:10780:        for (i=htmp[l1].istart;i<=htmp[l1].iend;i++) htmp[l1].vspline[i-htmp[l1].istart]=vals[i];
        -:10781:
        -:10782:
        -:10783:        //htmp[l1].istart+=htmp[l1].sadu*nadufit/(ADURGSTEP);
        -:10784:        //htmp[l1].iend+=htmp[l1].sadu*nadufit/(ADURGSTEP);
        -:10785:        //htmp[l1].adu = 0;
        -:10786:      }
        -:10787:    }
        -:10788:
        -:10789:#define STEPRG_HISTOADU (128)
        -:10790:
       20:10791:    for (ib=0;ib<nbolo;ib++) {
       16:10792:      if (ADURGSTEP[ib]>2) {
    #####:10793:	double *spline_stat = (double *) malloc(sizeof(double)*STEPRG_HISTOADU*3200);
    #####:10794:	memset(spline_stat,0,STEPRG_HISTOADU*3200*sizeof(double));
        -:10795:
    #####:10796:	for (k=0;k<nnbpix;k++) {
    #####:10797:	  long ndata = loc_nhpix[k];
    #####:10798:	  hpix *htmp = loc_hpix[k];
        -:10799:	  int l1;
    #####:10800:	  for (l1=0;l1<ndata;l1++) if (htmp[l1].ib==ib) {
    #####:10801:	    spline_stat[(int)(htmp[l1].adu/10)+3200*((int) (htmp[l1].sadu*STEPRG_HISTOADU))]+=1;
        -:10802:	  }
        -:10803:	}
        -:10804:
    #####:10805:	if (rank==0) {
        -:10806:	  MPI_Status statu;
        -:10807:	  int rrk;
    #####:10808:	  double *l_spline_stat=(double *) malloc(3200*STEPRG_HISTOADU*sizeof(double));
    #####:10809:	  for (rrk=1;rrk<mpi_size;rrk++) {
    #####:10810:	    MPI_Recv(l_spline_stat,sizeof(double)*3200*STEPRG_HISTOADU, MPI_BYTE, rrk,51, MPI_COMM_WORLD,&statu);
    #####:10811:	    for (j=0;j<3200*STEPRG_HISTOADU;j++) spline_stat[j]+=l_spline_stat[j];
        -:10812:	  }
    #####:10813:	  free(l_spline_stat);
        -:10814:
    #####:10815:	  for (j=0;j<STEPRG_HISTOADU;j++) {
    #####:10816:	    for (k=1;k<3200;k++) spline_stat[k+3200*j]+=spline_stat[k-1+3200*j];
    #####:10817:	    for (k=0;k<3200;k++) spline_stat[k+3200*j]=spline_stat[k+3200*j]*128/spline_stat[3199+3200*j];
        -:10818:	  }
        -:10819:
        -:10820:#if 0
        -:10821:	  char thename[128];
        -:10822:	  sprintf(thename,"spline_stat_%d.dat",(int) i);
        -:10823:	  FILE *fp=fopen(thename,"w");
        -:10824:	  fwrite(spline_stat,3200*STEPRG_HISTOADU*sizeof(double),1,fp);
        -:10825:	  fclose(fp);
        -:10826:#endif
        -:10827:	}
        -:10828:	else {
    #####:10829:	  MPI_Send(spline_stat, sizeof(double)*3200*STEPRG_HISTOADU, MPI_BYTE, 0, 51, MPI_COMM_WORLD);
        -:10830:	}
        -:10831:
    #####:10832:	MPI_Bcast(spline_stat,sizeof(double)*3200*STEPRG_HISTOADU, MPI_BYTE, 0, MPI_COMM_WORLD);
        -:10833:
        -:10834:
    #####:10835:	for (k=0;k<nnbpix;k++) {
    #####:10836:	  long ndata = loc_nhpix[k];
    #####:10837:	  hpix *htmp = loc_hpix[k];
        -:10838:	  int l1;
    #####:10839:	  for (l1=0;l1<ndata;l1++) if (htmp[l1].ib==ib) {
        -:10840:
    #####:10841:	      double xxadu=spline_stat[(int)(htmp[l1].adu/10)+3200*((int) (htmp[l1].sadu*STEPRG_HISTOADU))];
    #####:10842:	      bspline_value(bspline[htmp[l1].ib], xxadu, &(htmp[l1].istart),&(htmp[l1].iend));
    #####:10843:	      if (htmp[l1].istart<0) {
    #####:10844:		fprintf(stderr,"xadu2=%lg %lg %d %d\n",xxadu,(double) spline_stat[(int)(htmp[l1].adu/10)+3200*((int) (htmp[l1].sadu*STEPRG_HISTOADU))],(int)(htmp[l1].adu/10),((int) (htmp[l1].sadu*STEPRG_HISTOADU)));
    #####:10845:		exit(-1);
        -:10846:	      }
    #####:10847:	      if (htmp[l1].iend-htmp[l1].istart>3) fprintf(stderr,"SUP 4 %ld\n",(long) (htmp[l1].iend-htmp[l1].istart));
    #####:10848:	      double *vals = bspline[htmp[l1].ib]->vals;
    #####:10849:	      for (i=htmp[l1].istart;i<=htmp[l1].iend;i++) htmp[l1].vspline[i-htmp[l1].istart]=vals[i];
        -:10850:	    }
        -:10851:	}
        -:10852:
    #####:10853:	free(spline_stat);
    #####:10854:	nadufit[ib]=ADURGSTEP[ib]*nadufit[ib];
        -:10855:      }
        -:10856:    }
        -:10857:
        -:10858:    //===================================================================================
        -:10859:    //                    DEBUG AND TEST FIT_ADU_NL
        -:10860:    //===================================================================================
        -:10861:
        -:10862:#ifdef TESTFITADU
        -:10863:    double **splineval= (double **) malloc(sizeof(double *)*nbolo);
        -:10864:    for (i=0;i<nbolo;i++) {
        -:10865:      splineval[i] = malloc(sizeof(double)*nadufit[i]);
        -:10866:      for (j=0;j<nadufit[i];j++) splineval[i][j]=1E-5*exp(-((j-nadufit[i]/2.)*(j-nadufit[i]/2.))/8.);
        -:10867:      double avvspline=0;
        -:10868:      for (j=0;j<nadufit[i];j++) avvspline+=splineval[i][j];
        -:10869:      avvspline/=nadufit[i];
        -:10870:      for (j=0;j<nadufit[i];j++) splineval[i][j]-=avvspline;
        -:10871:    }
        -:10872:    for (k=0;k<nnbpix;k++) {
        -:10873:      long ndata = loc_nhpix[k];
        -:10874:      hpix *htmp = loc_hpix[k];
        -:10875:      int l1,iii,jjj;
        -:10876:      for (l1=0;l1<ndata;l1++) {
        -:10877:
        -:10878:	htmp[l1].listp[0]=htmp[l1].dip+0.01*htmp[l1].adu/1000.;
        -:10879:	if (ADURGSTEP[htmp[l1].ib]>2) {
        -:10880:	  for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
        -:10881:	    for (jjj=rg_start[htmp[l1].ib][htmp[l1].rg];jjj<=rg_end[htmp[l1].ib][htmp[l1].rg];jjj++) {
        -:10882:	      int l_idx=jjj+ADURGSTEP[htmp[l1].ib]*iii;
        -:10883:	      htmp[l1].listp[0]+=splineval[htmp[l1].ib][l_idx]*htmp[l1].vspline[iii-htmp[l1].istart]
        -:10884:		  *rg_vals[htmp[l1].ib][jjj-rg_start[htmp[l1].ib][htmp[l1].rg]+4*htmp[l1].rg];
        -:10885:	    }
        -:10886:	  }
        -:10887:	}
        -:10888:	else {
        -:10889:	  for (iii=htmp[l1].istart;iii<=htmp[l1].iend;iii++) {
        -:10890:	    htmp[l1].listp[0]+=splineval[htmp[l1].ib][iii]*htmp[l1].vspline[iii-htmp[l1].istart];
        -:10891:	  }
        -:10892:	}
        -:10893:      }
        -:10894:    }
        -:10895:    for (i=0;i<nbolo;i++) {
        -:10896:      if (rank==0) {
        -:10897:	PIOSTRING saveg;
        -:10898:	sprintf(saveg,"%s_INNL",Param->Out_Offset[i]);
        -:10899:	fprintf(stderr,"Write INNL  %lld\n",(long long) (PIOWriteVECT(saveg,splineval[i],0,sizeof(PIODOUBLE)*(nadufit[i])))/sizeof(double));
        -:10900:      }
        -:10901:      free(splineval[i]);
        -:10902:    }
        -:10903:
        -:10904:    free(splineval);
        -:10905:#endif
        -:10906:
        -:10907:  }// END OF DODISTOR!=0
        -:10908:
       20:10909:  for (ib=0;ib<nbolo;ib++) {
       16:10910:    free(xadu[ib]);
       16:10911:    free(histo_adu[ib]);
        -:10912:  }
        4:10913:  free(histo_gi);
        4:10914:  free(histo2_gi);
        4:10915:  free(histon_gi);
        -:10916:
        4:10917:  SSI = (double *) malloc(sizeof(double)*nnbpix);
        4:10918:  SSQ = (double *) malloc(sizeof(double)*nnbpix);
        4:10919:  SSU = (double *) malloc(sizeof(double)*nnbpix);
        4:10920:  SSI2 = (double *) malloc(sizeof(double)*nnbpix);
        4:10921:  SSQ2 = (double *) malloc(sizeof(double)*nnbpix);
        4:10922:  SSU2 = (double *) malloc(sizeof(double)*nnbpix);
        4:10923:  II = (double *) malloc(sizeof(double)*nnbpix);
        4:10924:  IQ = (double *) malloc(sizeof(double)*nnbpix);
        4:10925:  IU = (double *) malloc(sizeof(double)*nnbpix);
        4:10926:  QQ = (double *) malloc(sizeof(double)*nnbpix);
        4:10927:  UU = (double *) malloc(sizeof(double)*nnbpix);
        4:10928:  QU = (double *) malloc(sizeof(double)*nnbpix);
        -:10929:
        4:10930:  dthetai = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        4:10931:  dthetaq = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        4:10932:  dthetau = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        -:10933:
        4:10934:  dii = (double *) malloc(sizeof(double)*nbolo*GAINSTEP); //*nnbpix);
        4:10935:  dqq = (double *) malloc(sizeof(double)*nbolo*GAINSTEP); //*nnbpix);
        4:10936:  duu = (double *) malloc(sizeof(double)*nbolo*GAINSTEP); //*nnbpix);
        -:10937:
        4:10938:  dcoi = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        4:10939:  dcoq = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        4:10940:  dcou = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        -:10941:
        4:10942:  dfri = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        4:10943:  dfrq = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        4:10944:  dfru = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        -:10945:
        4:10946:  ddusti = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        4:10947:  ddustq = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        4:10948:  ddustu = (double *) malloc(sizeof(double)*nbolo*nnbpix);
        -:10949:
        4:10950:  dpixi = (double *) malloc(sizeof(double)*(npixbeam)*nbolo*nnbpix);
        4:10951:  dpixq = (double *) malloc(sizeof(double)*(npixbeam)*nbolo*nnbpix);
        4:10952:  dpixu = (double *) malloc(sizeof(double)*(npixbeam)*nbolo*nnbpix);
        -:10953:
        4:10954:  cdip= (double *) malloc(sizeof(double)*nbolo*GAINSTEP);
        4:10955:  cco= (double *) malloc(sizeof(double)*nbolo);
        4:10956:  ccfree= (double *) malloc(sizeof(double)*nbolo);
        4:10957:  ctheta= (double *) malloc(sizeof(double)*nbolo);
        4:10958:  cdust= (double *) malloc(sizeof(double)*nbolo);
        4:10959:  cpix= (double *) malloc(sizeof(double)*nbolo*(npixbeam+1));
        4:10960:  if (CUTRG>1) {
    #####:10961:    if (newnr2[nbolo]>newnr[nbolo]+nbolo*GAINSTEP) {
    #####:10962:      ctmp= (double *) malloc(sizeof(double)*(newnr2[nbolo]));
        -:10963:    }
        -:10964:  }
        4:10965:  else ctmp= (double *) malloc(sizeof(double)*(newnr[nbolo]+nbolo*GAINSTEP));
        -:10966:
        -:10967:
        -:10968:
        4:10969:  long l_off_nmatpix=0;
        -:10970:  {
        4:10971:    long rrk=0;
       20:10972:    for (rrk=0;rrk<mpi_size;rrk++) {
        -:10973:      long l_trans_nmatpix;
       16:10974:      if (rrk==rank) l_trans_nmatpix=l_nmatpix;
       16:10975:      MPI_Bcast(&l_trans_nmatpix,sizeof(long), MPI_BYTE, rrk, MPI_COMM_WORLD);
       16:10976:      if (rank>rrk) l_off_nmatpix+=l_trans_nmatpix;
        -:10977:    }
        -:10978:  }
        -:10979:
        4:10980:  if (rank==0) fprintf(stderr,"BEG-ED %d %ld %ld - %ld %ld\n",rank,(long) nmatpix,(long) begpix[rank],(long) edpix[rank],
        -:10981:          (long) l_nmatpix);
        4:10982:  MPI_Barrier(MPI_COMM_WORLD);
        -:10983:
        -:10984:  //double *tvec;
        -:10985:  //double *vvec;
        -:10986:  //double *totmat;
        -:10987:
        -:10988:  long l1;
        -:10989:
        -:10990:  // decoupe vecteur matrice par proc
        -:10991:#ifdef DORGG
        -:10992:  double *gtab2 = (double *) calloc (newnr[nbolo], sizeof (double));
        -:10993:#else
        4:10994:  double *gtab2 = (double *) calloc (GAINSTEP*nbolo, sizeof (double));
        -:10995:#endif
        -:10996:
        -:10997:
        4:10998:  long maxsizemat=newnr[nbolo]+nbolo*(GAINSTEPADU+npixbeam+1)+nmatco+nmatdust+nfreefree;
        4:10999:  if (GAINSTEP>GAINSTEPADU) maxsizemat=newnr[nbolo]+nbolo*(GAINSTEP+npixbeam+1)+nmatco+nmatdust+nfreefree;
        4:11000:  if (newnr2[nbolo]>maxsizemat&&CUTRG>(1)) {
    #####:11001:    maxsizemat=newnr2[nbolo];
        -:11002:  }
        4:11003:  if (rank==0) fprintf(stderr,"MAXSIZE %ld %ld\n",(long) maxsizemat,(long) newnr[nbolo]+nbolo*(GAINSTEP+npixbeam)+nmatco+nmatdust+nfreefree);
        -:11004:
        -:11005:
        -:11006:  //vvec=(double *) malloc((maxsizemat)*sizeof (double));
        -:11007:  //tvec=(double *) malloc((maxsizemat)*sizeof (double));
        -:11008:
        4:11009:  if (rank==0) fprintf(stderr,"NbGain %ld\n",newnr2[nbolo]);
        -:11010:
        -:11011:
        -:11012:    //if (Param->CALCODUST==1) {
        -:11013:    //  totmat=(double *) malloc(8*sizeof(double)*nnbpix);
        -:11014:    //}
        4:11015:    qmat=(double *) malloc(sizeof(double)*nnbpix);
        4:11016:    umat=(double *) malloc(sizeof(double)*nnbpix);
        -:11017:
        -:11018:#ifdef COMATOUT
        -:11019:    double *rcomat=(double *) malloc(sizeof(double)*nnbpix);
        -:11020:    double *co_mat=(double *) malloc(sizeof(double)*nnbpix);
        -:11021:    double *co_qmat=(double *) malloc(sizeof(double)*nnbpix);
        -:11022:    double *co_umat=(double *) malloc(sizeof(double)*nnbpix);
        -:11023:#endif
        -:11024:
        -:11025:
        -:11026:#ifdef DUSTMATOUT
        -:11027:    double *dust_mat=(double *) malloc(sizeof(double)*nnbpix);
        -:11028:    double *dust_qmat=(double *) malloc(sizeof(double)*nnbpix);
        -:11029:    double *dust_umat=(double *) malloc(sizeof(double)*nnbpix);
        -:11030:#endif
        4:11031:    x2 =     (double *) malloc (maxsizemat*sizeof (double));
        4:11032:    x2old =  (double *) malloc (maxsizemat*sizeof (double));
        4:11033:    x2init = (double *) malloc (maxsizemat*sizeof (double));
        4:11034:    b2 =     (double *) malloc (maxsizemat*sizeof (double));
        4:11035:    d2 =     (double *) malloc (maxsizemat*sizeof (double));
        4:11036:    q2 =     (double *) malloc (maxsizemat*sizeof (double));
        4:11037:    r2 =     (double *) malloc (maxsizemat*sizeof (double));
        4:11038:    s2 =     (double *) malloc (maxsizemat*sizeof (double));
        4:11039:    hit2 =   (double *) malloc (maxsizemat*sizeof (double));
        -:11040:
        -:11041:
        -:11042:    //if (Param->TESTPOL==-1) {
        -:11043:    //  for (i=0;i<Param->n_MAP;i++) {
        -:11044:    //  sprintf(mapout[i],"%s_I%d",Param->MAP[i],(int) nseed);
        -:11045:    //  if (rank==0) fprintf(stderr,"MAP %s\n",mapout[i]);
        -:11046:    //  }
        -:11047:    //}
        -:11048:    //else
        -:11049:    
        -:11050:
        -:11051:
        4:11052:    for (i=0;i<Param->n_MAP;i++) strcpy(mapout[i],Param->MAP[i]);
        -:11053:
        -:11054:
        4:11055:    if (rank==0) fprintf(stderr,"BEG %d %ld %ld - %ld %ld\n",rank,(long) nmatpix,(long) begpix[rank],(long) edpix[rank],
        -:11056:          (long) l_nmatpix);
        -:11057:
        4:11058:    MPI_Barrier(MPI_COMM_WORLD);
        -:11059:
        -:11060:
        -:11061:  /*======================================================
        -:11062:    =
        -:11063:    =    LOOP ON SEEDs
        -:11064:    =
        -:11065:    =*/
        -:11066:
        8:11067:  for (int iter = 0; iter < number_of_iterations; iter++) {
 50331652:11068:    for (k=0;k<nnbpix;k++)  {
 50331648:11069:      long ndata = loc_nhpix[k];
 50331648:11070:      hpix *htmp = loc_hpix[k];
        -:11071:      int l1;
        -:11072:      double l_th,l_ph;
 50331648:11073:      pix2ang_ring(Nside,k+begpix[rank],&l_th,&l_ph);
 50528033:11074:      for (l1=0;l1<ndata;l1++) {
   196385:11075:        htmp[l1].sig = htmp[l1].listp[iter];
        -:11076:      }
        -:11077:    }
        -:11078:
        4:11079:    itbogo=0;
        -:11080:
        -:11081:    /*======================================================
        -:11082:      =
        -:11083:      =    solve matrix
        -:11084:      =
        -:11085:      =*/
        -:11086:
        -:11087:    // ca plante pas
        4:11088:    memset(x2old  ,0,(maxsizemat)*sizeof (double));
        -:11089:
        -:11090:    /*======================================================
        -:11091:      =
        -:11092:      =    PUT to 0
        -:11093:      =
        -:11094:      =*/
        -:11095:
        -:11096:    // ca plante
        -:11097:    //if (Param->TESTPOL==-1) {
        -:11098:    //  for (k=0;k<nnbpix;k++)  {
        -:11099:    //    long ndata = loc_nhpix[k];
        -:11100:    //    hpix *htmp = loc_hpix[k];
        -:11101:    //    int l1;
        -:11102:    //    for (l1=0;l1<ndata;l1++) {
        -:11103:    //    htmp[l1].sig  = htmp[l1].dip+
        -:11104:    //      Param->NEP[htmp[l1].ib]/Param->Calibration[htmp[l1].ib]
        -:11105:    //      *sqrt(-2*log( drand48()))*cos(2*M_PI*drand48());
        -:11106:    //    }
        -:11107:    //  }
        -:11108:    //}
        -:11109:    // ca plante
        4:11110:    docutrg=nitbogo-1;
        -:11111:
        4:11112:    ittt=1;
        4:11113:    g=gtab2;
        4:11114:    memset(x2     ,0,maxsizemat*sizeof (double));
        4:11115:    memset(x2old  ,0,maxsizemat*sizeof (double));
        4:11116:    memset(x2init ,0,maxsizemat*sizeof (double));
        4:11117:    memset(b2     ,0,maxsizemat*sizeof (double));
        4:11118:    memset(d2     ,0,maxsizemat*sizeof (double));
        4:11119:    memset(q2     ,0,maxsizemat*sizeof (double));
        4:11120:    memset(r2     ,0,maxsizemat*sizeof (double));
        4:11121:    memset(s2     ,0,maxsizemat*sizeof (double));
        4:11122:    memset(hit2   ,0,maxsizemat*sizeof (double));
        -:11123:  #if DORGG
        -:11124:    for (i=0;i<newnr[nbolo];i++) g[i]=1.;
        -:11125:  #else
        4:11126:    for (i=0;i<GAINSTEP*nbolo;i++) g[i]=1.;
        -:11127:  #endif
        -:11128:
        4:11129:    nadu=GAINSTEPADU;
        -:11130:#if 0
        -:11131:    double *reshisto=(double *) malloc(sizeof(double)*GAINSTEPADU*nbolo);
        -:11132:    memset(reshisto,0,sizeof(double)*GAINSTEPADU*nbolo);
        -:11133:
        -:11134:    if (rank==0) {
        -:11135:      fprintf(stderr,"NADU %ld\n", (long) nadu);
        -:11136:    }
        -:11137:    PrintFreeMemOnNodes( rank, mpi_size, "before solving matrix");
        -:11138:#endif
        -:11139:
        4:11140:    MPI_Barrier(MPI_COMM_WORLD);
        -:11141:    // Exchange dip against sig in the XI2
        -:11142:
        -:11143:
 50331652:11144:    for (k=0;k<nnbpix;k++)  {
 50331648:11145:      long ndata = loc_nhpix[k];
 50331648:11146:      hpix *htmp = loc_hpix[k];
 50331648:11147:      II[k]=0;
 50331648:11148:      IQ[k]=0;
 50331648:11149:      IU[k]=0;
 50331648:11150:      QQ[k]=0;
 50331648:11151:      UU[k]=0;
 50331648:11152:      QU[k]=0;
        -:11153:
 50528033:11154:      for (l1=0;l1<ndata;l1++) {
   196385:11155:        long ri1=htmp[l1].rg-globalBeginRing;
        -:11156:
   392770:11157:        double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
   196385:11158:                                          -dpsisi[htmp[l1].ib]*htmp[l1].si);
   392770:11159:        double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
   196385:11160:                                          +dpsisi[htmp[l1].ib]*htmp[l1].co);
   196385:11161:        if (flg_rg[htmp[l1].ib][ri1]!=0) {
   196385:11162:          II[k]+=htmp[l1].w;
   196385:11163:          IQ[k]+=htmp[l1].w*CO1;
   196385:11164:          IU[k]+=htmp[l1].w*SI1;
   196385:11165:          QQ[k]+=htmp[l1].w*CO1*CO1;
   196385:11166:          QU[k]+=htmp[l1].w*SI1*CO1;
   196385:11167:          UU[k]+=htmp[l1].w*SI1*SI1;
        -:11168:        }
        -:11169:      }
 50331648:11170:      if (ndata>0&&flgpix[k]>0) {
        -:11171:
    19487:11172:        double SI=0;
    19487:11173:        double SQ=0;
    19487:11174:        double SU=0;
    89281:11175:        for (l1=0;l1<ndata;l1++) {
    69794:11176:          long ri1=htmp[l1].rg-globalBeginRing;
        -:11177:
   139588:11178:          double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    69794:11179:                                            -dpsisi[htmp[l1].ib]*htmp[l1].si);
   139588:11180:          double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    69794:11181:                                            +dpsisi[htmp[l1].ib]*htmp[l1].co);
    69794:11182:          if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -:11183:
    69794:11184:            SI+=htmp[l1].w*(htmp[l1].dip+htmp[l1].fsl);
    69794:11185:            SQ+=htmp[l1].w*(htmp[l1].dip+htmp[l1].fsl)*CO1;
    69794:11186:            SU+=htmp[l1].w*(htmp[l1].dip+htmp[l1].fsl)*SI1;
        -:11187:
        -:11188:
        -:11189:  #ifdef UPDATE_DIP
        -:11190:            double tmp=htmp[l1].sig-htmp[l1].fsl;
        -:11191:            matdip[iri1*4]  +=htmp[l1].w*htmp[l1].dip*htmp[l1].dip;
        -:11192:            matdip[iri1*4+1]+=htmp[l1].w*htmp[l1].dip;
        -:11193:            matdip[iri1*4+2]+=htmp[l1].w*htmp[l1].dip;
        -:11194:            matdip[iri1*4+3]+=htmp[l1].w;
        -:11195:            vecdip[iri1*2]  +=htmp[l1].w*tmp*htmp[l1].dip;
        -:11196:            vecdip[iri1*2+1]+=htmp[l1].w*tmp;
        -:11197:  #endif
        -:11198:
        -:11199:          }
        -:11200:        }
        -:11201:
    19487:11202:        solvemap(&SI,&SQ,&SU,II[k],IQ[k],IU[k],QQ[k],QU[k],UU[k]);
        -:11203:
    19487:11204:        SSI2[k]=SI;
    19487:11205:        SSQ2[k]=SQ;
    19487:11206:        SSU2[k]=SU;
        -:11207:      }
        -:11208:    }
        -:11209:
        4:11210:    double *gain = (double *) malloc(sizeof(double)*nbolo*GAINSTEP);
        -:11211:
       20:11212:    for (i=0;i<nbolo;i++) {
       16:11213:      for (j=0;j<GAINSTEP;j++) gain[i*GAINSTEP+j]=1; //+3E-3*i+1E-3*cos(j/4.);
        -:11214:    }
        -:11215:
        4:11216:    memset(x2,0,(newnr[nbolo]+nbolo*npixbeam+nmatco+nmatdust+nfreefree)*sizeof(double));
        -:11217:
        4:11218:    double *xoff= (double *) malloc(sizeof(double)*newnr2[nbolo]);
        -:11219:
        4:11220:    gainoff=0;
        -:11221:
        4:11222:    if (GAINSTEP<GAINSTEPADU) nmatres=newnr[nbolo]+nbolo*(GAINSTEPADU+npixbeam)+nmatdust+nmatco+nfreefree;
    #####:11223:    else nmatres=newnr[nbolo]+nbolo*(GAINSTEP+npixbeam)+nmatdust+nmatco+nfreefree;
        -:11224:
        4:11225:    double *x3= (double *) malloc(sizeof(double)*(nmatres+nbolo)); //+nbolo in case of fittetha
        -:11226:
        4:11227:    GetProcMem(&vmem,&phymem);
        6:11228:    if (rank==0) fprintf(stderr,"Rank: %ld[%d] MEM %.1lf[%.1lf]MB line=%d\n",
        -:11229:                (long) rank, getpid(),
        1:11230:                (double) vmem/1024./1024.,
        1:11231:                (double) phymem/1024./1024.,__LINE__);
        -:11232:    int itt;
        -:11233:
        4:11234:    memset(x3,0,sizeof(double)*nmatres);
        -:11235:
        4:11236:    itt=0;
        4:11237:    double resxi=1;
       48:11238:    while (itt<Param->NITT) {
        -:11239:
       40:11240:      memset(newnr[nbolo]+x3,0,sizeof(double)*nbolo*GAINSTEP);
        -:11241:
       40:11242:      if (Param->OUT_NOPOL[0]%2==1) minimize_gain_nopol(x3,gain);
    #####:11243:      else minimize_gain_gi(x3,gain);
        -:11244:
       40:11245:      resxi=0;
      200:11246:      for (i=0;i<nbolo;i++){
      320:11247:	for (j=0;j<GAINSTEP;j++) {
      160:11248:	  resxi+=x3[newnr[nbolo]+i*GAINSTEP+j]*x3[newnr[nbolo]+i*GAINSTEP+j];
        -:11249:	}
        -:11250:      }
       40:11251:      resxi/=(nbolo*GAINSTEP);
        -:11252:
       40:11253:      if (COMP_CNN>0&&itt>=Param->CNN_START) { //itt>=2&&itt<Param->NITT-2) {
       40:11254:	GetProcMem(&vmem,&phymem);
       60:11255:	if (rank==0) fprintf(stderr,"Rank: %ld Line=%d MEM %.1lf[%.1lf]MB\n",
        -:11256:			     (long) rank, __LINE__,
       10:11257:			     (double) vmem/1024./1024.,
       10:11258:			     (double) phymem/1024./1024.);
        -:11259:	//fit_cnn2d_rg(x3,gain);
       40:11260:	fit_cnn(x3,gain,itt-Param->CNN_START);
       60:11261:	if (rank==0) fprintf(stderr,"Rank: %ld Line=%d MEM %.1lf[%.1lf]MB\n",
        -:11262:			     (long) rank, __LINE__,
       10:11263:			     (double) vmem/1024./1024.,
       10:11264:			     (double) phymem/1024./1024.);
        -:11265:      }
        -:11266:
        -:11267:// when we start to use fit_adu_nl?
        -:11268:// it seems that does not really matter
        -:11269:// on sims consistent resutls
        -:11270://      if (DODISTOR!=0&&itt>=3) {
       40:11271:      if (DODISTOR!=0&&itt>0) {
        -:11272:
        -:11273:// OLD USAGE OF NLTEMP, NOW COMPUTES THE CORRECTION FOR TRACABILITY
        -:11274://=================================================================
        -:11275:// ltemp : equal to the average correction x=adu, y=ringindex
        -:11276://corr_nl is the variabile used
        -:11277:// nltemp could be removed
       36:11278:	double *nltemp = (double *) malloc(sizeof(double)*nbolo*320*320);
       36:11279:	double *ltemp = (double *) malloc(sizeof(double)*nbolo*320*320);
       36:11280:	fit_adu_nl_opt(x3,gain,ltemp,nltemp);
        -:11281:
       36:11282:	if (rank==0) {
        -:11283:	  PIOSTRING saveg;
        9:11284:	  sprintf(saveg,"%s_%d_%d_CORRNL",Param->Out_Offset[0],stim_first_seed+iter,itt);
        9:11285:	  fprintf(stderr,"Write CORRNL  %lld\n",(long long) (PIOWriteVECT(saveg,ltemp,0,sizeof(PIODOUBLE)*(nbolo*320*320)))/sizeof(double));
        9:11286:	  fprintf(stderr,"Write CORRNL  %lld\n",(long long) (PIOWriteVECT(saveg,nltemp,sizeof(PIODOUBLE)*(nbolo*320*320),
        -:11287:									  sizeof(PIODOUBLE)*(nbolo*320*320)))/sizeof(double));
        -:11288:	}
       36:11289:	free(ltemp);
       36:11290:	free(nltemp);
        -:11291:
        -:11292:      }
      200:11293:      for (i=0;i<nbolo;i++){
      320:11294:	for (j=0;j<GAINSTEP;j++) {
      160:11295:	  if (itt<Param->NITT-1) gain[i*GAINSTEP+j]-=x3[newnr[nbolo]+i*GAINSTEP+j];
        -:11296:	}
        -:11297:      }
        -:11298:
        -:11299:
       40:11300:      if (rank==0) {
       10:11301:        fprintf(stderr,"GI XIGAIN %.10lg\n",sqrt(resxi));
      210:11302:	for (i=GAINSTEP*nbolo+newnr[nbolo];i<(GAINSTEP+npixbeam-DOFITANGLE-DOFITPOLEFF-DOTDUST-DOCO13-DOSYNCHRO)*nbolo+newnr[nbolo];i++) {
      200:11303:	  if ((i-newnr[nbolo])%nbolo==0) fprintf(stderr,"TF=[");
      200:11304:	  fprintf(stderr,"%lg,",x3[i]);
      200:11305:	  if ((i-newnr[nbolo])%nbolo==nbolo-1) fprintf(stderr,"]\n");
        -:11306:	}
        -:11307:
       10:11308:	if (DOFITANGLE==1) {
       10:11309:	  fprintf(stderr,"polang=[");
       10:11310:	  for (i=0;i<nbolo-1;i++) fprintf(stderr,"%lg,",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam-(1+DOCO13+DOSYNCHRO+DOTDUST+DOFITPOLEFF))+i]);
       10:11311:	  fprintf(stderr,"%lg]\n",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam-(1+DOCO13+DOSYNCHRO+DOTDUST+DOFITPOLEFF))+nbolo-1]);
        -:11312:	}
       10:11313:	if (DOFITPOLEFF==1) {
       10:11314:	  fprintf(stderr,"poleff=[");
       10:11315:	  for (i=0;i<nbolo-1;i++) fprintf(stderr,"%lg,",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam-(1+DOCO13+DOSYNCHRO+DOTDUST))+i]);
       10:11316:	  fprintf(stderr,"%lg]\n",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam-(1+DOCO13+DOSYNCHRO+DOTDUST))+nbolo-1]);
        -:11317:	}
       10:11318:	if (DOCO13==1) {
       10:11319:	  fprintf(stderr,"co13=[");
       10:11320:	  for (i=0;i<nbolo-1;i++) fprintf(stderr,"%lg,",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam-(1+DOSYNCHRO))+i]);
       10:11321:	  fprintf(stderr,"%lg]\n",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam-(1+DOSYNCHRO))+nbolo-1]);
        -:11322:	}
       10:11323:        if (nmatco>0) {
       10:11324:	  fprintf(stderr,"co12=[");
       10:11325:	  for (i=0;i<nbolo-1;i++) fprintf(stderr,"%lg,",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam)+i]);
       10:11326:	  fprintf(stderr,"%lg]\n",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam)+nbolo-1]);
        -:11327:	}
       10:11328:        if (nfreefree>0) {
    #####:11329:	  fprintf(stderr,"freefree=[");
    #####:11330:	  for (i=0;i<nbolo-1;i++) fprintf(stderr,"%lg,",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam)+nmatco+nmatdust+i]);
    #####:11331:	  fprintf(stderr,"%lg]\n",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam)+nmatco+nmatdust+nbolo-1]);
        -:11332:	}
       10:11333:        if (nmatdust>0) {
       10:11334:	  fprintf(stderr,"dust=[");
       10:11335:	  for (i=0;i<nbolo-1;i++) fprintf(stderr,"%lg,",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam)+nmatco+i]);
       10:11336:	  fprintf(stderr,"%lg]\n",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam)+nmatco+nbolo-1]);
        -:11337:	}
       10:11338:	if (DOTDUST==1) {
    #####:11339:	  fprintf(stderr,"tdust=[");
    #####:11340:	  for (i=0;i<nbolo-1;i++) fprintf(stderr,"%lg,",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam-(1+DOSYNCHRO+DOCO13))+i]);
    #####:11341:	  fprintf(stderr,"%lg]\n",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam-(1+DOSYNCHRO+DOCO13))+nbolo-1]);
        -:11342:	}
       10:11343:	if (DOSYNCHRO==1) {
    #####:11344:	  fprintf(stderr,"sync=[");
    #####:11345:	  for (i=0;i<nbolo-1;i++) fprintf(stderr,"%lg,",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam-1)+i]);
    #####:11346:	  fprintf(stderr,"%lg]\n",x3[newnr[nbolo]+nbolo*(GAINSTEP+npixbeam-1)+nbolo-1]);
        -:11347:	}
        -:11348:      }
        -:11349:
       40:11350:      itt++;
       40:11351:      MPI_Barrier(MPI_COMM_WORLD);
        -:11352:    }
        -:11353:
        4:11354:    if (CUTRG>1) {
    #####:11355:      minimize_optimize(x3,xoff,gain);
        -:11356:    }
        -:11357:
        4:11358:    MPI_Barrier(MPI_COMM_WORLD);
        -:11359:
        4:11360:    nmatres=newnr[nbolo]+nbolo*(GAINSTEP+npixbeam)+nmatdust+nmatco+nfreefree;
        4:11361:    if (rank==0) {
        -:11362:
        -:11363:      PIOSTRING commm;
        -:11364:      PIOSTRING saveg;
        -:11365:      // Write offset
        1:11366:      PIODOUBLE *tmpoff = (PIODOUBLE *) malloc(sizeof(PIODOUBLE)*(globalRangeRing));
        -:11367:
        5:11368:      for (i=0;i<nbolo;i++) {
        4:11369:        sprintf(commm,"begin=%lld;end=%lld",(long long) globalBeginRing,(long long) globalEndRing);
     1040:11370:        for (j=0;j<globalRangeRing;j++) {
     1036:11371:          tmpoff[j]=-10000;
        -:11372:        }
        4:11373:        for (j=newnr[i];j<newnr[i+1];j++) tmpoff[rgordinv[i][j-newnr[i]]]=x3[j];
        4:11374:        if (stim_first_seed+iter==0) sprintf(saveg,"%s_OFF",Param->Out_Offset[i]);
    #####:11375:        else sprintf(saveg,"%s_%d_OFF",Param->Out_Offset[i],stim_first_seed+iter);
        -:11376:
        4:11377:        fprintf(stderr,"Write OFF  %lld\n",(long long) PIOWriteVECT(saveg,tmpoff,sizeof(PIODOUBLE)*globalBeginRing,sizeof(PIODOUBLE)*(globalRangeRing)));
        -:11378:
        4:11379:        for (j=0;j<globalRangeRing;j++) tmpoff[j]=gain[invgi[j+globalBeginRing+i*32000]+GAINSTEP*i];
        4:11380:        if (stim_first_seed+iter==0) sprintf(saveg,"%s_GAIN",Param->Out_Offset[i]);
    #####:11381:        else sprintf(saveg,"%s_%d_GAIN",Param->Out_Offset[i],stim_first_seed+iter);
        -:11382:
        4:11383:        fprintf(stderr,"Write GAIN  %lld\n",(long long) PIOWriteVECT(saveg,tmpoff,sizeof(PIODOUBLE)*globalBeginRing,sizeof(PIODOUBLE)*(globalRangeRing)));
        -:11384:
        4:11385:        if (CUTRG>1) {
    #####:11386:          PIODOUBLE *tmpcutoff = (PIODOUBLE *) malloc(sizeof(PIODOUBLE)*(globalRangeRing)*CUTRG);
    #####:11387:          for (j=0;j<CUTRG*(globalRangeRing);j++) {
    #####:11388:            tmpcutoff[j]=-10000;
        -:11389:          }
    #####:11390:          if (stim_first_seed+iter==0) sprintf(saveg,"%s_X3",Param->Out_Offset[i]);
    #####:11391:          else sprintf(saveg,"%s_%d_X3",Param->Out_Offset[i],stim_first_seed+iter);
        -:11392:
    #####:11393:          for (j=newnr2[i];j<newnr2[i+1];j++) tmpcutoff[rgordinv2[i][j-newnr2[i]]]=xoff[j];
    #####:11394:          fprintf(stderr,"Save X3 CUTRG\n");
    #####:11395:          sprintf(commm,"begin=%lld;end=%lld",(long long) globalBeginRing*CUTRG,(long long) globalEndRing*CUTRG);
    #####:11396:          fprintf(stderr,"Write OPTOFF  %lld\n",(long long) PIOWriteVECT(saveg,tmpcutoff,globalBeginRing*CUTRG*sizeof(PIODOUBLE),
        -:11397:                                                                         (globalRangeRing)*CUTRG*sizeof(PIODOUBLE)));
    #####:11398:          free(tmpcutoff);
        -:11399:        }
        -:11400:      }
        1:11401:      free(tmpoff);
        -:11402:
        1:11403:      if (stim_first_seed+iter==0) sprintf(saveg,"%s_X2",Param->Out_Offset[0]);
    #####:11404:      else sprintf(saveg,"%s_%d_X2",Param->Out_Offset[0],stim_first_seed+iter);
        -:11405:
        -:11406:      //for (i=newnr[nbolo]+GAINSTEP*nbolo;i<nmatres;i++) fprintf(stderr,"X2 %d %lg\n",(int) i,x3[i]);
        1:11407:      fprintf(stderr,"Save X2 NO CUTRG\n");
        1:11408:      fprintf(stderr,"Write MAT  %lld\n",(long long) PIOWriteVECT(saveg,x3+newnr[nbolo],0,(nbolo*(GAINSTEP+npixbeam)+nmatdust+nmatco+nfreefree)*sizeof(PIODOUBLE)));
        -:11409:
        -:11410:    }
        -:11411:
        4:11412:    double avvgain=0;
        4:11413:    for (i=0;i<nbolo*GAINSTEP;i++) avvgain+=x3[newnr[nbolo]+i];
        4:11414:    avvgain/=((double)(nbolo*GAINSTEP));
        -:11415:
        -:11416:
        4:11417:    if (rank==0)  {
        1:11418:      fprintf(stderr,"AVVGAIN: %lf\n",avvgain);
        -:11419:    }
        -:11420:
        4:11421:    if (number_of_iterations==iter+1) {
        4:11422:      free(x2);
        4:11423:      free(x2old);
        4:11424:      free(x2init);
        4:11425:      free(b2);
        4:11426:      free(d2);
        4:11427:      free(q2);
        4:11428:      free(r2);
        4:11429:      free(s2);
        4:11430:      free(hit2);
        -:11431:
        4:11432:      free(dthetai );
        4:11433:      free(dthetaq );
        4:11434:      free(dthetau );
        4:11435:      free(dii     );
        4:11436:      free(dqq     );
        4:11437:      free(duu     );
        4:11438:      free(dcoi );
        4:11439:      free(dcoq );
        4:11440:      free(dcou );
        4:11441:      free(dfri );
        4:11442:      free(dfrq );
        4:11443:      free(dfru );
        4:11444:      free(ddusti);
        4:11445:      free(ddustq);
        4:11446:      free(ddustu);
        4:11447:      free(dpixi );
        4:11448:      free(dpixq );
        4:11449:      free(dpixu );
        4:11450:      free(cdip );
        4:11451:      free(cco);
        4:11452:      free(ccfree);
        4:11453:      free(ctheta);
        4:11454:      free(cdust);
        4:11455:      free(cpix );
        4:11456:      free(ctmp);
        -:11457:    }
        -:11458:
        4:11459:    MPI_Barrier(MPI_COMM_WORLD);
        4:11460:    if (rank%64==0) {
        1:11461:      GetProcMem(&vmem,&phymem);
        2:11462:      fprintf(stderr,"Rank: %ld[%d] MEM %.1lf[%.1lf]MB line=%d\n",
        -:11463:                (long) rank, getpid(),
        1:11464:                (double) vmem/1024./1024.,
        1:11465:                (double) phymem/1024./1024.,__LINE__);
        -:11466:    }
        -:11467:
        -:11468:    /*======================================================
        -:11469:      =
        -:11470:      =    build maps
        -:11471:      =
        -:11472:      =*/
        -:11473:
        -:11474:    double *MAPS_CORR[3]; // corrected I, Q, U maps
        -:11475:    double *MAPS_COV[7];  // corresponding II, IQ, IU, QQ, QU, UU, HH covariance matrix
        -:11476:
        4:11477:    double **MAPS_CORR_CO   = (double **) malloc(sizeof(double *)*nbolo*3); // corrected I, Q, U, 12CO=C1, 13CO=C2 maps
        4:11478:    double **MAPS_CORR_DUST = (double **) malloc(sizeof(double *)*nbolo*3); // corrected I, Q, U, 12CO=C1, 13CO=C2 maps
        4:11479:    double **MAPS_COV_DUST  = (double **) malloc(sizeof(double *)*nbolo*6); // corrected II, IQ, IU, IC1, IC2, QQ, QU, UU covariance matrix
        -:11480:
       32:11481:    for (i=0; i<7; i++) {
       28:11482:      MAPS_COV[i] = (double *) malloc(sizeof(double)*nnbpix);
       28:11483:      assert( MAPS_COV[i] != NULL);
        -:11484:    }
       16:11485:    for (i=0; i<3; i++) {
       12:11486:      MAPS_CORR[i] = (double *) malloc(sizeof(double)*nnbpix);
       12:11487:      assert( MAPS_CORR[i] != NULL);
        -:11488:    }
        -:11489:
       24:11490:    for (int detset=0; detset<Param->n_MAP; detset++) {
        -:11491:      // convert MAPRINGS codes to list of survey maps to produce
       20:11492:      long surveys = 0; // one bit in <surveys> = one map to produce
        -:11493:      PIOSTRING mapname; // map name suffix describing the ring range / survey
       20:11494:      int isurv = 0; // to know if we're in the first loop iteration
       20:11495:      long current_survey = 0; // currently processed survey bit
        -:11496:
       20:11497:      if (Param->MAPRINGS[detset] & FULL) {
       20:11498:        surveys += MAPFULL;
        -:11499:      }
       20:11500:      if (Param->MAPRINGS[detset] & HM12) {
        4:11501:        surveys += HM1 + HM2;
        -:11502:      }
       20:11503:      if (Param->MAPRINGS[detset] & S12345) {
    #####:11504:        surveys += S1 + S2 + S3 + S4 + S5;
        -:11505:      }
       20:11506:      if (Param->MAPRINGS[detset] & YEAR12) {
    #####:11507:        surveys += YEAR1 + YEAR2;
        -:11508:      }
       20:11509:      if (Param->MAPRINGS[detset] & FULLODDEVEN) {
        4:11510:        surveys += FULLODD + FULLEVEN;
        -:11511:      }
       20:11512:      if (Param->MAPRINGS[detset] & HM12ODDEVEN) {
    #####:11513:        surveys += HM1ODD + HM1EVEN + HM2ODD + HM2EVEN;
        -:11514:      }
        -:11515:
       76:11516:      while (surveys != 0) {
        -:11517:	//===================================================================
        -:11518:	// COMPUTE CO MAP IF DETSET=0
        -:11519:
       36:11520:	if (detset==0&&surveys & MAPFULL) {
      100:11521:	  for (i=0; i<6*nbolo; i++) {
       96:11522:	    MAPS_COV_DUST[i] = (double *) malloc(sizeof(double)*nnbpix);
       96:11523:	    memset(MAPS_COV_DUST[i],0,sizeof(double)*nnbpix);
       96:11524:	    assert( MAPS_COV_DUST[i] != NULL);
        -:11525:	  }
       52:11526:	  for (i=0; i<3*nbolo; i++) {
       48:11527:	    MAPS_CORR_CO[i] = (double *) malloc(sizeof(double)*nnbpix);
       48:11528:	    memset(MAPS_CORR_CO[i],0,sizeof(double)*nnbpix);
       48:11529:	    assert( MAPS_CORR_CO[i] != NULL);
        -:11530:	  }
       52:11531:	  for (i=0; i<3*nbolo; i++) {
       48:11532:	    MAPS_CORR_DUST[i] = (double *) malloc(sizeof(double)*nnbpix);
       48:11533:	    memset(MAPS_CORR_DUST[i],0,sizeof(double)*nnbpix);
       48:11534:	    assert( MAPS_CORR_DUST[i] != NULL);
        -:11535:	  }
        -:11536:	}
       36:11537:        int nside_out = Param->Nside;
       36:11538:        int reduced_nside = nside_out;
       36:11539:        if (nside_out == 2048) {
        -:11540:          // reduced_nside is used to reduce nside for maps with bad conditioning
       36:11541:          reduced_nside = 1024;
        -:11542:        }
      144:11543:        for (i=0; i<3; i++) {
      108:11544:          memset(MAPS_CORR[i],0,sizeof(double)*nnbpix);
        -:11545:        }
      288:11546:        for (i=0; i<7; i++) {
      252:11547:          memset(MAPS_COV[i],0,sizeof(double)*nnbpix);
        -:11548:        }
       36:11549:        GetProcMem(&vmem,&phymem);
       54:11550:        if (rank%64==0) fprintf(stderr,"Rank: %ld[%d] MEM %.1lf[%.1lf]MB line=%d\n",
        -:11551:                                (long) rank, getpid(),
        9:11552:                                (double) vmem/1024./1024.,
        9:11553:                                (double) phymem/1024./1024.,__LINE__);
        -:11554:
       36:11555:        MPI_Barrier(MPI_COMM_WORLD);
        -:11556:
       36:11557:        if (surveys & MAPFULL) {
       20:11558:          current_survey = MAPFULL;
       20:11559:          strcpy( mapname, "full");
        -:11560:
       16:11561:        } else if (surveys & HM1) {
        4:11562:          current_survey = HM1;
        4:11563:          strcpy( mapname, "hm1");
        4:11564:          if (singleFreq == 100) nside_out = reduced_nside;
        -:11565:
       12:11566:        } else if (surveys & HM2) {
        4:11567:          current_survey = HM2;
        4:11568:          strcpy( mapname, "hm2");
        4:11569:          if (singleFreq == 100) nside_out = reduced_nside;
        -:11570:
        8:11571:        } else if (surveys & S1) {
    #####:11572:          current_survey = S1;
    #####:11573:          strcpy( mapname, "s1");
        -:11574:
        8:11575:        } else if (surveys & S2) {
    #####:11576:          current_survey = S2;
    #####:11577:          strcpy( mapname, "s2");
        -:11578:
        8:11579:        } else if (surveys & S3) {
    #####:11580:          current_survey = S3;
    #####:11581:          strcpy( mapname, "s3");
        -:11582:
        8:11583:        } else if (surveys & S4) {
    #####:11584:          current_survey = S4;
    #####:11585:          strcpy( mapname, "s4");
        -:11586:
        8:11587:        } else if (surveys & S5) {
    #####:11588:          current_survey = S5;
    #####:11589:          strcpy( mapname, "s5");
        -:11590:
        8:11591:        } else if (surveys & YEAR1) {
    #####:11592:          current_survey = YEAR1;
    #####:11593:          strcpy( mapname, "year1");
        -:11594:
        8:11595:        } else if (surveys & YEAR2) {
    #####:11596:          current_survey = YEAR2;
    #####:11597:          strcpy( mapname, "year2");
        -:11598:
        8:11599:        } else if (surveys & FULLODD) {
        4:11600:          current_survey = FULLODD;
        4:11601:          strcpy( mapname, "fullodd");
        -:11602:
        4:11603:        } else if (surveys & FULLEVEN) {
        4:11604:          current_survey = FULLEVEN;
        4:11605:          strcpy( mapname, "fulleven");
        -:11606:
    #####:11607:        } else if (surveys & HM1ODD) {
    #####:11608:          current_survey = HM1ODD;
    #####:11609:          strcpy( mapname, "hm1odd");
    #####:11610:          nside_out = reduced_nside;
        -:11611:
    #####:11612:        } else if (surveys & HM1EVEN) {
    #####:11613:          current_survey = HM1EVEN;
    #####:11614:          strcpy( mapname, "hm1even");
    #####:11615:          nside_out = reduced_nside;
        -:11616:
    #####:11617:        } else if (surveys & HM2ODD) {
    #####:11618:          current_survey = HM2ODD;
    #####:11619:          strcpy( mapname, "hm2odd");
    #####:11620:          nside_out = reduced_nside;
        -:11621:
    #####:11622:        } else if (surveys & HM2EVEN) {
    #####:11623:          current_survey = HM2EVEN;
    #####:11624:          strcpy( mapname, "hm2even");
    #####:11625:          nside_out = reduced_nside;
        -:11626:        }
       36:11627:        surveys &= ~current_survey; // clear current_survey bit
        -:11628:
452984868:11629:        for (k=0; k<nnbpix; k++) { // for each pixel in the rank
452984832:11630:          long ndata = loc_nhpix[k];
        -:11631:          long m;
452984832:11632:          hpix *htmp = loc_hpix[k];
        -:11633:          long ri,ri2;
        -:11634:
454752297:11635:          for (i=0;i<ndata;i++) {
  1767465:11636:            ri=htmp[i].rg-globalBeginRing;
  1767465:11637:            ri2=htmp[i].hrg-globalBeginRing*CUTRG;
  1767465:11638:            ib=htmp[i].ib;
        -:11639:
        -:11640:            // select only bolometers in detset
  1767465:11641:            int use_bolo = Param->bolomask[detset*nbolo+ib];
        -:11642:
  1767465:11643:            if (use_bolo) {
        -:11644:              // and select only needed rings
  1178310:11645:              switch (current_survey) {
   196385:11646:                case HM1:
   196385:11647:                  if (htmp[i].surv > 10) use_bolo = 0;
   196385:11648:                  break;
   196385:11649:                case HM2:
   196385:11650:                  if (htmp[i].surv < 10) use_bolo = 0;
   196385:11651:                  break;
    #####:11652:                case S1:
    #####:11653:                  if (htmp[i].surv%10 != 1) use_bolo = 0;
    #####:11654:                  break;
    #####:11655:                case S2:
    #####:11656:                  if (htmp[i].surv%10 != 2) use_bolo = 0;
    #####:11657:                  break;
    #####:11658:                case S3:
    #####:11659:                  if (htmp[i].surv%10 != 3) use_bolo = 0;
    #####:11660:                  break;
    #####:11661:                case S4:
    #####:11662:                  if (htmp[i].surv%10 != 4) use_bolo = 0;
    #####:11663:                  break;
    #####:11664:                case S5:
    #####:11665:                  if (htmp[i].surv%10 != 5) use_bolo = 0;
    #####:11666:                  break;
    #####:11667:                case YEAR1:
    #####:11668:                  if (htmp[i].surv%10!=1 && htmp[i].surv%10!=2) use_bolo=0;
    #####:11669:                  break;
    #####:11670:                case YEAR2:
    #####:11671:                  if (htmp[i].surv%10!=3 && htmp[i].surv%10!=4) use_bolo=0;
    #####:11672:                  break;
   196385:11673:                case FULLODD:
   196385:11674:                  if (htmp[i].rg%2 == 0) use_bolo = 0;
   196385:11675:                  break;
   196385:11676:                case FULLEVEN:
   196385:11677:                  if (htmp[i].rg%2 == 1) use_bolo = 0;
   196385:11678:                  break;
    #####:11679:                case HM1ODD:
    #####:11680:                  if (htmp[i].surv > 10) use_bolo = 0;
    #####:11681:                  if (htmp[i].rg%2 == 0) use_bolo = 0;
    #####:11682:                  break;
    #####:11683:                case HM1EVEN:
    #####:11684:                  if (htmp[i].surv > 10) use_bolo = 0;
    #####:11685:                  if (htmp[i].rg%2 == 1) use_bolo = 0;
    #####:11686:                  break;
    #####:11687:                case HM2ODD:
    #####:11688:                  if (htmp[i].surv < 10) use_bolo = 0;
    #####:11689:                  if (htmp[i].rg%2 == 0) use_bolo = 0;
    #####:11690:                  break;
    #####:11691:                case HM2EVEN:
    #####:11692:                  if (htmp[i].surv < 10) use_bolo = 0;
    #####:11693:                  if (htmp[i].rg%2 == 1) use_bolo = 0;
        -:11694:              }
        -:11695:            }
        -:11696:
  1767465:11697:            if (flg_rg[ib][ri]!=0 && use_bolo==1) {
   785540:11698:              ri=rgord[ib][ri]+newnr[htmp[i].ib];
   785540:11699:              if (CUTRG>1) {
    #####:11700:                ri2=rgord2[ib][ri2]+newnr2[htmp[i].ib];
        -:11701:              }
   785540:11702:              double gg2 = gain[htmp[i].gi+htmp[i].ib*GAINSTEP];
   785540:11703:              double sig_corr = htmp[i].sig*gg2-htmp[i].fsl-htmp[i].corr_nl-htmp[i].corr_cnn;
  1571080:11704:              double CO1 = eta[htmp[i].ib]*(dpsico[htmp[i].ib]*htmp[i].co
   785540:11705:                           - dpsisi[htmp[i].ib]*htmp[i].si);
  1571080:11706:              double SI1 = eta[htmp[i].ib]*(dpsico[htmp[i].ib]*htmp[i].si
   785540:11707:                           + dpsisi[htmp[i].ib]*htmp[i].co);
   785540:11708:              if (REMHDIP==0) {
    #####:11709:                sig_corr -= htmp[i].dip;
        -:11710:              }
        -:11711:              else {
   785540:11712:                sig_corr -= htmp[i].freefree;
        -:11713:              }
        -:11714:
   785540:11715:              if (CUTRG>1) {
    #####:11716:                sig_corr-=xoff[ri2];
        -:11717:              }
        -:11718:              else {
   785540:11719:                sig_corr-=x3[ri];
        -:11720:              }
        -:11721:
   785540:11722:              sig_corr-=x3[newnr[nbolo]+htmp[i].gi+htmp[i].ib*GAINSTEP]*htmp[i].model;
        -:11723:
   785540:11724:              double bandpass=0;
   785540:11725:              double pbandpass=0;
        -:11726:
   785540:11727:              if (nmatco!=0) {
   785540:11728:                bandpass+=htmp[i].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[i].ib];
        -:11729:              }
   785540:11730:              if (nmatdust!=0) {
   785540:11731:                bandpass+=htmp[i].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[i].ib];
   785540:11732:                pbandpass+=htmp[i].pdustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[i].ib];
        -:11733:              }
   785540:11734:              if (nfreefree!=0) {
    #####:11735:                bandpass+=htmp[i].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[i].ib];
        -:11736:              }
        -:11737:
   785540:11738:	      sig_corr-=bandpass;
        -:11739:
  7069860:11740:              for (m=0;m<npixbeam;m++)  {
  6284320:11741:                sig_corr -= htmp[i].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[i].ib];
        -:11742:              }
        -:11743:
   785540:11744:              MAPS_CORR[0][k] += htmp[i].w*sig_corr;
   785540:11745:              MAPS_COV [0][k] += htmp[i].w;
        -:11746:
   785540:11747:              if (Param->OUT_NOPOL[detset]%2==1 && htmp[i].vi!=UNSEENPIX) {
   196385:11748:                MAPS_CORR[1][k] += htmp[i].w*(sig_corr-htmp[i].vi);
   196385:11749:                MAPS_COV [1][k] += htmp[i].w;
        -:11750:              }
        -:11751:              else {
   589155:11752:                MAPS_CORR[1][k] += htmp[i].w*sig_corr*CO1;
   589155:11753:                MAPS_COV [1][k] += htmp[i].w*CO1;
        -:11754:              }
   785540:11755:              if (Param->OUT_NOPOL[detset]%2==1) {
   785540:11756:		double c2=x3[newnr[nbolo]+nbolo*(GAINSTEP)+(npixbeam-1-DOSYNCHRO)*nbolo+htmp[i].ib];
   785540:11757:		double s1=x3[newnr[nbolo]+nbolo*(GAINSTEP)+(npixbeam-1)*nbolo+htmp[i].ib];
   785540:11758:		double td1=x3[newnr[nbolo]+nbolo*(GAINSTEP)+(npixbeam-1-DOSYNCHRO-DOCO13)*nbolo+htmp[i].ib];
        -:11759:
   785540:11760:		if (DOTDUST==1)
    #####:11761:		  bandpass+=htmp[i].listofpix[npixbeam-1-DOSYNCHRO-DOCO13]*td1; // TDUST
   785540:11762:		if (DOCO13==1)
   785540:11763:		  bandpass+=htmp[i].listofpix[npixbeam-1-DOSYNCHRO]*c2; //13CO
   785540:11764:		if (DOSYNCHRO==1)
    #####:11765:		  bandpass+=htmp[i].listofpix[npixbeam-1]*s1; // SYNCHROTRON
        -:11766:
   785540:11767:		if (Param->OUT_NOPOL[0]%2==0) {
    #####:11768:		  if (htmp[i].vi!=UNSEENPIX) {
    #####:11769:		    MAPS_CORR[2][k] += htmp[i].w*(sig_corr+bandpass-htmp[i].vi-pbandpass);
    #####:11770:		    MAPS_COV [2][k] += htmp[i].w;
        -:11771:		  }
        -:11772:		}
        -:11773:		else {
   785540:11774:		    MAPS_CORR[2][k] += htmp[i].w*(sig_corr+bandpass);
   785540:11775:		    MAPS_COV [2][k] += htmp[i].w;
        -:11776:		}
        -:11777:
        -:11778:              }
        -:11779:              else {
    #####:11780:                MAPS_CORR[2][k] += htmp[i].w*sig_corr*SI1;
    #####:11781:                MAPS_COV [2][k] += htmp[i].w*SI1;
        -:11782:              }
   785540:11783:              MAPS_COV [3][k] += htmp[i].w*CO1*CO1;
   785540:11784:              MAPS_COV [4][k] += htmp[i].w*CO1*SI1;
   785540:11785:              MAPS_COV [5][k] += htmp[i].w*SI1*SI1;
   785540:11786:              MAPS_COV [6][k] += roundf( 1/(htmp[i].hit*htmp[i].hit));
        -:11787:
   785540:11788:	      if (detset==0&& current_survey== MAPFULL) {
   196385:11789:		double c1=x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[i].ib];
   196385:11790:		double c2=x3[newnr[nbolo]+nbolo*(GAINSTEP)+(npixbeam-1-DOSYNCHRO)*nbolo+htmp[i].ib];
   196385:11791:		double d1=x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[i].ib];
   196385:11792:		double f1=x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[i].ib];
   196385:11793:		double s1=x3[newnr[nbolo]+nbolo*(GAINSTEP)+(npixbeam-1)*nbolo+htmp[i].ib];
   196385:11794:		double td1=x3[newnr[nbolo]+nbolo*(GAINSTEP)+(npixbeam-1-DOSYNCHRO-DOCO13)*nbolo+htmp[i].ib];
        -:11795:
   196385:11796:		double sig_corr3=sig_corr;
   196385:11797:		if (nmatco!=0)
   196385:11798:		  sig_corr3+=htmp[i].comap*c1;  // 12CO
        -:11799:
   196385:11800:		if (nmatdust!=0)
   196385:11801:		  sig_corr3+=htmp[i].dustmap*d1; //DUST
        -:11802:
   196385:11803:		if (nfreefree!=0)
    #####:11804:		  sig_corr3+=htmp[i].freefree*f1; // FREEFREE
        -:11805:
   196385:11806:		if (DOTDUST==1)
    #####:11807:		  sig_corr3+=htmp[i].listofpix[npixbeam-1-DOSYNCHRO-DOCO13]*td1; // TDUST
        -:11808:
   196385:11809:		if (DOCO13==1)
   196385:11810:		  sig_corr3+=htmp[i].listofpix[npixbeam-1-DOSYNCHRO]*c2; //13CO
        -:11811:
   196385:11812:		if (DOSYNCHRO==1)
    #####:11813:		  sig_corr3+=htmp[i].listofpix[npixbeam-1]*s1; // SYNCHROTRON
        -:11814:
   196385:11815:		double sig_corr2=sig_corr;
   196385:11816:		if (nmatco!=0)
   196385:11817:		  sig_corr2+=htmp[i].comap*c1;  // 12CO
        -:11818:
   196385:11819:		if (DOCO13==1)
   196385:11820:		  sig_corr2+=htmp[i].listofpix[npixbeam-1-DOSYNCHRO]*c2; //13CO
        -:11821:
   196385:11822:		MAPS_CORR_CO[0+htmp[i].ib*3][k] += htmp[i].w*sig_corr2;
   196385:11823:		MAPS_CORR_CO[1+htmp[i].ib*3][k] += htmp[i].w*sig_corr2*CO1;
   196385:11824:		MAPS_CORR_CO[2+htmp[i].ib*3][k] += htmp[i].w*sig_corr2*SI1;
        -:11825:
   196385:11826:		MAPS_CORR_DUST[0+htmp[i].ib*3][k] += htmp[i].w*sig_corr3;
   196385:11827:		MAPS_CORR_DUST[1+htmp[i].ib*3][k] += htmp[i].w*sig_corr3*CO1;
   196385:11828:		MAPS_CORR_DUST[2+htmp[i].ib*3][k] += htmp[i].w*sig_corr3*SI1;
        -:11829:
   196385:11830:		MAPS_COV_DUST [0+htmp[i].ib*6][k] += htmp[i].w;
   196385:11831:		MAPS_COV_DUST [1+htmp[i].ib*6][k] += htmp[i].w*CO1;
   196385:11832:		MAPS_COV_DUST [2+htmp[i].ib*6][k] += htmp[i].w*SI1;
   196385:11833:		MAPS_COV_DUST [3+htmp[i].ib*6][k] += htmp[i].w*CO1*CO1;
   196385:11834:		MAPS_COV_DUST [4+htmp[i].ib*6][k] += htmp[i].w*CO1*SI1;
   196385:11835:		MAPS_COV_DUST [5+htmp[i].ib*6][k] += htmp[i].w*SI1*SI1;
        -:11836:	      }
        -:11837:            }
        -:11838:          }
        -:11839:        }
        -:11840:
       36:11841:        MPI_Barrier(MPI_COMM_WORLD);
        -:11842:        double l_th, l_ph; // local_theta, local_phi
        -:11843:        int p; // some map counter
        -:11844:
452984868:11845:        for (k=0;k<nnbpix;k++) {
452984832:11846:          long ndata = loc_nhpix[k];
452984832:11847:          hpix *htmp = loc_hpix[k];
452984832:11848:          if (detset==0 && isurv==0) {
 50331648:11849:            for (i=0;i<ndata;i++) htmp[i].vi=UNSEENPIX;
        -:11850:          }
        -:11851:
452984832:11852:          pix2ang_ring(Nside,k+begpix[rank],&l_th,&l_ph);
        -:11853:
452984832:11854:          if (MAPS_COV[0][k]>0) {
   452612:11855:            if (Param->OUT_NOPOL[detset]%2==1) {
   452612:11856:              MAPS_CORR[0][k]/=MAPS_COV[0][k];
   452612:11857:              if (MAPS_COV[1][k]>0) {
   310208:11858:                MAPS_CORR[1][k]/=MAPS_COV[1][k]; // get polar+bandpass cleanned version
        -:11859:              }
        -:11860:              else {
   142404:11861:                MAPS_CORR[1][k]=UNSEENPIX;
        -:11862:              }
   452612:11863:              if (MAPS_COV[2][k]>0) {
   452612:11864:                MAPS_CORR[2][k]/=MAPS_COV[2][k]; // get polar cleanned version
        -:11865:              }
        -:11866:              else {
    #####:11867:                MAPS_CORR[2][k]=UNSEENPIX;
        -:11868:              }
        -:11869:            }
        -:11870:            else {
    #####:11871:              solvemap(MAPS_CORR[0]+k,MAPS_CORR[1]+k,MAPS_CORR[2]+k,
    #####:11872:                       MAPS_COV[0][k],MAPS_COV[1][k],MAPS_COV[2][k],
    #####:11873:                       MAPS_COV[3][k],MAPS_COV[4][k],MAPS_COV[5][k]);
    #####:11874:              double cond=cond_3_3_thres(MAPS_COV[0][k],MAPS_COV[1][k],MAPS_COV[2][k],
    #####:11875:                                         MAPS_COV[1][k],MAPS_COV[3][k],MAPS_COV[4][k],
    #####:11876:                                         MAPS_COV[2][k],MAPS_COV[4][k],MAPS_COV[5][k]);
    #####:11877:              if (cond >= Param->seuilcond) {
    #####:11878:                for (p=0;p<7;p++) {
    #####:11879:                  MAPS_COV[p][k]=0;
        -:11880:                }
    #####:11881:                for (p=0;p<3;p++) {
    #####:11882:                  MAPS_CORR[p][k]=UNSEENPIX;
        -:11883:                }
        -:11884:              }
        -:11885:              else {
    #####:11886:                if (detset==0 && isurv==0) {
    #####:11887:                  for (i=0;i<ndata;i++) {
    #####:11888:                    double CO1 = eta[htmp[i].ib]*(dpsico[htmp[i].ib]*htmp[i].co
    #####:11889:                                 - dpsisi[htmp[i].ib]*htmp[i].si);
    #####:11890:                    double SI1 = eta[htmp[i].ib]*(dpsico[htmp[i].ib]*htmp[i].si
    #####:11891:                                 + dpsisi[htmp[i].ib]*htmp[i].co);
        -:11892:
    #####:11893:                    htmp[i].vi=CO1*MAPS_CORR[1][k]+SI1*MAPS_CORR[2][k];
        -:11894:                  }
        -:11895:                }
        -:11896:              }
        -:11897:            }
        -:11898:          }
        -:11899:          else {
3620257760:11900:            for (p=0;p<7;p++) {
3167725540:11901:              MAPS_COV[p][k]=0;
        -:11902:            }
1810128880:11903:            for (p=0;p<3;p++) {
1357596660:11904:              MAPS_CORR[p][k]=UNSEENPIX;
        -:11905:            }
        -:11906:          }
        -:11907:        }
       36:11908:        if (rank==0) fprintf(stderr,"%d %d : %ld %ld %ld\n",__LINE__,rank,(long) begpix[rank],(long) edpix[rank],(long) nnbpix);
        -:11909:
        -:11910:        // only save II,QQ,UU,etc. when not running stim or in first realisation of stim
       36:11911:        if ((stim_first_seed + iter == 0) && (Param->saveCOV == 1)) {
    #####:11912:          for (p=0;p<7;p++) {
        -:11913:            char suffix[10];
    #####:11914:            if (p==0) strcpy(suffix,"II");
    #####:11915:            if (Param->OUT_NOPOL[detset]%2!=1 || p==0 || p==6) {
    #####:11916:              if (p==1) strcpy(suffix,"IQ");
    #####:11917:              if (p==2) strcpy(suffix,"IU");
    #####:11918:              if (p==3) strcpy(suffix,"QQ");
    #####:11919:              if (p==4) strcpy(suffix,"QU");
    #####:11920:              if (p==5) strcpy(suffix,"UU");
    #####:11921:              if (p==6) strcpy(suffix,"HH");
        -:11922:
        -:11923:              char OUTMAP[MAXOUTMAP];
    #####:11924:              sprintf(OUTMAP,"%s_%s_%s", mapout[detset], mapname, suffix);
    #####:11925:              PIOWriteMAP(OUTMAP,MAPS_COV[p],begpix[rank],begpix[rank]+nnbpix-1);
    #####:11926:              MPI_Barrier(MPI_COMM_WORLD);
        -:11927:            }
        -:11928:          }
        -:11929:        }
        -:11930:
      144:11931:        for (p=0;p<3;p++) {
        -:11932:          char suffix[10];
      108:11933:          if (Param->OUT_NOPOL[detset]%2==0 || p==0 || (p==1 && Param->OUT_NOPOL[detset]%2==1 && Param->OUT_NOPOL[0]%2==0)|| (p==2 && Param->OUT_NOPOL[detset]%2==1)) {
       72:11934:            if (p==0) strcpy(suffix,"I");
       72:11935:            if (p==1) strcpy(suffix,"Q");
       72:11936:            if (p==1 && Param->OUT_NOPOL[detset]%2==1 && Param->OUT_NOPOL[0]%2==0) strcpy(suffix,"C"); // produce polarisation+bandpass "corrected" single bolo maps when used in a polarised detset
       72:11937:            if (p==2) strcpy(suffix,"U");
       72:11938:            if (p==2 && Param->OUT_NOPOL[detset]%2==1) strcpy(suffix,"D"); // produce polarisation "corrected" single bolo maps when used in a polarised detset
        -:11939:
        -:11940:            char OUTMAP[MAXOUTMAP];
       72:11941:            if (Param->flag_stim_paramfiles == 1) {
    #####:11942:              sprintf(OUTMAP,"%s_%03d_%s_%s",mapout[detset], (int) iter + stim_first_seed, mapname, suffix);
        -:11943:            } else {
       72:11944:              sprintf(OUTMAP,"%s_%s_%s", mapout[detset], mapname, suffix);
        -:11945:            }
       72:11946:            PIOWriteMAP(OUTMAP,MAPS_CORR[p],begpix[rank],begpix[rank]+nnbpix-1);
       72:11947:            MPI_Barrier(MPI_COMM_WORLD);
        -:11948:          }
        -:11949:        }
        -:11950:
        -:11951:	//===================================================================
        -:11952:	// COMPUTE CO MAP
       36:11953:	if (Param->saveCO) {
        -:11954:	  int l_ib;
        -:11955:
    #####:11956:	  for (l_ib=0;l_ib<nbolo;l_ib++) {
    #####:11957:	    for (p=0;p<6;p++) {
        -:11958:	      char suffix[6];
    #####:11959:	      if (p==0) strcpy(suffix,"II");
    #####:11960:	      if (p==1) strcpy(suffix,"IQ");
    #####:11961:	      if (p==2) strcpy(suffix,"IU");
    #####:11962:	      if (p==3) strcpy(suffix,"QQ");
    #####:11963:	      if (p==4) strcpy(suffix,"QU");
    #####:11964:	      if (p==5) strcpy(suffix,"UU");
        -:11965:
        -:11966:	      char OUTMAP[MAXOUTMAP];
    #####:11967:	      sprintf(OUTMAP,"%s_%s_%s_%s", mapout[detset], mapname, pixnames[l_ib], suffix);
    #####:11968:	      PIOWriteMAP(OUTMAP,MAPS_COV_DUST[p+l_ib*6],begpix[rank],begpix[rank]+nnbpix-1);
    #####:11969:	      MPI_Barrier(MPI_COMM_WORLD);
        -:11970:	    }
        -:11971:
    #####:11972:	    for (p=0;p<3;p++) {
        -:11973:	      char suffix[15];
    #####:11974:	      if (p==0) strcpy(suffix,"CO_SI");
    #####:11975:	      if (p==1) strcpy(suffix,"CO_SQ");
    #####:11976:	      if (p==2) strcpy(suffix,"CO_SU");
        -:11977:
        -:11978:	      char OUTMAP[MAXOUTMAP];
    #####:11979:	      sprintf(OUTMAP,"%s_%s_%s_%s", mapout[detset], mapname, pixnames[l_ib], suffix);
    #####:11980:	      PIOWriteMAP(OUTMAP,MAPS_CORR_CO[p+l_ib*3],begpix[rank],begpix[rank]+nnbpix-1);
    #####:11981:	      MPI_Barrier(MPI_COMM_WORLD);
        -:11982:	    }
    #####:11983:	    for (p=0;p<3;p++) {
        -:11984:	      char suffix[3];
    #####:11985:	      if (p==0) strcpy(suffix,"SI");
    #####:11986:	      if (p==1) strcpy(suffix,"SQ");
    #####:11987:	      if (p==2) strcpy(suffix,"SU");
        -:11988:
        -:11989:	      char OUTMAP[MAXOUTMAP];
    #####:11990:	      sprintf(OUTMAP,"%s_%s_%s_%s", mapout[detset], mapname, pixnames[l_ib], suffix);
    #####:11991:	      PIOWriteMAP(OUTMAP,MAPS_CORR_DUST[p+l_ib*3],begpix[rank],begpix[rank]+nnbpix-1);
    #####:11992:	      MPI_Barrier(MPI_COMM_WORLD);
        -:11993:	    }
        -:11994:	  }
        -:11995:
    #####:11996:	  for (i=0; i<6*nbolo; i++) {
    #####:11997:	    free(MAPS_COV_DUST[i]);
        -:11998:	  }
    #####:11999:	  for (i=0; i<3*nbolo; i++) {
    #####:12000:	    free(MAPS_CORR_CO[i]);
        -:12001:	  }
    #####:12002:	  for (i=0; i<3*nbolo; i++) {
    #####:12003:	    free(MAPS_CORR_DUST[i]);
        -:12004:	  }
        -:12005:	}
        -:12006:
       36:12007:        if (rank==0) fprintf(stderr,"line: %d rank: %d file: %s\n",__LINE__,rank,__FILE__);
       36:12008:        MPI_Barrier(MPI_COMM_WORLD);
       36:12009:        isurv++;
        -:12010:      }
        -:12011:    }
        -:12012:
       32:12013:    for (i=0;i<7;i++) {
       28:12014:      free(MAPS_COV[i]);
        -:12015:    }
       16:12016:    for (i=0;i<3;i++) {
       12:12017:      free(MAPS_CORR[i]);
        -:12018:    }
        -:12019:
        -:12020:  /*================================================================*/
        -:12021:  /*                                                                */
        -:12022:  /*        COMPUTE CHI2                                            */
        -:12023:  /*                                                                */
        -:12024:  /*================================================================*/
        -:12025:
        4:12026:  double *diff = (double *) malloc(32000*sizeof(double)*nbolo);
        4:12027:  double *diff2 = (double *) malloc(32000*sizeof(double)*nbolo);
        4:12028:  double *ndiff = (double *) malloc(32000*sizeof(double)*nbolo);
        -:12029:
        4:12030:  memset(diff,0,32000*sizeof(double)*nbolo);
        4:12031:  memset(diff2,0,32000*sizeof(double)*nbolo);
        4:12032:  memset(ndiff,0,32000*sizeof(double)*nbolo);
        -:12033:
 50331652:12034:  for (k=0;k<nnbpix;k++) {
 50331648:12035:    long ndata = loc_nhpix[k];
 50331648:12036:    hpix *htmp = loc_hpix[k];
        -:12037:
 50331648:12038:    if (ndata>0&&flgpix[k]>0) {
    19487:12039:      double SII=0;
    19487:12040:      double SIQ=0;
    19487:12041:      double SIU=0;
    19487:12042:      double SQQ=0;
    19487:12043:      double SUU=0;
    19487:12044:      double SQU=0;
        -:12045:
    19487:12046:      double SI=0;
    19487:12047:      double SQ=0;
    19487:12048:      double SU=0;
        -:12049:
        -:12050:      int l1,m;
        -:12051:
    89281:12052:      for (l1=0;l1<ndata;l1++) {
    69794:12053:	long ri1=htmp[l1].rg-globalBeginRing;
    69794:12054:	long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
    69794:12055:	if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -:12056:
   139588:12057:	  double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    69794:12058:					    -dpsisi[htmp[l1].ib]*htmp[l1].si);
   139588:12059:	  double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    69794:12060:					    +dpsisi[htmp[l1].ib]*htmp[l1].co);
        -:12061:
    69794:12062:	  double gg2=gain[htmp[l1].ib];
        -:12063:
    69794:12064:	  double sig_corr = htmp[l1].sig*gg2-htmp[l1].fsl-htmp[l1].corr_nl-htmp[l1].corr_cnn;
    69794:12065:	  if (REMHDIP==0) sig_corr-=htmp[l1].dip;
    69794:12066:	  else sig_corr-=htmp[l1].freefree;
        -:12067:
    69794:12068:	  sig_corr-=x3[iri1];
        -:12069:
        -:12070:	  // ATTENTION GAINSTEP EST FORCE A 1
    69794:12071:	  sig_corr-=x3[newnr[nbolo]+htmp[l1].ib]*htmp[l1].model;
        -:12072:
    69794:12073:	  if (nmatco!=0) {
    69794:12074:	    sig_corr -=htmp[l1].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib];
        -:12075:	  }
        -:12076:
    69794:12077:	  if (nmatdust!=0) {
    69794:12078:	    sig_corr -=htmp[l1].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib];
        -:12079:	  }
    69794:12080:	  if (nfreefree!=0) {
    #####:12081:	    sig_corr -=htmp[l1].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib];
        -:12082:	  }
   628146:12083:	  for (m=0;m<npixbeam;m++)  {
   558352:12084:	    sig_corr -= htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -:12085:	  }
    69794:12086:	  SI +=htmp[l1].w*sig_corr;
    69794:12087:	  SQ +=htmp[l1].w*CO1*sig_corr;
    69794:12088:	  SU +=htmp[l1].w*SI1*sig_corr;
        -:12089:
    69794:12090:	  SII +=htmp[l1].w;
    69794:12091:	  SIQ +=htmp[l1].w*CO1;
    69794:12092:	  SIU +=htmp[l1].w*SI1;
    69794:12093:	  SQQ +=htmp[l1].w*CO1*CO1;
    69794:12094:	  SQU +=htmp[l1].w*CO1*SI1;
    69794:12095:	  SUU +=htmp[l1].w*SI1*SI1;
        -:12096:	}
        -:12097:      }
    19487:12098:      if (Param->OUT_NOPOL[0]%2==0) {
    #####:12099:	double cond=cond_3_3_thres(SII,SIQ,SIU,
        -:12100:				   SIQ,SQQ,SQU,
        -:12101:				   SIU,SQU,SUU);
        -:12102:
    #####:12103:	if (cond<Param->seuilcond) {
    #####:12104:	  solvemap(&SI,&SQ,&SU,SII,SIQ,SIU,SQQ,SQU,SUU);
        -:12105:
        -:12106:	}
        -:12107:      }
        -:12108:
        -:12109:
    89281:12110:      for (l1=0;l1<ndata;l1++) {
    69794:12111:	long ri1=htmp[l1].rg-globalBeginRing;
    69794:12112:	long iri1=rgord[htmp[l1].ib][ri1]+newnr[htmp[l1].ib];
    69794:12113:	if (flg_rg[htmp[l1].ib][ri1]!=0) {
        -:12114:
   139588:12115:	  double CO1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].co
    69794:12116:					    -dpsisi[htmp[l1].ib]*htmp[l1].si);
   139588:12117:	  double SI1=eta_dest[htmp[l1].ib]*(dpsico[htmp[l1].ib]*htmp[l1].si
    69794:12118:					    +dpsisi[htmp[l1].ib]*htmp[l1].co);
        -:12119:
    69794:12120:	  double gg2=gain[htmp[l1].ib];
        -:12121:
    69794:12122:	  double sig_corr = htmp[l1].sig*gg2-htmp[l1].fsl-htmp[l1].corr_nl-htmp[l1].corr_cnn;
    69794:12123:	  if (REMHDIP==0) sig_corr-=htmp[l1].dip;
    69794:12124:	  else sig_corr-=htmp[l1].freefree;
        -:12125:
    69794:12126:	  sig_corr-=x3[iri1];
        -:12127:
        -:12128:	  // ATTENTION GAINSTEP EST FORCE A 1
    69794:12129:	  sig_corr-=x3[newnr[nbolo]+htmp[l1].ib]*htmp[l1].model;
        -:12130:
    69794:12131:	  if (nmatco!=0) {
    69794:12132:	    sig_corr -=htmp[l1].comap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+htmp[l1].ib];
        -:12133:	  }
        -:12134:
    69794:12135:	  if (nmatdust!=0) {
    69794:12136:	    sig_corr -=htmp[l1].dustmap*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+htmp[l1].ib];
        -:12137:	  }
    69794:12138:	  if (nfreefree!=0) {
    #####:12139:	    sig_corr -=htmp[l1].freefree*x3[newnr[nbolo]+nbolo*(npixbeam+GAINSTEP)+nmatco+nmatdust+htmp[l1].ib];
        -:12140:	  }
   628146:12141:	  for (m=0;m<npixbeam;m++)  {
   558352:12142:	    sig_corr -= htmp[l1].listofpix[m]*x3[newnr[nbolo]+nbolo*(GAINSTEP)+m*nbolo+htmp[l1].ib];
        -:12143:	  }
        -:12144:
    69794:12145:	  double tmp=sig_corr;
    69794:12146:	  if (REFMAPI==NULL) tmp-=SI+SQ*CO1+SU*SI1;
    #####:12147:	  else tmp-=REFMAPI[k]+REFMAPQ[k]*CO1+REFMAPU[k]*SI1;
    69794:12148:	  diff2[htmp[l1].rg+32000*htmp[l1].ib] += htmp[l1].w*tmp*tmp;
    69794:12149:	  diff[htmp[l1].rg+32000*htmp[l1].ib]  += htmp[l1].w*tmp;
    69794:12150:	  ndiff[htmp[l1].rg+32000*htmp[l1].ib] += htmp[l1].w;
        -:12151:	}
        -:12152:      }
        -:12153:    }
        -:12154:  }
        -:12155:
        -:12156:
        4:12157:  if (rank==0) {
        -:12158:    long l;
        1:12159:    double *lb = (double *) malloc(sizeof(double)*(nbolo*32000));
        4:12160:    for (rrk=1;rrk<mpi_size;rrk++) {
        3:12161:      MPI_Recv(lb,sizeof(double)*(nbolo*32000), MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
        3:12162:      for (l=0;l<nbolo*32000;l++) diff[l]+=lb[l];
        3:12163:      MPI_Recv(lb,sizeof(double)*(nbolo*32000), MPI_BYTE, rrk,1031, MPI_COMM_WORLD,&statu);
        3:12164:      for (l=0;l<nbolo*32000;l++) diff2[l]+=lb[l];
        3:12165:      MPI_Recv(lb,sizeof(double)*(nbolo*32000), MPI_BYTE, rrk,1032, MPI_COMM_WORLD,&statu);
        3:12166:      for (l=0;l<nbolo*32000;l++) ndiff[l]+=lb[l];
        -:12167:    }
        1:12168:    free(lb);
        -:12169:    char saveg[256];
        -:12170:
        5:12171:    for (i=0;i<nbolo;i++) {
        4:12172:      sprintf(saveg,"%s_diff",Param->Out_xi2_corr[i]);
        4:12173:      fprintf(stderr,"Write DIFF  %lld\n",(long long) PIOWriteVECT(saveg,diff+i*32000,0,sizeof(PIODOUBLE)*(32000)));
        4:12174:      sprintf(saveg,"%s_diff2",Param->Out_xi2_corr[i]);
        4:12175:      fprintf(stderr,"Write DIFF2  %lld\n",(long long) PIOWriteVECT(saveg,diff2+i*32000,0,sizeof(PIODOUBLE)*(32000)));
        4:12176:      sprintf(saveg,"%s_ndiff",Param->Out_xi2_corr[i]);
        4:12177:      fprintf(stderr,"Write NDIFF  %lld\n",(long long) PIOWriteVECT(saveg,ndiff+i*32000,0,sizeof(PIODOUBLE)*(32000)));
        -:12178:    }
        -:12179:  }
        -:12180:  else {
        3:12181:    MPI_Send(diff, sizeof(double)*(nbolo*32000), MPI_BYTE, 0, 1031, MPI_COMM_WORLD);
        3:12182:    MPI_Send(diff2, sizeof(double)*(nbolo*32000), MPI_BYTE, 0, 1031, MPI_COMM_WORLD);
        3:12183:    MPI_Send(ndiff, sizeof(double)*(nbolo*32000), MPI_BYTE, 0, 1032, MPI_COMM_WORLD);
        -:12184:  }
        -:12185:  } // while (iter++ < number_of_iterations)
        -:12186:
        4:12187:  MPI_Barrier(MPI_COMM_WORLD);
        -:12188:
        4:12189:  if (python_rank==0) {
        4:12190:    CleanPython(&MyPythonBackend);
        -:12191:  }
        4:12192:  if (rank==0) {
        1:12193:    now = time( NULL);
        1:12194:    fprintf(stderr, "%s: --------------------------\n", __FILE__ );
        1:12195:    fprintf(stderr, "%s: Finished sucessfully at %s",   __FILE__, ctime( &now));
        1:12196:    fprintf(stderr, "%s: --------------------------\n", __FILE__ );
        -:12197:  }
        -:12198:
        4:12199:  if (Param->flag_DOCNN==_PAR_TRUE) {
        4:12200:    if (python_rank==0) MPI_Comm_free(&tensorflow_comm);
        4:12201:    MPI_Comm_free(&python_comm);
        -:12202:  }
        -:12203:  
        4:12204:  MPI_Finalize();        /* free parameters info */
        -:12205:
        4:12206:  exit (0);
        -:12207:}
        -:12208:

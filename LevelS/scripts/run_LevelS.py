#!/usr/bin/env python

from __future__ import division, print_function

import os
import sys
import time
from copy import copy
import subprocess

from IMO_4_27 import * # BOLOID, DETSETS, CALIB, etc.


################################################################################

class LSParameters( object):
  def __init__( self):
    # read environment
    try:
      self.SROLLHOST = os.environ["SROLLHOST"]
      self.SROLLDIR  = os.environ["SROLLDIR"]
      self.NODMCDATA = os.environ["NODMCDATA"]
      self.USER      = os.environ["USER"]
    except:
      raise Exception( "You must 'source ./srollex_setenv.sh' before using this script")
    self.scriptfilename = os.path.realpath( __file__)
    # default paths
    self.LSBINDIR  = self.SROLLDIR  + "/LevelS/LevelS-2015-01-09/linux_gcc/bin"
    if self.SROLLHOST == "M4":
      self.LSFITSDIR = "/bluevan1/symottet/LevelS_mission_fits"
    else:
      self.LSFITSDIR = self.NODMCDATA + "/LevelS_mission_fits"
    self.BEAM_TPL  = self.LSFITSDIR + "/DX11v67_HFI_scanning_beams/BS_HBM_DX11v67_I5_HIGHRES_POLAR_{pixname}_xp_alm.fits"
    # default parameters
    self.nodes        = 1
    self.ppn          = 24
    self.outdir       = ""  # directory where parameter and data files will be stored
    self.run_name     = ""
    self.prefix       = ""  # prefix of the parmeter file and generated object names
    self.dipole       = "T" # dipole type, "S" for solar, "O" for orbital, "T" for total (S+O), "" for none
    self.dipole_type  = 8   # 2 for FFP10, 8 for APR20
    self.solar_dipole = "HFI2018" # unused, hard coded in $SROLLDIR/LevelS/LevelS-2015-01-09/cxxmod/dipole.cc
    self.insky_map    = ""  # name of input sky map. if not empty, anafast will be used to convert to alm
    self.sky_alm      = ""  # name of input sky alm. if not empty, anafast is skipped and conviqt is used
    self.ringset      = ""  # name of input sky ring set. if not empty, conviqt is skipped and multimod is used
    self.beam         = "S" # beam type, "S" for scanning, "G" for 10 arcmin FWHM gaussian beam, TODO: GRASP?
    self.fwhm         = 0   # conviqt deconv beam, must be 0 for FFP10/JAN18/APR20
    self.begring      = 240
    self.endring      = 26050
    self.pixname      = "100-1a"
    self.do_hpr       = True
    self.submit       = False


################################################################################
# Generate magique4 batch submission script

def submit_m4( params, cmd, lbl, run=False):

  script = """
#!/bin/sh
#PBS -S /bin/sh
#PBS -N {lbl}
#PBS -j oe
#PBS -l nodes=1:ppn=24,walltime=12:00:00

cd {params.SROLLDIR}
source ./srollex_setenv.sh

#export OMP_NUM_THREADS=1

cd {params.outdir}
{cmd}
""".format( **locals())

  script_name = params.parfile_name + ".m4qsub"
  with open( script_name, 'w') as f:
    f.write( script)
  print( "\nWritten " + script_name)

  if run:
    cmd = "qsub " + script_name
    print( "running " + cmd)
    subprocess.call( cmd, shell=True)


################################################################################
# Generate conviqt parameter file and run

def run_conviqt( params, run=False):

  params.prefix       = "%s/%s_%s" % (params.outdir, params.run_name, params.pixname)
  params.ringset      = params.prefix + "_RSET.fits"
  params.parfile_name = params.prefix + ".conviqt.par"

  beam_alm     = params.BEAM_TPL.format( **vars( params))
  cmd          = "{params.LSBINDIR}/conviqt_v3 {params.parfile_name}".format( **locals())
  strnow       = time.ctime()

  parfile = """
# LevelS conviqt parameter file
# generated by {params.scriptfilename}
# for {params.USER}
# on {params.SROLLHOST}
# at {strnow}
# run with '{cmd}'

# input sky alm
sky_alm = {params.sky_alm}

# input beam alm
beam_alm = {beam_alm}

# fwhm_deconv = 0 for FFP10 PSM, input maps are not smoothed by a gaussian beam
fwhm_deconv = {params.fwhm}

polarisation = T

#nphi   =
#ntheta =

conv_lmax = 4800
lmax_out  = 4800
beammmax  = 14

# output ringset
ringset = {params.ringset}

""".format( **locals())

  with open( params.parfile_name, 'w') as f:
    f.write( parfile)
  print( "\nWritten " + params.parfile_name)

  if run:
    # clear outputs
    if os.path.exists( params.ringset):
      os.remove( params.ringset)
    # and call conviqt
    print( "running " + cmd)
    subprocess.call( cmd, shell=True)
  else:
    print( "  - run with " + cmd)
  

################################################################################
# generate multimod parameter file and run

def run_multimod( params, run=False):

  params.boloid       = BOLOID[params.pixname]
  params.prefix       = "%s/%s_%s" % (params.outdir, params.run_name, params.pixname)
  params.parfile_name = params.prefix + ".multimod.par"
  params.tod_file     = params.prefix + "_mmTOI.fits"
  params.map_file     = params.prefix + "_mmMAP.fits"
  params.detpt_file   = params.prefix + "_DETPT.fits"

  cmd    = "{params.LSBINDIR}/multimod {params.parfile_name}".format( **locals())
  strnow = time.ctime()

  # LevelS ring numbers start at 1 instead of 0
  params.ls_begring = params.begring + 1
  params.ls_endring = params.endring + 1

  if params.dipole == "":
    params.source_dipole = "F"
    params.dipole_speed = "TOTAL"
  elif params.dipole == "T":
    params.source_dipole = "T"
    params.dipole_speed = "TOTAL"
  elif params.dipole == "S":
    params.source_dipole = "T"
    params.dipole_speed = "SOLSYS"
  elif params.dipole == "O":
    params.source_dipole = "T"
    params.dipole_speed = "SATELLITE"
  else:
    raise Exception( "Unknown LSParameters.dipole value: <%s> (must be 'T'(otal), 'S'(olar) or 'O'(rbital))" % params.dipole)

  # at 545/857, in and out data are in MJY/sr, not KCMB, then set the dipole factor to KCMB_to_MJy/sr
  if params.pixname[0:3] in ("545", "857"):
    dip_norm = KCMB2MJY[params.pixname]
  else:
    dip_norm = 1.0

  if params.ringset != "":
    params.source_mixed = "T"
  else:
    params.source_mixed = "F"

  parfile = """
# LevelS multimod parameter file
# generated by {params.scriptfilename}
# for {params.USER}
# on {params.SROLLHOST}
# at {strnow}
# run with '{cmd}'

detector_id              = {params.boloid}
nominal_pointing         = F
satinfo_type             = HFI
first_pointing           = {params.ls_begring}
last_pointing            = {params.ls_endring}
oversampling_factor      = 1.0
single_precision_detpt   = T
nside                    = 2048
calibrate_signal         = T
bypass_sampler           = T
sampler_timeshift        = 0.0
detpt_aberration         = T
interpol_order           = 11
output_type              = SIGNAL
interpol_galactic        = T
source_dipole            = {params.source_dipole}
source_fsldp             = F
dipole_thermotemp        = T
dipole_speed             = {params.dipole_speed}
dipole_type              = {params.dipole_type}
dip_norm                 = {dip_norm}
source_oof               = F
source_pntsrc            = F
beam_file_type           = 0
beam_radius_max          = 2.0
variable_pntsrc_factor   = 1.0
source_mixed             = {params.source_mixed}
source_mixed2            = F
verbose                  = 1

# input mission fits
focalplane_db        = {params.LSFITSDIR}/fpdb_IMO_4_27.fits
satinfo_ephemeris    = {params.LSFITSDIR}/ephemeris.fits
satinfo_quaternions  = {params.LSFITSDIR}/quaternions_27100.fits
satinfo_ctr          = {params.LSFITSDIR}/ctr.fits
satinfo_indexobject  = {params.LSFITSDIR}/ringindex_begin_end.fits

# input sky map ringset
ringset              = {params.ringset}

# output Time Ordered Data / TOI
tod_file             = {params.tod_file}

# optional output map and detector pointing
map_file             = {params.map_file}
#detpt_file           = {params.detpt_file}

""".format( **locals())

  with open( params.parfile_name, 'w') as f:
    f.write( parfile)
  print( "\nWritten " + params.parfile_name)

  if run:
    # clear outputs
    for fname in [params.tod_file, params.map_file, params.detpt_file]:
      if os.path.exists( fname):
        os.remove( fname)
    # and submit multimod job
    lbl = "mmod_{params.run_name}_{params.pixname}".format( **locals())
    cmd += " &> {params.parfile_name}.log".format( **locals())
    submit_m4( params, cmd, lbl, run=True)
  else:
    print( "  - run with " + cmd)


################################################################################

def run_APR20_conviqt( detset):

  pixlist = DETSETS[detset]
  for pixname in pixlist:
    params = LSParameters()
    params.outdir   = "/bluevan1/symottet/APR20_levels/conviqt_sky_ringsets"
    params.run_name = "APR20"
    params.pixname  = pixname
    params.sky_alm  = "/bluevan1/symottet/APR20_sky_alm/APR20_sky_alm_%s.fits" % pixname
    run_conviqt( params, run=True)


################################################################################

def run_APR20_multimod( detset):

  pixlist = DETSETS[detset]
  pixcount = len( pixlist)
  for i, pixname in enumerate( pixlist, 1):
    params = LSParameters()
    params.outdir      = "/bluevan1/symottet/APR20_levels/multimod_sky_toi"
    params.pixname     = pixname
    params.begring     = 230
    params.endring     = 26100
    params.dipole_type = 8 # 2 for FFP10, 8 for APR20 (2 + kinetic quadrupole)
    params.run_name    = "APR20_dipole"
    params.ringset     = "" # no input ringset for dipole-only TOI
    run_multimod( params, run=True)

    params.run_name = "APR20_sky"
    params.ringset  = "/bluevan1/symottet/APR20_levels/conviqt_sky_ringsets/APR20_{pixname}_RSET.fits".format( **vars( params))
    run_multimod( params, run=True)
    if i < len( pixlist):
      w = 120
      print( "waiting %d seconds for the IO peak before submitting next multimod..." % w)
      time.sleep( w)


################################################################################


if __name__ == '__main__':

  if (len( sys.argv) != 3) or not (sys.argv[1] in ("conviqt", "multimod")) or not (sys.argv[2] in DETSETS.keys()):
    print( "usage: %s <program> <pixname_or_detset>" % sys.argv[0])
    print( "  where <program> is 'conviqt' or 'multimod'")
    print( "  if <program> is 'conviqt', should be run in 'qsub -I -l nodes=1:ppn=24,walltime=4:00:00' on magique4")
    print( "  if <program> is 'multimod', a magique4 batch script per bolometer will be written and submitted")
    print( "")
    exit( 1)

  if sys.argv[1] == "conviqt":
    run_APR20_conviqt( sys.argv[2])

  if sys.argv[1] == "multimod":
    run_APR20_multimod( sys.argv[2])

exit(0)











################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

# Writes the parameter file for anafast

def write_anafast_par( params):

# TODO

  content = """# run with:
# .../LevelS_***/m4_linux_gcc/bin/anafast_cxx anafast_par_file.par


nlmax = 4800
nmmax = 4800

infile       = """+ sky_map_file +"""
# no power spectrum
outfile      =
outfile_alms = """+ OUT_FILES_DEST + outfile_alm +""".fits

polarisation = T

# no ring weights
ringweights  =

iter_order   = 3
double_precision = F

#remove_monopole  ="""

  par_file = open(PAR_FILES_DEST+par_file_name+".par", 'w')
  par_file.write(content)
  par_file.close()


################################################################################

# Writes the qsub file for a general LevelS run

def write_LevelS_qsub( params):
  
# TODO
  
  lspars = copy( params)

  if (lspars.endring - lspars.begring) <= 1000:
    lspars.walltime = "00:30:00"
  else:
    lspars.walltime = "02:00:00"

  lspars.job_label = "LS_{prefix}_{pixname}".format( **vars( lspars))

  script = """#!/bin/sh
#PBS -S /bin/sh
#PBS -N {job_label}
#PBS -j oe
#PBS -l nodes={nodes}:ppn={ppn},walltime={walltime}

cd {SROLLDIR}
source ./srollex_setenv.sh

PARFILE={out_prefix}.mutlimod.par
# find 'tod_file', 'map_file' and 'detpt_file' in mm parameter file and remove the existing files before new mm run
grep ^tod_file $PARFILE | cut -d= -f2 | xargs rm
grep ^map_file $PARFILE | cut -d= -f2 | xargs rm
grep ^detpt_file $PARFILE | cut -d= -f2 | xargs rm

{LSBINDIR}/multimod {out_prefix}.mutlimod.par &> {out_prefix}.mutlimod.log

exit 0

""".format( **vars( lspars))

  script_name = params.out_prefix + ".qsub"
  with open( script_name, 'w') as f:
    f.write( script)
  print( "Written " + script_name)


################################################################################

def run_LevelS( params):

# TODO

  # initialise output directory
  if params.outdir == "":
    params.outdir = params.NODMCDATA + "/" + params.USER
  if params.outdir[0] != "/":
    params.outdir = params.NODMCDATA + "/" + params.outdir
  if not os.path.isdir( params.outdir):
      os.mkdir( params.outdir)

  # initialise output filename prefix
  params.out_prefix = "{outdir}/{prefix}_{pixname}".format( **vars( params))

  # test if we run anafast
  if params.insky_map != "":
    # run anafast
    params.anafast = True
    write_anafast_par( params)
  else:
    params.anafast = False

  # test if we run conviqt
  if params.anafast or (params.sky_alm != ""):
    # run conviqt
    params.conviqt = True
    write_conviqt_par( params)
  else:
    params.conviqt = False

  # run multimod
  write_multimod_par( params)

  # generate the LevelS submission script
  write_LevelS_qsub( params)

  # Launch the qsub job if requested
  if params.submit:
    os.system( "qsub " + params.out_prefix + ".qsub")


